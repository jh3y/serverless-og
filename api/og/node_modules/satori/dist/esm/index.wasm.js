var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/tsup@5.12.9_typescript@4.8.3/node_modules/tsup/assets/esm_shims.js
var init_esm_shims = __esm({
  "node_modules/.pnpm/tsup@5.12.9_typescript@4.8.3/node_modules/tsup/assets/esm_shims.js"() {
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/negateValue.js
var require_negateValue = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/negateValue.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => _default
    });
    function _default(value) {
      value = `${value}`;
      if (value === "0") {
        return "0";
      }
      if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(value)) {
        return value.replace(/^[+-]?/, (sign) => sign === "-" ? "" : "-");
      }
      if (value.includes("var(") || value.includes("calc(")) {
        return `calc(${value} * -1)`;
      }
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/corePluginList.js
var require_corePluginList = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/corePluginList.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => _default
    });
    var _default = [
      "preflight",
      "container",
      "accessibility",
      "pointerEvents",
      "visibility",
      "position",
      "inset",
      "isolation",
      "zIndex",
      "order",
      "gridColumn",
      "gridColumnStart",
      "gridColumnEnd",
      "gridRow",
      "gridRowStart",
      "gridRowEnd",
      "float",
      "clear",
      "margin",
      "boxSizing",
      "display",
      "aspectRatio",
      "height",
      "maxHeight",
      "minHeight",
      "width",
      "minWidth",
      "maxWidth",
      "flex",
      "flexShrink",
      "flexGrow",
      "flexBasis",
      "tableLayout",
      "borderCollapse",
      "borderSpacing",
      "transformOrigin",
      "translate",
      "rotate",
      "skew",
      "scale",
      "transform",
      "animation",
      "cursor",
      "touchAction",
      "userSelect",
      "resize",
      "scrollSnapType",
      "scrollSnapAlign",
      "scrollSnapStop",
      "scrollMargin",
      "scrollPadding",
      "listStylePosition",
      "listStyleType",
      "appearance",
      "columns",
      "breakBefore",
      "breakInside",
      "breakAfter",
      "gridAutoColumns",
      "gridAutoFlow",
      "gridAutoRows",
      "gridTemplateColumns",
      "gridTemplateRows",
      "flexDirection",
      "flexWrap",
      "placeContent",
      "placeItems",
      "alignContent",
      "alignItems",
      "justifyContent",
      "justifyItems",
      "gap",
      "space",
      "divideWidth",
      "divideStyle",
      "divideColor",
      "divideOpacity",
      "placeSelf",
      "alignSelf",
      "justifySelf",
      "overflow",
      "overscrollBehavior",
      "scrollBehavior",
      "textOverflow",
      "whitespace",
      "wordBreak",
      "borderRadius",
      "borderWidth",
      "borderStyle",
      "borderColor",
      "borderOpacity",
      "backgroundColor",
      "backgroundOpacity",
      "backgroundImage",
      "gradientColorStops",
      "boxDecorationBreak",
      "backgroundSize",
      "backgroundAttachment",
      "backgroundClip",
      "backgroundPosition",
      "backgroundRepeat",
      "backgroundOrigin",
      "fill",
      "stroke",
      "strokeWidth",
      "objectFit",
      "objectPosition",
      "padding",
      "textAlign",
      "textIndent",
      "verticalAlign",
      "fontFamily",
      "fontSize",
      "fontWeight",
      "textTransform",
      "fontStyle",
      "fontVariantNumeric",
      "lineHeight",
      "letterSpacing",
      "textColor",
      "textOpacity",
      "textDecoration",
      "textDecorationColor",
      "textDecorationStyle",
      "textDecorationThickness",
      "textUnderlineOffset",
      "fontSmoothing",
      "placeholderColor",
      "placeholderOpacity",
      "caretColor",
      "accentColor",
      "opacity",
      "backgroundBlendMode",
      "mixBlendMode",
      "boxShadow",
      "boxShadowColor",
      "outlineStyle",
      "outlineWidth",
      "outlineOffset",
      "outlineColor",
      "ringWidth",
      "ringColor",
      "ringOpacity",
      "ringOffsetWidth",
      "ringOffsetColor",
      "blur",
      "brightness",
      "contrast",
      "dropShadow",
      "grayscale",
      "hueRotate",
      "invert",
      "saturate",
      "sepia",
      "filter",
      "backdropBlur",
      "backdropBrightness",
      "backdropContrast",
      "backdropGrayscale",
      "backdropHueRotate",
      "backdropInvert",
      "backdropOpacity",
      "backdropSaturate",
      "backdropSepia",
      "backdropFilter",
      "transitionProperty",
      "transitionDelay",
      "transitionDuration",
      "transitionTimingFunction",
      "willChange",
      "content"
    ];
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/configurePlugins.js
var require_configurePlugins = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/configurePlugins.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => _default
    });
    function _default(pluginConfig, plugins) {
      if (pluginConfig === void 0) {
        return plugins;
      }
      const pluginNames = Array.isArray(pluginConfig) ? pluginConfig : [
        ...new Set(plugins.filter((pluginName) => {
          return pluginConfig !== false && pluginConfig[pluginName] !== false;
        }).concat(Object.keys(pluginConfig).filter((pluginName) => {
          return pluginConfig[pluginName] !== false;
        })))
      ];
      return pluginNames;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/stubs/defaultConfig.stub.js
var require_defaultConfig_stub = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/stubs/defaultConfig.stub.js"(exports, module) {
    init_esm_shims();
    module.exports = {
      content: [],
      presets: [],
      darkMode: "media",
      theme: {
        screens: {
          sm: "640px",
          md: "768px",
          lg: "1024px",
          xl: "1280px",
          "2xl": "1536px"
        },
        colors: ({ colors }) => ({
          inherit: colors.inherit,
          current: colors.current,
          transparent: colors.transparent,
          black: colors.black,
          white: colors.white,
          slate: colors.slate,
          gray: colors.gray,
          zinc: colors.zinc,
          neutral: colors.neutral,
          stone: colors.stone,
          red: colors.red,
          orange: colors.orange,
          amber: colors.amber,
          yellow: colors.yellow,
          lime: colors.lime,
          green: colors.green,
          emerald: colors.emerald,
          teal: colors.teal,
          cyan: colors.cyan,
          sky: colors.sky,
          blue: colors.blue,
          indigo: colors.indigo,
          violet: colors.violet,
          purple: colors.purple,
          fuchsia: colors.fuchsia,
          pink: colors.pink,
          rose: colors.rose
        }),
        columns: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          "3xs": "16rem",
          "2xs": "18rem",
          xs: "20rem",
          sm: "24rem",
          md: "28rem",
          lg: "32rem",
          xl: "36rem",
          "2xl": "42rem",
          "3xl": "48rem",
          "4xl": "56rem",
          "5xl": "64rem",
          "6xl": "72rem",
          "7xl": "80rem"
        },
        spacing: {
          px: "1px",
          0: "0px",
          0.5: "0.125rem",
          1: "0.25rem",
          1.5: "0.375rem",
          2: "0.5rem",
          2.5: "0.625rem",
          3: "0.75rem",
          3.5: "0.875rem",
          4: "1rem",
          5: "1.25rem",
          6: "1.5rem",
          7: "1.75rem",
          8: "2rem",
          9: "2.25rem",
          10: "2.5rem",
          11: "2.75rem",
          12: "3rem",
          14: "3.5rem",
          16: "4rem",
          20: "5rem",
          24: "6rem",
          28: "7rem",
          32: "8rem",
          36: "9rem",
          40: "10rem",
          44: "11rem",
          48: "12rem",
          52: "13rem",
          56: "14rem",
          60: "15rem",
          64: "16rem",
          72: "18rem",
          80: "20rem",
          96: "24rem"
        },
        animation: {
          none: "none",
          spin: "spin 1s linear infinite",
          ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
          pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
          bounce: "bounce 1s infinite"
        },
        aspectRatio: {
          auto: "auto",
          square: "1 / 1",
          video: "16 / 9"
        },
        backdropBlur: ({ theme }) => theme("blur"),
        backdropBrightness: ({ theme }) => theme("brightness"),
        backdropContrast: ({ theme }) => theme("contrast"),
        backdropGrayscale: ({ theme }) => theme("grayscale"),
        backdropHueRotate: ({ theme }) => theme("hueRotate"),
        backdropInvert: ({ theme }) => theme("invert"),
        backdropOpacity: ({ theme }) => theme("opacity"),
        backdropSaturate: ({ theme }) => theme("saturate"),
        backdropSepia: ({ theme }) => theme("sepia"),
        backgroundColor: ({ theme }) => theme("colors"),
        backgroundImage: {
          none: "none",
          "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
          "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
          "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
          "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
          "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
          "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
          "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
          "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
        },
        backgroundOpacity: ({ theme }) => theme("opacity"),
        backgroundPosition: {
          bottom: "bottom",
          center: "center",
          left: "left",
          "left-bottom": "left bottom",
          "left-top": "left top",
          right: "right",
          "right-bottom": "right bottom",
          "right-top": "right top",
          top: "top"
        },
        backgroundSize: {
          auto: "auto",
          cover: "cover",
          contain: "contain"
        },
        blur: {
          0: "0",
          none: "0",
          sm: "4px",
          DEFAULT: "8px",
          md: "12px",
          lg: "16px",
          xl: "24px",
          "2xl": "40px",
          "3xl": "64px"
        },
        brightness: {
          0: "0",
          50: ".5",
          75: ".75",
          90: ".9",
          95: ".95",
          100: "1",
          105: "1.05",
          110: "1.1",
          125: "1.25",
          150: "1.5",
          200: "2"
        },
        borderColor: ({ theme }) => ({
          ...theme("colors"),
          DEFAULT: theme("colors.gray.200", "currentColor")
        }),
        borderOpacity: ({ theme }) => theme("opacity"),
        borderRadius: {
          none: "0px",
          sm: "0.125rem",
          DEFAULT: "0.25rem",
          md: "0.375rem",
          lg: "0.5rem",
          xl: "0.75rem",
          "2xl": "1rem",
          "3xl": "1.5rem",
          full: "9999px"
        },
        borderSpacing: ({ theme }) => ({
          ...theme("spacing")
        }),
        borderWidth: {
          DEFAULT: "1px",
          0: "0px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        boxShadow: {
          sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
          DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
          md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
          lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
          xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
          "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
          inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
          none: "none"
        },
        boxShadowColor: ({ theme }) => theme("colors"),
        caretColor: ({ theme }) => theme("colors"),
        accentColor: ({ theme }) => ({
          ...theme("colors"),
          auto: "auto"
        }),
        contrast: {
          0: "0",
          50: ".5",
          75: ".75",
          100: "1",
          125: "1.25",
          150: "1.5",
          200: "2"
        },
        container: {},
        content: {
          none: "none"
        },
        cursor: {
          auto: "auto",
          default: "default",
          pointer: "pointer",
          wait: "wait",
          text: "text",
          move: "move",
          help: "help",
          "not-allowed": "not-allowed",
          none: "none",
          "context-menu": "context-menu",
          progress: "progress",
          cell: "cell",
          crosshair: "crosshair",
          "vertical-text": "vertical-text",
          alias: "alias",
          copy: "copy",
          "no-drop": "no-drop",
          grab: "grab",
          grabbing: "grabbing",
          "all-scroll": "all-scroll",
          "col-resize": "col-resize",
          "row-resize": "row-resize",
          "n-resize": "n-resize",
          "e-resize": "e-resize",
          "s-resize": "s-resize",
          "w-resize": "w-resize",
          "ne-resize": "ne-resize",
          "nw-resize": "nw-resize",
          "se-resize": "se-resize",
          "sw-resize": "sw-resize",
          "ew-resize": "ew-resize",
          "ns-resize": "ns-resize",
          "nesw-resize": "nesw-resize",
          "nwse-resize": "nwse-resize",
          "zoom-in": "zoom-in",
          "zoom-out": "zoom-out"
        },
        divideColor: ({ theme }) => theme("borderColor"),
        divideOpacity: ({ theme }) => theme("borderOpacity"),
        divideWidth: ({ theme }) => theme("borderWidth"),
        dropShadow: {
          sm: "0 1px 1px rgb(0 0 0 / 0.05)",
          DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
          md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
          lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
          xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
          "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
          none: "0 0 #0000"
        },
        fill: ({ theme }) => theme("colors"),
        grayscale: {
          0: "0",
          DEFAULT: "100%"
        },
        hueRotate: {
          0: "0deg",
          15: "15deg",
          30: "30deg",
          60: "60deg",
          90: "90deg",
          180: "180deg"
        },
        invert: {
          0: "0",
          DEFAULT: "100%"
        },
        flex: {
          1: "1 1 0%",
          auto: "1 1 auto",
          initial: "0 1 auto",
          none: "none"
        },
        flexBasis: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          "1/5": "20%",
          "2/5": "40%",
          "3/5": "60%",
          "4/5": "80%",
          "1/6": "16.666667%",
          "2/6": "33.333333%",
          "3/6": "50%",
          "4/6": "66.666667%",
          "5/6": "83.333333%",
          "1/12": "8.333333%",
          "2/12": "16.666667%",
          "3/12": "25%",
          "4/12": "33.333333%",
          "5/12": "41.666667%",
          "6/12": "50%",
          "7/12": "58.333333%",
          "8/12": "66.666667%",
          "9/12": "75%",
          "10/12": "83.333333%",
          "11/12": "91.666667%",
          full: "100%"
        }),
        flexGrow: {
          0: "0",
          DEFAULT: "1"
        },
        flexShrink: {
          0: "0",
          DEFAULT: "1"
        },
        fontFamily: {
          sans: [
            "ui-sans-serif",
            "system-ui",
            "-apple-system",
            "BlinkMacSystemFont",
            '"Segoe UI"',
            "Roboto",
            '"Helvetica Neue"',
            "Arial",
            '"Noto Sans"',
            "sans-serif",
            '"Apple Color Emoji"',
            '"Segoe UI Emoji"',
            '"Segoe UI Symbol"',
            '"Noto Color Emoji"'
          ],
          serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
          mono: [
            "ui-monospace",
            "SFMono-Regular",
            "Menlo",
            "Monaco",
            "Consolas",
            '"Liberation Mono"',
            '"Courier New"',
            "monospace"
          ]
        },
        fontSize: {
          xs: ["0.75rem", { lineHeight: "1rem" }],
          sm: ["0.875rem", { lineHeight: "1.25rem" }],
          base: ["1rem", { lineHeight: "1.5rem" }],
          lg: ["1.125rem", { lineHeight: "1.75rem" }],
          xl: ["1.25rem", { lineHeight: "1.75rem" }],
          "2xl": ["1.5rem", { lineHeight: "2rem" }],
          "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
          "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
          "5xl": ["3rem", { lineHeight: "1" }],
          "6xl": ["3.75rem", { lineHeight: "1" }],
          "7xl": ["4.5rem", { lineHeight: "1" }],
          "8xl": ["6rem", { lineHeight: "1" }],
          "9xl": ["8rem", { lineHeight: "1" }]
        },
        fontWeight: {
          thin: "100",
          extralight: "200",
          light: "300",
          normal: "400",
          medium: "500",
          semibold: "600",
          bold: "700",
          extrabold: "800",
          black: "900"
        },
        gap: ({ theme }) => theme("spacing"),
        gradientColorStops: ({ theme }) => theme("colors"),
        gridAutoColumns: {
          auto: "auto",
          min: "min-content",
          max: "max-content",
          fr: "minmax(0, 1fr)"
        },
        gridAutoRows: {
          auto: "auto",
          min: "min-content",
          max: "max-content",
          fr: "minmax(0, 1fr)"
        },
        gridColumn: {
          auto: "auto",
          "span-1": "span 1 / span 1",
          "span-2": "span 2 / span 2",
          "span-3": "span 3 / span 3",
          "span-4": "span 4 / span 4",
          "span-5": "span 5 / span 5",
          "span-6": "span 6 / span 6",
          "span-7": "span 7 / span 7",
          "span-8": "span 8 / span 8",
          "span-9": "span 9 / span 9",
          "span-10": "span 10 / span 10",
          "span-11": "span 11 / span 11",
          "span-12": "span 12 / span 12",
          "span-full": "1 / -1"
        },
        gridColumnEnd: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          13: "13"
        },
        gridColumnStart: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          13: "13"
        },
        gridRow: {
          auto: "auto",
          "span-1": "span 1 / span 1",
          "span-2": "span 2 / span 2",
          "span-3": "span 3 / span 3",
          "span-4": "span 4 / span 4",
          "span-5": "span 5 / span 5",
          "span-6": "span 6 / span 6",
          "span-full": "1 / -1"
        },
        gridRowStart: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7"
        },
        gridRowEnd: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7"
        },
        gridTemplateColumns: {
          none: "none",
          1: "repeat(1, minmax(0, 1fr))",
          2: "repeat(2, minmax(0, 1fr))",
          3: "repeat(3, minmax(0, 1fr))",
          4: "repeat(4, minmax(0, 1fr))",
          5: "repeat(5, minmax(0, 1fr))",
          6: "repeat(6, minmax(0, 1fr))",
          7: "repeat(7, minmax(0, 1fr))",
          8: "repeat(8, minmax(0, 1fr))",
          9: "repeat(9, minmax(0, 1fr))",
          10: "repeat(10, minmax(0, 1fr))",
          11: "repeat(11, minmax(0, 1fr))",
          12: "repeat(12, minmax(0, 1fr))"
        },
        gridTemplateRows: {
          none: "none",
          1: "repeat(1, minmax(0, 1fr))",
          2: "repeat(2, minmax(0, 1fr))",
          3: "repeat(3, minmax(0, 1fr))",
          4: "repeat(4, minmax(0, 1fr))",
          5: "repeat(5, minmax(0, 1fr))",
          6: "repeat(6, minmax(0, 1fr))"
        },
        height: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          "1/5": "20%",
          "2/5": "40%",
          "3/5": "60%",
          "4/5": "80%",
          "1/6": "16.666667%",
          "2/6": "33.333333%",
          "3/6": "50%",
          "4/6": "66.666667%",
          "5/6": "83.333333%",
          full: "100%",
          screen: "100vh",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        }),
        inset: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          full: "100%"
        }),
        keyframes: {
          spin: {
            to: {
              transform: "rotate(360deg)"
            }
          },
          ping: {
            "75%, 100%": {
              transform: "scale(2)",
              opacity: "0"
            }
          },
          pulse: {
            "50%": {
              opacity: ".5"
            }
          },
          bounce: {
            "0%, 100%": {
              transform: "translateY(-25%)",
              animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
            },
            "50%": {
              transform: "none",
              animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
            }
          }
        },
        letterSpacing: {
          tighter: "-0.05em",
          tight: "-0.025em",
          normal: "0em",
          wide: "0.025em",
          wider: "0.05em",
          widest: "0.1em"
        },
        lineHeight: {
          none: "1",
          tight: "1.25",
          snug: "1.375",
          normal: "1.5",
          relaxed: "1.625",
          loose: "2",
          3: ".75rem",
          4: "1rem",
          5: "1.25rem",
          6: "1.5rem",
          7: "1.75rem",
          8: "2rem",
          9: "2.25rem",
          10: "2.5rem"
        },
        listStyleType: {
          none: "none",
          disc: "disc",
          decimal: "decimal"
        },
        margin: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing")
        }),
        maxHeight: ({ theme }) => ({
          ...theme("spacing"),
          full: "100%",
          screen: "100vh",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        }),
        maxWidth: ({ theme, breakpoints }) => ({
          none: "none",
          0: "0rem",
          xs: "20rem",
          sm: "24rem",
          md: "28rem",
          lg: "32rem",
          xl: "36rem",
          "2xl": "42rem",
          "3xl": "48rem",
          "4xl": "56rem",
          "5xl": "64rem",
          "6xl": "72rem",
          "7xl": "80rem",
          full: "100%",
          min: "min-content",
          max: "max-content",
          fit: "fit-content",
          prose: "65ch",
          ...breakpoints(theme("screens"))
        }),
        minHeight: {
          0: "0px",
          full: "100%",
          screen: "100vh",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        },
        minWidth: {
          0: "0px",
          full: "100%",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        },
        objectPosition: {
          bottom: "bottom",
          center: "center",
          left: "left",
          "left-bottom": "left bottom",
          "left-top": "left top",
          right: "right",
          "right-bottom": "right bottom",
          "right-top": "right top",
          top: "top"
        },
        opacity: {
          0: "0",
          5: "0.05",
          10: "0.1",
          20: "0.2",
          25: "0.25",
          30: "0.3",
          40: "0.4",
          50: "0.5",
          60: "0.6",
          70: "0.7",
          75: "0.75",
          80: "0.8",
          90: "0.9",
          95: "0.95",
          100: "1"
        },
        order: {
          first: "-9999",
          last: "9999",
          none: "0",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12"
        },
        padding: ({ theme }) => theme("spacing"),
        placeholderColor: ({ theme }) => theme("colors"),
        placeholderOpacity: ({ theme }) => theme("opacity"),
        outlineColor: ({ theme }) => theme("colors"),
        outlineOffset: {
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        outlineWidth: {
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        ringColor: ({ theme }) => ({
          DEFAULT: theme(`colors.blue.500`, "#3b82f6"),
          ...theme("colors")
        }),
        ringOffsetColor: ({ theme }) => theme("colors"),
        ringOffsetWidth: {
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        ringOpacity: ({ theme }) => ({
          DEFAULT: "0.5",
          ...theme("opacity")
        }),
        ringWidth: {
          DEFAULT: "3px",
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        rotate: {
          0: "0deg",
          1: "1deg",
          2: "2deg",
          3: "3deg",
          6: "6deg",
          12: "12deg",
          45: "45deg",
          90: "90deg",
          180: "180deg"
        },
        saturate: {
          0: "0",
          50: ".5",
          100: "1",
          150: "1.5",
          200: "2"
        },
        scale: {
          0: "0",
          50: ".5",
          75: ".75",
          90: ".9",
          95: ".95",
          100: "1",
          105: "1.05",
          110: "1.1",
          125: "1.25",
          150: "1.5"
        },
        scrollMargin: ({ theme }) => ({
          ...theme("spacing")
        }),
        scrollPadding: ({ theme }) => theme("spacing"),
        sepia: {
          0: "0",
          DEFAULT: "100%"
        },
        skew: {
          0: "0deg",
          1: "1deg",
          2: "2deg",
          3: "3deg",
          6: "6deg",
          12: "12deg"
        },
        space: ({ theme }) => ({
          ...theme("spacing")
        }),
        stroke: ({ theme }) => theme("colors"),
        strokeWidth: {
          0: "0",
          1: "1",
          2: "2"
        },
        textColor: ({ theme }) => theme("colors"),
        textDecorationColor: ({ theme }) => theme("colors"),
        textDecorationThickness: {
          auto: "auto",
          "from-font": "from-font",
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        textUnderlineOffset: {
          auto: "auto",
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        textIndent: ({ theme }) => ({
          ...theme("spacing")
        }),
        textOpacity: ({ theme }) => theme("opacity"),
        transformOrigin: {
          center: "center",
          top: "top",
          "top-right": "top right",
          right: "right",
          "bottom-right": "bottom right",
          bottom: "bottom",
          "bottom-left": "bottom left",
          left: "left",
          "top-left": "top left"
        },
        transitionDelay: {
          75: "75ms",
          100: "100ms",
          150: "150ms",
          200: "200ms",
          300: "300ms",
          500: "500ms",
          700: "700ms",
          1e3: "1000ms"
        },
        transitionDuration: {
          DEFAULT: "150ms",
          75: "75ms",
          100: "100ms",
          150: "150ms",
          200: "200ms",
          300: "300ms",
          500: "500ms",
          700: "700ms",
          1e3: "1000ms"
        },
        transitionProperty: {
          none: "none",
          all: "all",
          DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
          colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
          opacity: "opacity",
          shadow: "box-shadow",
          transform: "transform"
        },
        transitionTimingFunction: {
          DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
          linear: "linear",
          in: "cubic-bezier(0.4, 0, 1, 1)",
          out: "cubic-bezier(0, 0, 0.2, 1)",
          "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
        },
        translate: ({ theme }) => ({
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          full: "100%"
        }),
        width: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          "1/5": "20%",
          "2/5": "40%",
          "3/5": "60%",
          "4/5": "80%",
          "1/6": "16.666667%",
          "2/6": "33.333333%",
          "3/6": "50%",
          "4/6": "66.666667%",
          "5/6": "83.333333%",
          "1/12": "8.333333%",
          "2/12": "16.666667%",
          "3/12": "25%",
          "4/12": "33.333333%",
          "5/12": "41.666667%",
          "6/12": "50%",
          "7/12": "58.333333%",
          "8/12": "66.666667%",
          "9/12": "75%",
          "10/12": "83.333333%",
          "11/12": "91.666667%",
          full: "100%",
          screen: "100vw",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        }),
        willChange: {
          auto: "auto",
          scroll: "scroll-position",
          contents: "contents",
          transform: "transform"
        },
        zIndex: {
          auto: "auto",
          0: "0",
          10: "10",
          20: "20",
          30: "30",
          40: "40",
          50: "50"
        }
      },
      variantOrder: [
        "first",
        "last",
        "odd",
        "even",
        "visited",
        "checked",
        "empty",
        "read-only",
        "group-hover",
        "group-focus",
        "focus-within",
        "hover",
        "focus",
        "focus-visible",
        "active",
        "disabled"
      ],
      plugins: []
    };
  }
});

// src/vendor/twrnc/log.js
var log_exports = {};
__export(log_exports, {
  default: () => log_default
});
var log_default;
var init_log = __esm({
  "src/vendor/twrnc/log.js"() {
    init_esm_shims();
    log_default = {
      info(key, messages) {
        console.info(...Array.isArray(key) ? [key] : [messages, key]);
      },
      warn(key, messages) {
        console.warn(...Array.isArray(key) ? [key] : [messages, key]);
      },
      risk(key, messages) {
        console.error(...Array.isArray(key) ? [key] : [messages, key]);
      }
    };
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/public/colors.js
var require_colors = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/public/colors.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => _default
    });
    var _log = /* @__PURE__ */ _interopRequireDefault((init_log(), __toCommonJS(log_exports)));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function warn2({ version, from, to }) {
      _log.default.warn(`${from}-color-renamed`, [
        `As of Tailwind CSS ${version}, \`${from}\` has been renamed to \`${to}\`.`,
        "Update your configuration file to silence this warning."
      ]);
    }
    var _default = {
      inherit: "inherit",
      current: "currentColor",
      transparent: "transparent",
      black: "#000",
      white: "#fff",
      slate: {
        50: "#f8fafc",
        100: "#f1f5f9",
        200: "#e2e8f0",
        300: "#cbd5e1",
        400: "#94a3b8",
        500: "#64748b",
        600: "#475569",
        700: "#334155",
        800: "#1e293b",
        900: "#0f172a"
      },
      gray: {
        50: "#f9fafb",
        100: "#f3f4f6",
        200: "#e5e7eb",
        300: "#d1d5db",
        400: "#9ca3af",
        500: "#6b7280",
        600: "#4b5563",
        700: "#374151",
        800: "#1f2937",
        900: "#111827"
      },
      zinc: {
        50: "#fafafa",
        100: "#f4f4f5",
        200: "#e4e4e7",
        300: "#d4d4d8",
        400: "#a1a1aa",
        500: "#71717a",
        600: "#52525b",
        700: "#3f3f46",
        800: "#27272a",
        900: "#18181b"
      },
      neutral: {
        50: "#fafafa",
        100: "#f5f5f5",
        200: "#e5e5e5",
        300: "#d4d4d4",
        400: "#a3a3a3",
        500: "#737373",
        600: "#525252",
        700: "#404040",
        800: "#262626",
        900: "#171717"
      },
      stone: {
        50: "#fafaf9",
        100: "#f5f5f4",
        200: "#e7e5e4",
        300: "#d6d3d1",
        400: "#a8a29e",
        500: "#78716c",
        600: "#57534e",
        700: "#44403c",
        800: "#292524",
        900: "#1c1917"
      },
      red: {
        50: "#fef2f2",
        100: "#fee2e2",
        200: "#fecaca",
        300: "#fca5a5",
        400: "#f87171",
        500: "#ef4444",
        600: "#dc2626",
        700: "#b91c1c",
        800: "#991b1b",
        900: "#7f1d1d"
      },
      orange: {
        50: "#fff7ed",
        100: "#ffedd5",
        200: "#fed7aa",
        300: "#fdba74",
        400: "#fb923c",
        500: "#f97316",
        600: "#ea580c",
        700: "#c2410c",
        800: "#9a3412",
        900: "#7c2d12"
      },
      amber: {
        50: "#fffbeb",
        100: "#fef3c7",
        200: "#fde68a",
        300: "#fcd34d",
        400: "#fbbf24",
        500: "#f59e0b",
        600: "#d97706",
        700: "#b45309",
        800: "#92400e",
        900: "#78350f"
      },
      yellow: {
        50: "#fefce8",
        100: "#fef9c3",
        200: "#fef08a",
        300: "#fde047",
        400: "#facc15",
        500: "#eab308",
        600: "#ca8a04",
        700: "#a16207",
        800: "#854d0e",
        900: "#713f12"
      },
      lime: {
        50: "#f7fee7",
        100: "#ecfccb",
        200: "#d9f99d",
        300: "#bef264",
        400: "#a3e635",
        500: "#84cc16",
        600: "#65a30d",
        700: "#4d7c0f",
        800: "#3f6212",
        900: "#365314"
      },
      green: {
        50: "#f0fdf4",
        100: "#dcfce7",
        200: "#bbf7d0",
        300: "#86efac",
        400: "#4ade80",
        500: "#22c55e",
        600: "#16a34a",
        700: "#15803d",
        800: "#166534",
        900: "#14532d"
      },
      emerald: {
        50: "#ecfdf5",
        100: "#d1fae5",
        200: "#a7f3d0",
        300: "#6ee7b7",
        400: "#34d399",
        500: "#10b981",
        600: "#059669",
        700: "#047857",
        800: "#065f46",
        900: "#064e3b"
      },
      teal: {
        50: "#f0fdfa",
        100: "#ccfbf1",
        200: "#99f6e4",
        300: "#5eead4",
        400: "#2dd4bf",
        500: "#14b8a6",
        600: "#0d9488",
        700: "#0f766e",
        800: "#115e59",
        900: "#134e4a"
      },
      cyan: {
        50: "#ecfeff",
        100: "#cffafe",
        200: "#a5f3fc",
        300: "#67e8f9",
        400: "#22d3ee",
        500: "#06b6d4",
        600: "#0891b2",
        700: "#0e7490",
        800: "#155e75",
        900: "#164e63"
      },
      sky: {
        50: "#f0f9ff",
        100: "#e0f2fe",
        200: "#bae6fd",
        300: "#7dd3fc",
        400: "#38bdf8",
        500: "#0ea5e9",
        600: "#0284c7",
        700: "#0369a1",
        800: "#075985",
        900: "#0c4a6e"
      },
      blue: {
        50: "#eff6ff",
        100: "#dbeafe",
        200: "#bfdbfe",
        300: "#93c5fd",
        400: "#60a5fa",
        500: "#3b82f6",
        600: "#2563eb",
        700: "#1d4ed8",
        800: "#1e40af",
        900: "#1e3a8a"
      },
      indigo: {
        50: "#eef2ff",
        100: "#e0e7ff",
        200: "#c7d2fe",
        300: "#a5b4fc",
        400: "#818cf8",
        500: "#6366f1",
        600: "#4f46e5",
        700: "#4338ca",
        800: "#3730a3",
        900: "#312e81"
      },
      violet: {
        50: "#f5f3ff",
        100: "#ede9fe",
        200: "#ddd6fe",
        300: "#c4b5fd",
        400: "#a78bfa",
        500: "#8b5cf6",
        600: "#7c3aed",
        700: "#6d28d9",
        800: "#5b21b6",
        900: "#4c1d95"
      },
      purple: {
        50: "#faf5ff",
        100: "#f3e8ff",
        200: "#e9d5ff",
        300: "#d8b4fe",
        400: "#c084fc",
        500: "#a855f7",
        600: "#9333ea",
        700: "#7e22ce",
        800: "#6b21a8",
        900: "#581c87"
      },
      fuchsia: {
        50: "#fdf4ff",
        100: "#fae8ff",
        200: "#f5d0fe",
        300: "#f0abfc",
        400: "#e879f9",
        500: "#d946ef",
        600: "#c026d3",
        700: "#a21caf",
        800: "#86198f",
        900: "#701a75"
      },
      pink: {
        50: "#fdf2f8",
        100: "#fce7f3",
        200: "#fbcfe8",
        300: "#f9a8d4",
        400: "#f472b6",
        500: "#ec4899",
        600: "#db2777",
        700: "#be185d",
        800: "#9d174d",
        900: "#831843"
      },
      rose: {
        50: "#fff1f2",
        100: "#ffe4e6",
        200: "#fecdd3",
        300: "#fda4af",
        400: "#fb7185",
        500: "#f43f5e",
        600: "#e11d48",
        700: "#be123c",
        800: "#9f1239",
        900: "#881337"
      },
      get lightBlue() {
        warn2({
          version: "v2.2",
          from: "lightBlue",
          to: "sky"
        });
        return this.sky;
      },
      get warmGray() {
        warn2({
          version: "v3.0",
          from: "warmGray",
          to: "stone"
        });
        return this.stone;
      },
      get trueGray() {
        warn2({
          version: "v3.0",
          from: "trueGray",
          to: "neutral"
        });
        return this.neutral;
      },
      get coolGray() {
        warn2({
          version: "v3.0",
          from: "coolGray",
          to: "gray"
        });
        return this.gray;
      },
      get blueGray() {
        warn2({
          version: "v3.0",
          from: "blueGray",
          to: "slate"
        });
        return this.slate;
      }
    };
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/defaults.js
var require_defaults = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/defaults.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "defaults", {
      enumerable: true,
      get: () => defaults
    });
    function defaults(target, ...sources) {
      for (let source of sources) {
        for (let k in source) {
          var ref;
          if (!(target === null || target === void 0 ? void 0 : (ref = target.hasOwnProperty) === null || ref === void 0 ? void 0 : ref.call(target, k))) {
            target[k] = source[k];
          }
        }
        for (let k1 of Object.getOwnPropertySymbols(source)) {
          var ref1;
          if (!(target === null || target === void 0 ? void 0 : (ref1 = target.hasOwnProperty) === null || ref1 === void 0 ? void 0 : ref1.call(target, k1))) {
            target[k1] = source[k1];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/toPath.js
var require_toPath = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/toPath.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "toPath", {
      enumerable: true,
      get: () => toPath
    });
    function toPath(path) {
      if (Array.isArray(path))
        return path;
      let openBrackets = path.split("[").length - 1;
      let closedBrackets = path.split("]").length - 1;
      if (openBrackets !== closedBrackets) {
        throw new Error(`Path is invalid. Has unbalanced brackets: ${path}`);
      }
      return path.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/normalizeConfig.js
var require_normalizeConfig = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/normalizeConfig.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "normalizeConfig", {
      enumerable: true,
      get: () => normalizeConfig
    });
    var _log = /* @__PURE__ */ _interopRequireWildcard((init_log(), __toCommonJS(log_exports)));
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function normalizeConfig(config2) {
      let valid = (() => {
        if (config2.purge) {
          return false;
        }
        if (!config2.content) {
          return false;
        }
        if (!Array.isArray(config2.content) && !(typeof config2.content === "object" && config2.content !== null)) {
          return false;
        }
        if (Array.isArray(config2.content)) {
          return config2.content.every((path) => {
            if (typeof path === "string")
              return true;
            if (typeof (path === null || path === void 0 ? void 0 : path.raw) !== "string")
              return false;
            if ((path === null || path === void 0 ? void 0 : path.extension) && typeof (path === null || path === void 0 ? void 0 : path.extension) !== "string") {
              return false;
            }
            return true;
          });
        }
        if (typeof config2.content === "object" && config2.content !== null) {
          if (Object.keys(config2.content).some((key) => ![
            "files",
            "extract",
            "transform"
          ].includes(key))) {
            return false;
          }
          if (Array.isArray(config2.content.files)) {
            if (!config2.content.files.every((path) => {
              if (typeof path === "string")
                return true;
              if (typeof (path === null || path === void 0 ? void 0 : path.raw) !== "string")
                return false;
              if ((path === null || path === void 0 ? void 0 : path.extension) && typeof (path === null || path === void 0 ? void 0 : path.extension) !== "string") {
                return false;
              }
              return true;
            })) {
              return false;
            }
            if (typeof config2.content.extract === "object") {
              for (let value of Object.values(config2.content.extract)) {
                if (typeof value !== "function") {
                  return false;
                }
              }
            } else if (!(config2.content.extract === void 0 || typeof config2.content.extract === "function")) {
              return false;
            }
            if (typeof config2.content.transform === "object") {
              for (let value1 of Object.values(config2.content.transform)) {
                if (typeof value1 !== "function") {
                  return false;
                }
              }
            } else if (!(config2.content.transform === void 0 || typeof config2.content.transform === "function")) {
              return false;
            }
          }
          return true;
        }
        return false;
      })();
      if (!valid) {
        _log.default.warn("purge-deprecation", [
          "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
          "Update your configuration file to eliminate this warning.",
          "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
        ]);
      }
      config2.safelist = (() => {
        var ref;
        let { content, purge, safelist } = config2;
        if (Array.isArray(safelist))
          return safelist;
        if (Array.isArray(content === null || content === void 0 ? void 0 : content.safelist))
          return content.safelist;
        if (Array.isArray(purge === null || purge === void 0 ? void 0 : purge.safelist))
          return purge.safelist;
        if (Array.isArray(purge === null || purge === void 0 ? void 0 : (ref = purge.options) === null || ref === void 0 ? void 0 : ref.safelist))
          return purge.options.safelist;
        return [];
      })();
      if (typeof config2.prefix === "function") {
        _log.default.warn("prefix-function", [
          "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
          "Update `prefix` in your configuration to be a string to eliminate this warning.",
          "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
        ]);
        config2.prefix = "";
      } else {
        var _prefix;
        config2.prefix = (_prefix = config2.prefix) !== null && _prefix !== void 0 ? _prefix : "";
      }
      config2.content = {
        files: (() => {
          let { content, purge } = config2;
          if (Array.isArray(purge))
            return purge;
          if (Array.isArray(purge === null || purge === void 0 ? void 0 : purge.content))
            return purge.content;
          if (Array.isArray(content))
            return content;
          if (Array.isArray(content === null || content === void 0 ? void 0 : content.content))
            return content.content;
          if (Array.isArray(content === null || content === void 0 ? void 0 : content.files))
            return content.files;
          return [];
        })(),
        extract: (() => {
          let extract = (() => {
            var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
            if ((ref = config2.purge) === null || ref === void 0 ? void 0 : ref.extract)
              return config2.purge.extract;
            if ((ref1 = config2.content) === null || ref1 === void 0 ? void 0 : ref1.extract)
              return config2.content.extract;
            if ((ref2 = config2.purge) === null || ref2 === void 0 ? void 0 : (ref3 = ref2.extract) === null || ref3 === void 0 ? void 0 : ref3.DEFAULT)
              return config2.purge.extract.DEFAULT;
            if ((ref4 = config2.content) === null || ref4 === void 0 ? void 0 : (ref5 = ref4.extract) === null || ref5 === void 0 ? void 0 : ref5.DEFAULT)
              return config2.content.extract.DEFAULT;
            if ((ref6 = config2.purge) === null || ref6 === void 0 ? void 0 : (ref7 = ref6.options) === null || ref7 === void 0 ? void 0 : ref7.extractors)
              return config2.purge.options.extractors;
            if ((ref8 = config2.content) === null || ref8 === void 0 ? void 0 : (ref9 = ref8.options) === null || ref9 === void 0 ? void 0 : ref9.extractors)
              return config2.content.options.extractors;
            return {};
          })();
          let extractors = {};
          let defaultExtractor = (() => {
            var ref, ref1, ref2, ref3;
            if ((ref = config2.purge) === null || ref === void 0 ? void 0 : (ref1 = ref.options) === null || ref1 === void 0 ? void 0 : ref1.defaultExtractor) {
              return config2.purge.options.defaultExtractor;
            }
            if ((ref2 = config2.content) === null || ref2 === void 0 ? void 0 : (ref3 = ref2.options) === null || ref3 === void 0 ? void 0 : ref3.defaultExtractor) {
              return config2.content.options.defaultExtractor;
            }
            return void 0;
          })();
          if (defaultExtractor !== void 0) {
            extractors.DEFAULT = defaultExtractor;
          }
          if (typeof extract === "function") {
            extractors.DEFAULT = extract;
          } else if (Array.isArray(extract)) {
            for (let { extensions, extractor } of extract !== null && extract !== void 0 ? extract : []) {
              for (let extension of extensions) {
                extractors[extension] = extractor;
              }
            }
          } else if (typeof extract === "object" && extract !== null) {
            Object.assign(extractors, extract);
          }
          return extractors;
        })(),
        transform: (() => {
          let transform2 = (() => {
            var ref, ref1, ref2, ref3, ref4, ref5;
            if ((ref = config2.purge) === null || ref === void 0 ? void 0 : ref.transform)
              return config2.purge.transform;
            if ((ref1 = config2.content) === null || ref1 === void 0 ? void 0 : ref1.transform)
              return config2.content.transform;
            if ((ref2 = config2.purge) === null || ref2 === void 0 ? void 0 : (ref3 = ref2.transform) === null || ref3 === void 0 ? void 0 : ref3.DEFAULT)
              return config2.purge.transform.DEFAULT;
            if ((ref4 = config2.content) === null || ref4 === void 0 ? void 0 : (ref5 = ref4.transform) === null || ref5 === void 0 ? void 0 : ref5.DEFAULT)
              return config2.content.transform.DEFAULT;
            return {};
          })();
          let transformers = {};
          if (typeof transform2 === "function") {
            transformers.DEFAULT = transform2;
          }
          if (typeof transform2 === "object" && transform2 !== null) {
            Object.assign(transformers, transform2);
          }
          return transformers;
        })()
      };
      for (let file of config2.content.files) {
        if (typeof file === "string" && /{([^,]*?)}/g.test(file)) {
          _log.default.warn("invalid-glob-braces", [
            `The glob pattern ${(0, _log.dim)(file)} in your Tailwind CSS configuration is invalid.`,
            `Update it to ${(0, _log.dim)(file.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
          ]);
          break;
        }
      }
      return config2;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/isPlainObject.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => isPlainObject
    });
    function isPlainObject(value) {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/cloneDeep.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "cloneDeep", {
      enumerable: true,
      get: () => cloneDeep
    });
    function cloneDeep(value) {
      if (Array.isArray(value)) {
        return value.map((child) => cloneDeep(child));
      }
      if (typeof value === "object" && value !== null) {
        return Object.fromEntries(Object.entries(value).map(([k, v2]) => [
          k,
          cloneDeep(v2)
        ]));
      }
      return value;
    }
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/util/unesc.js
var require_unesc = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/util/unesc.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = unesc;
    function gobbleHex(str) {
      var lower = str.toLowerCase();
      var hex = "";
      var spaceTerminated = false;
      for (var i3 = 0; i3 < 6 && lower[i3] !== void 0; i3++) {
        var code2 = lower.charCodeAt(i3);
        var valid = code2 >= 97 && code2 <= 102 || code2 >= 48 && code2 <= 57;
        spaceTerminated = code2 === 32;
        if (!valid) {
          break;
        }
        hex += lower[i3];
      }
      if (hex.length === 0) {
        return void 0;
      }
      var codePoint = parseInt(hex, 16);
      var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
      if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
        return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
      }
      return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
    }
    var CONTAINS_ESCAPE = /\\/;
    function unesc(str) {
      var needToProcess = CONTAINS_ESCAPE.test(str);
      if (!needToProcess) {
        return str;
      }
      var ret = "";
      for (var i3 = 0; i3 < str.length; i3++) {
        if (str[i3] === "\\") {
          var gobbled = gobbleHex(str.slice(i3 + 1, i3 + 7));
          if (gobbled !== void 0) {
            ret += gobbled[0];
            i3 += gobbled[1];
            continue;
          }
          if (str[i3 + 1] === "\\") {
            ret += "\\";
            i3++;
            continue;
          }
          if (str.length === i3 + 1) {
            ret += str[i3];
          }
          continue;
        }
        ret += str[i3];
      }
      return ret;
    }
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/util/getProp.js
var require_getProp = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/util/getProp.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = getProp;
    function getProp(obj) {
      for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
      }
      while (props.length > 0) {
        var prop = props.shift();
        if (!obj[prop]) {
          return void 0;
        }
        obj = obj[prop];
      }
      return obj;
    }
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/util/ensureObject.js
var require_ensureObject = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/util/ensureObject.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = ensureObject;
    function ensureObject(obj) {
      for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
      }
      while (props.length > 0) {
        var prop = props.shift();
        if (!obj[prop]) {
          obj[prop] = {};
        }
        obj = obj[prop];
      }
    }
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/util/stripComments.js
var require_stripComments = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/util/stripComments.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = stripComments;
    function stripComments(str) {
      var s2 = "";
      var commentStart = str.indexOf("/*");
      var lastEnd = 0;
      while (commentStart >= 0) {
        s2 = s2 + str.slice(lastEnd, commentStart);
        var commentEnd = str.indexOf("*/", commentStart + 2);
        if (commentEnd < 0) {
          return s2;
        }
        lastEnd = commentEnd + 2;
        commentStart = str.indexOf("/*", lastEnd);
      }
      s2 = s2 + str.slice(lastEnd);
      return s2;
    }
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/util/index.js
var require_util = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/util/index.js"(exports) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports.stripComments = exports.ensureObject = exports.getProp = exports.unesc = void 0;
    var _unesc = _interopRequireDefault(require_unesc());
    exports.unesc = _unesc["default"];
    var _getProp = _interopRequireDefault(require_getProp());
    exports.getProp = _getProp["default"];
    var _ensureObject = _interopRequireDefault(require_ensureObject());
    exports.ensureObject = _ensureObject["default"];
    var _stripComments = _interopRequireDefault(require_stripComments());
    exports.stripComments = _stripComments["default"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/node.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _util = require_util();
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var cloneNode = function cloneNode2(obj, parent) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      var cloned = new obj.constructor();
      for (var i3 in obj) {
        if (!obj.hasOwnProperty(i3)) {
          continue;
        }
        var value = obj[i3];
        var type = typeof value;
        if (i3 === "parent" && type === "object") {
          if (parent) {
            cloned[i3] = parent;
          }
        } else if (value instanceof Array) {
          cloned[i3] = value.map(function(j) {
            return cloneNode2(j, cloned);
          });
        } else {
          cloned[i3] = cloneNode2(value, cloned);
        }
      }
      return cloned;
    };
    var Node = /* @__PURE__ */ function() {
      function Node2(opts) {
        if (opts === void 0) {
          opts = {};
        }
        Object.assign(this, opts);
        this.spaces = this.spaces || {};
        this.spaces.before = this.spaces.before || "";
        this.spaces.after = this.spaces.after || "";
      }
      var _proto = Node2.prototype;
      _proto.remove = function remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      };
      _proto.replaceWith = function replaceWith() {
        if (this.parent) {
          for (var index in arguments) {
            this.parent.insertBefore(this, arguments[index]);
          }
          this.remove();
        }
        return this;
      };
      _proto.next = function next() {
        return this.parent.at(this.parent.index(this) + 1);
      };
      _proto.prev = function prev() {
        return this.parent.at(this.parent.index(this) - 1);
      };
      _proto.clone = function clone(overrides) {
        if (overrides === void 0) {
          overrides = {};
        }
        var cloned = cloneNode(this);
        for (var name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      };
      _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
        if (!this.raws) {
          this.raws = {};
        }
        var originalValue = this[name];
        var originalEscaped = this.raws[name];
        this[name] = originalValue + value;
        if (originalEscaped || valueEscaped !== value) {
          this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
        } else {
          delete this.raws[name];
        }
      };
      _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
        if (!this.raws) {
          this.raws = {};
        }
        this[name] = value;
        this.raws[name] = valueEscaped;
      };
      _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
        this[name] = value;
        if (this.raws) {
          delete this.raws[name];
        }
      };
      _proto.isAtPosition = function isAtPosition(line, column) {
        if (this.source && this.source.start && this.source.end) {
          if (this.source.start.line > line) {
            return false;
          }
          if (this.source.end.line < line) {
            return false;
          }
          if (this.source.start.line === line && this.source.start.column > column) {
            return false;
          }
          if (this.source.end.line === line && this.source.end.column < column) {
            return false;
          }
          return true;
        }
        return void 0;
      };
      _proto.stringifyProperty = function stringifyProperty(name) {
        return this.raws && this.raws[name] || this[name];
      };
      _proto.valueToString = function valueToString() {
        return String(this.stringifyProperty("value"));
      };
      _proto.toString = function toString() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      };
      _createClass(Node2, [{
        key: "rawSpaceBefore",
        get: function get() {
          var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
          if (rawSpace === void 0) {
            rawSpace = this.spaces && this.spaces.before;
          }
          return rawSpace || "";
        },
        set: function set(raw) {
          (0, _util.ensureObject)(this, "raws", "spaces");
          this.raws.spaces.before = raw;
        }
      }, {
        key: "rawSpaceAfter",
        get: function get() {
          var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
          if (rawSpace === void 0) {
            rawSpace = this.spaces.after;
          }
          return rawSpace || "";
        },
        set: function set(raw) {
          (0, _util.ensureObject)(this, "raws", "spaces");
          this.raws.spaces.after = raw;
        }
      }]);
      return Node2;
    }();
    exports["default"] = Node;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/types.js"(exports) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports.UNIVERSAL = exports.ATTRIBUTE = exports.CLASS = exports.COMBINATOR = exports.COMMENT = exports.ID = exports.NESTING = exports.PSEUDO = exports.ROOT = exports.SELECTOR = exports.STRING = exports.TAG = void 0;
    var TAG = "tag";
    exports.TAG = TAG;
    var STRING = "string";
    exports.STRING = STRING;
    var SELECTOR = "selector";
    exports.SELECTOR = SELECTOR;
    var ROOT = "root";
    exports.ROOT = ROOT;
    var PSEUDO = "pseudo";
    exports.PSEUDO = PSEUDO;
    var NESTING = "nesting";
    exports.NESTING = NESTING;
    var ID = "id";
    exports.ID = ID;
    var COMMENT = "comment";
    exports.COMMENT = COMMENT;
    var COMBINATOR = "combinator";
    exports.COMBINATOR = COMBINATOR;
    var CLASS = "class";
    exports.CLASS = CLASS;
    var ATTRIBUTE = "attribute";
    exports.ATTRIBUTE = ATTRIBUTE;
    var UNIVERSAL = "universal";
    exports.UNIVERSAL = UNIVERSAL;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/container.js
var require_container = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/container.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node());
    var types = _interopRequireWildcard(require_types());
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
        if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
          if (it)
            o2 = it;
          var i3 = 0;
          return function() {
            if (i3 >= o2.length)
              return { done: true };
            return { done: false, value: o2[i3++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      it = o2[Symbol.iterator]();
      return it.next.bind(it);
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n = Object.prototype.toString.call(o2).slice(8, -1);
      if (n === "Object" && o2.constructor)
        n = o2.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o2);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
        arr2[i3] = arr[i3];
      }
      return arr2;
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    var Container = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Container2, _Node);
      function Container2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        if (!_this.nodes) {
          _this.nodes = [];
        }
        return _this;
      }
      var _proto = Container2.prototype;
      _proto.append = function append(selector) {
        selector.parent = this;
        this.nodes.push(selector);
        return this;
      };
      _proto.prepend = function prepend(selector) {
        selector.parent = this;
        this.nodes.unshift(selector);
        return this;
      };
      _proto.at = function at(index) {
        return this.nodes[index];
      };
      _proto.index = function index(child) {
        if (typeof child === "number") {
          return child;
        }
        return this.nodes.indexOf(child);
      };
      _proto.removeChild = function removeChild(child) {
        child = this.index(child);
        this.at(child).parent = void 0;
        this.nodes.splice(child, 1);
        var index;
        for (var id in this.indexes) {
          index = this.indexes[id];
          if (index >= child) {
            this.indexes[id] = index - 1;
          }
        }
        return this;
      };
      _proto.removeAll = function removeAll() {
        for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
          var node = _step.value;
          node.parent = void 0;
        }
        this.nodes = [];
        return this;
      };
      _proto.empty = function empty() {
        return this.removeAll();
      };
      _proto.insertAfter = function insertAfter(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex + 1, 0, newNode);
        newNode.parent = this;
        var index;
        for (var id in this.indexes) {
          index = this.indexes[id];
          if (oldIndex <= index) {
            this.indexes[id] = index + 1;
          }
        }
        return this;
      };
      _proto.insertBefore = function insertBefore(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex, 0, newNode);
        newNode.parent = this;
        var index;
        for (var id in this.indexes) {
          index = this.indexes[id];
          if (index <= oldIndex) {
            this.indexes[id] = index + 1;
          }
        }
        return this;
      };
      _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
        var found = void 0;
        this.each(function(node) {
          if (node.atPosition) {
            var foundChild = node.atPosition(line, col);
            if (foundChild) {
              found = foundChild;
              return false;
            }
          } else if (node.isAtPosition(line, col)) {
            found = node;
            return false;
          }
        });
        return found;
      };
      _proto.atPosition = function atPosition(line, col) {
        if (this.isAtPosition(line, col)) {
          return this._findChildAtPosition(line, col) || this;
        } else {
          return void 0;
        }
      };
      _proto._inferEndPosition = function _inferEndPosition() {
        if (this.last && this.last.source && this.last.source.end) {
          this.source = this.source || {};
          this.source.end = this.source.end || {};
          Object.assign(this.source.end, this.last.source.end);
        }
      };
      _proto.each = function each(callback) {
        if (!this.lastEach) {
          this.lastEach = 0;
        }
        if (!this.indexes) {
          this.indexes = {};
        }
        this.lastEach++;
        var id = this.lastEach;
        this.indexes[id] = 0;
        if (!this.length) {
          return void 0;
        }
        var index, result;
        while (this.indexes[id] < this.length) {
          index = this.indexes[id];
          result = callback(this.at(index), index);
          if (result === false) {
            break;
          }
          this.indexes[id] += 1;
        }
        delete this.indexes[id];
        if (result === false) {
          return false;
        }
      };
      _proto.walk = function walk(callback) {
        return this.each(function(node, i3) {
          var result = callback(node, i3);
          if (result !== false && node.length) {
            result = node.walk(callback);
          }
          if (result === false) {
            return false;
          }
        });
      };
      _proto.walkAttributes = function walkAttributes(callback) {
        var _this2 = this;
        return this.walk(function(selector) {
          if (selector.type === types.ATTRIBUTE) {
            return callback.call(_this2, selector);
          }
        });
      };
      _proto.walkClasses = function walkClasses(callback) {
        var _this3 = this;
        return this.walk(function(selector) {
          if (selector.type === types.CLASS) {
            return callback.call(_this3, selector);
          }
        });
      };
      _proto.walkCombinators = function walkCombinators(callback) {
        var _this4 = this;
        return this.walk(function(selector) {
          if (selector.type === types.COMBINATOR) {
            return callback.call(_this4, selector);
          }
        });
      };
      _proto.walkComments = function walkComments(callback) {
        var _this5 = this;
        return this.walk(function(selector) {
          if (selector.type === types.COMMENT) {
            return callback.call(_this5, selector);
          }
        });
      };
      _proto.walkIds = function walkIds(callback) {
        var _this6 = this;
        return this.walk(function(selector) {
          if (selector.type === types.ID) {
            return callback.call(_this6, selector);
          }
        });
      };
      _proto.walkNesting = function walkNesting(callback) {
        var _this7 = this;
        return this.walk(function(selector) {
          if (selector.type === types.NESTING) {
            return callback.call(_this7, selector);
          }
        });
      };
      _proto.walkPseudos = function walkPseudos(callback) {
        var _this8 = this;
        return this.walk(function(selector) {
          if (selector.type === types.PSEUDO) {
            return callback.call(_this8, selector);
          }
        });
      };
      _proto.walkTags = function walkTags(callback) {
        var _this9 = this;
        return this.walk(function(selector) {
          if (selector.type === types.TAG) {
            return callback.call(_this9, selector);
          }
        });
      };
      _proto.walkUniversals = function walkUniversals(callback) {
        var _this10 = this;
        return this.walk(function(selector) {
          if (selector.type === types.UNIVERSAL) {
            return callback.call(_this10, selector);
          }
        });
      };
      _proto.split = function split2(callback) {
        var _this11 = this;
        var current = [];
        return this.reduce(function(memo, node, index) {
          var split3 = callback.call(_this11, node);
          current.push(node);
          if (split3) {
            memo.push(current);
            current = [];
          } else if (index === _this11.length - 1) {
            memo.push(current);
          }
          return memo;
        }, []);
      };
      _proto.map = function map(callback) {
        return this.nodes.map(callback);
      };
      _proto.reduce = function reduce(callback, memo) {
        return this.nodes.reduce(callback, memo);
      };
      _proto.every = function every(callback) {
        return this.nodes.every(callback);
      };
      _proto.some = function some(callback) {
        return this.nodes.some(callback);
      };
      _proto.filter = function filter(callback) {
        return this.nodes.filter(callback);
      };
      _proto.sort = function sort(callback) {
        return this.nodes.sort(callback);
      };
      _proto.toString = function toString() {
        return this.map(String).join("");
      };
      _createClass(Container2, [{
        key: "first",
        get: function get() {
          return this.at(0);
        }
      }, {
        key: "last",
        get: function get() {
          return this.at(this.length - 1);
        }
      }, {
        key: "length",
        get: function get() {
          return this.nodes.length;
        }
      }]);
      return Container2;
    }(_node["default"]);
    exports["default"] = Container;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/root.js
var require_root = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/root.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _container = _interopRequireDefault(require_container());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    var Root = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Root2, _Container);
      function Root2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.ROOT;
        return _this;
      }
      var _proto = Root2.prototype;
      _proto.toString = function toString() {
        var str = this.reduce(function(memo, selector) {
          memo.push(String(selector));
          return memo;
        }, []).join(",");
        return this.trailingComma ? str + "," : str;
      };
      _proto.error = function error(message, options) {
        if (this._error) {
          return this._error(message, options);
        } else {
          return new Error(message);
        }
      };
      _createClass(Root2, [{
        key: "errorGenerator",
        set: function set(handler2) {
          this._error = handler2;
        }
      }]);
      return Root2;
    }(_container["default"]);
    exports["default"] = Root;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/selector.js
var require_selector = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/selector.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _container = _interopRequireDefault(require_container());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    var Selector = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Selector2, _Container);
      function Selector2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.SELECTOR;
        return _this;
      }
      return Selector2;
    }(_container["default"]);
    exports["default"] = Selector;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/cssesc@3.0.0/node_modules/cssesc/cssesc.js
var require_cssesc = __commonJS({
  "node_modules/.pnpm/cssesc@3.0.0/node_modules/cssesc/cssesc.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var merge = function merge2(options, defaults) {
      if (!options) {
        return defaults;
      }
      var result = {};
      for (var key in defaults) {
        result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
      }
      return result;
    };
    var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
    var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
    var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
    var cssesc = function cssesc2(string, options) {
      options = merge(options, cssesc2.options);
      if (options.quotes != "single" && options.quotes != "double") {
        options.quotes = "single";
      }
      var quote = options.quotes == "double" ? '"' : "'";
      var isIdentifier = options.isIdentifier;
      var firstChar = string.charAt(0);
      var output = "";
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var character = string.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value = void 0;
        if (codePoint < 32 || codePoint > 126) {
          if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
            } else {
              counter--;
            }
          }
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else {
          if (options.escapeEverything) {
            if (regexAnySingleEscape.test(character)) {
              value = "\\" + character;
            } else {
              value = "\\" + codePoint.toString(16).toUpperCase() + " ";
            }
          } else if (/[\t\n\f\r\x0B]/.test(character)) {
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
            value = "\\" + character;
          } else {
            value = character;
          }
        }
        output += value;
      }
      if (isIdentifier) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        } else if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
        if ($1 && $1.length % 2) {
          return $0;
        }
        return ($1 || "") + $2;
      });
      if (!isIdentifier && options.wrap) {
        return quote + output + quote;
      }
      return output;
    };
    cssesc.options = {
      "escapeEverything": false,
      "isIdentifier": false,
      "quotes": "single",
      "wrap": false
    };
    cssesc.version = "3.0.0";
    module.exports = cssesc;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/className.js
var require_className = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/className.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _util = require_util();
    var _node = _interopRequireDefault(require_node());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    var ClassName = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(ClassName2, _Node);
      function ClassName2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.CLASS;
        _this._constructed = true;
        return _this;
      }
      var _proto = ClassName2.prototype;
      _proto.valueToString = function valueToString() {
        return "." + _Node.prototype.valueToString.call(this);
      };
      _createClass(ClassName2, [{
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(v2) {
          if (this._constructed) {
            var escaped = (0, _cssesc["default"])(v2, {
              isIdentifier: true
            });
            if (escaped !== v2) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.value = escaped;
            } else if (this.raws) {
              delete this.raws.value;
            }
          }
          this._value = v2;
        }
      }]);
      return ClassName2;
    }(_node["default"]);
    exports["default"] = ClassName;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/comment.js
var require_comment = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/comment.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    var Comment = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Comment2, _Node);
      function Comment2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.COMMENT;
        return _this;
      }
      return Comment2;
    }(_node["default"]);
    exports["default"] = Comment;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/id.js
var require_id = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/id.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    var ID = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(ID2, _Node);
      function ID2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.ID;
        return _this;
      }
      var _proto = ID2.prototype;
      _proto.valueToString = function valueToString() {
        return "#" + _Node.prototype.valueToString.call(this);
      };
      return ID2;
    }(_node["default"]);
    exports["default"] = ID;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/namespace.js
var require_namespace = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/namespace.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _util = require_util();
    var _node = _interopRequireDefault(require_node());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    var Namespace = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Namespace2, _Node);
      function Namespace2() {
        return _Node.apply(this, arguments) || this;
      }
      var _proto = Namespace2.prototype;
      _proto.qualifiedName = function qualifiedName(value) {
        if (this.namespace) {
          return this.namespaceString + "|" + value;
        } else {
          return value;
        }
      };
      _proto.valueToString = function valueToString() {
        return this.qualifiedName(_Node.prototype.valueToString.call(this));
      };
      _createClass(Namespace2, [{
        key: "namespace",
        get: function get() {
          return this._namespace;
        },
        set: function set(namespace) {
          if (namespace === true || namespace === "*" || namespace === "&") {
            this._namespace = namespace;
            if (this.raws) {
              delete this.raws.namespace;
            }
            return;
          }
          var escaped = (0, _cssesc["default"])(namespace, {
            isIdentifier: true
          });
          this._namespace = namespace;
          if (escaped !== namespace) {
            (0, _util.ensureObject)(this, "raws");
            this.raws.namespace = escaped;
          } else if (this.raws) {
            delete this.raws.namespace;
          }
        }
      }, {
        key: "ns",
        get: function get() {
          return this._namespace;
        },
        set: function set(namespace) {
          this.namespace = namespace;
        }
      }, {
        key: "namespaceString",
        get: function get() {
          if (this.namespace) {
            var ns = this.stringifyProperty("namespace");
            if (ns === true) {
              return "";
            } else {
              return ns;
            }
          } else {
            return "";
          }
        }
      }]);
      return Namespace2;
    }(_node["default"]);
    exports["default"] = Namespace;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/tag.js
var require_tag = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/tag.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    var Tag = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Tag2, _Namespace);
      function Tag2(opts) {
        var _this;
        _this = _Namespace.call(this, opts) || this;
        _this.type = _types.TAG;
        return _this;
      }
      return Tag2;
    }(_namespace["default"]);
    exports["default"] = Tag;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/string.js
var require_string = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/string.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    var String2 = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(String3, _Node);
      function String3(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.STRING;
        return _this;
      }
      return String3;
    }(_node["default"]);
    exports["default"] = String2;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/pseudo.js
var require_pseudo = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _container = _interopRequireDefault(require_container());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    var Pseudo = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Pseudo2, _Container);
      function Pseudo2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.PSEUDO;
        return _this;
      }
      var _proto = Pseudo2.prototype;
      _proto.toString = function toString() {
        var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
      };
      return Pseudo2;
    }(_container["default"]);
    exports["default"] = Pseudo;
    module.exports = exports.default;
  }
});

// src/vendor/twrnc/deprecate.js
var require_deprecate = __commonJS({
  "src/vendor/twrnc/deprecate.js"(exports, module) {
    init_esm_shims();
    module.exports = function deprecate(fn, message) {
      return function(...args) {
        console.warn(message);
        return fn(...args);
      };
    };
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/attribute.js
var require_attribute = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/attribute.js"(exports) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports.unescapeValue = unescapeValue;
    exports["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _unesc = _interopRequireDefault(require_unesc());
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    var _CSSESC_QUOTE_OPTIONS;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    var deprecate = require_deprecate();
    var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
    var warnOfDeprecatedValueAssignment = deprecate(function() {
    }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
    var warnOfDeprecatedQuotedAssignment = deprecate(function() {
    }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
    var warnOfDeprecatedConstructor = deprecate(function() {
    }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function unescapeValue(value) {
      var deprecatedUsage = false;
      var quoteMark = null;
      var unescaped = value;
      var m2 = unescaped.match(WRAPPED_IN_QUOTES);
      if (m2) {
        quoteMark = m2[1];
        unescaped = m2[2];
      }
      unescaped = (0, _unesc["default"])(unescaped);
      if (unescaped !== value) {
        deprecatedUsage = true;
      }
      return {
        deprecatedUsage,
        unescaped,
        quoteMark
      };
    }
    function handleDeprecatedContructorOpts(opts) {
      if (opts.quoteMark !== void 0) {
        return opts;
      }
      if (opts.value === void 0) {
        return opts;
      }
      warnOfDeprecatedConstructor();
      var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
      if (!opts.raws) {
        opts.raws = {};
      }
      if (opts.raws.value === void 0) {
        opts.raws.value = opts.value;
      }
      opts.value = unescaped;
      opts.quoteMark = quoteMark;
      return opts;
    }
    var Attribute = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Attribute2, _Namespace);
      function Attribute2(opts) {
        var _this;
        if (opts === void 0) {
          opts = {};
        }
        _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
        _this.type = _types.ATTRIBUTE;
        _this.raws = _this.raws || {};
        Object.defineProperty(_this.raws, "unquoted", {
          get: deprecate(function() {
            return _this.value;
          }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
          set: deprecate(function() {
            return _this.value;
          }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        });
        _this._constructed = true;
        return _this;
      }
      var _proto = Attribute2.prototype;
      _proto.getQuotedValue = function getQuotedValue(options) {
        if (options === void 0) {
          options = {};
        }
        var quoteMark = this._determineQuoteMark(options);
        var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
        var escaped = (0, _cssesc["default"])(this._value, cssescopts);
        return escaped;
      };
      _proto._determineQuoteMark = function _determineQuoteMark(options) {
        return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
      };
      _proto.setValue = function setValue(value, options) {
        if (options === void 0) {
          options = {};
        }
        this._value = value;
        this._quoteMark = this._determineQuoteMark(options);
        this._syncRawValue();
      };
      _proto.smartQuoteMark = function smartQuoteMark(options) {
        var v2 = this.value;
        var numSingleQuotes = v2.replace(/[^']/g, "").length;
        var numDoubleQuotes = v2.replace(/[^"]/g, "").length;
        if (numSingleQuotes + numDoubleQuotes === 0) {
          var escaped = (0, _cssesc["default"])(v2, {
            isIdentifier: true
          });
          if (escaped === v2) {
            return Attribute2.NO_QUOTE;
          } else {
            var pref = this.preferredQuoteMark(options);
            if (pref === Attribute2.NO_QUOTE) {
              var quote = this.quoteMark || options.quoteMark || Attribute2.DOUBLE_QUOTE;
              var opts = CSSESC_QUOTE_OPTIONS[quote];
              var quoteValue = (0, _cssesc["default"])(v2, opts);
              if (quoteValue.length < escaped.length) {
                return quote;
              }
            }
            return pref;
          }
        } else if (numDoubleQuotes === numSingleQuotes) {
          return this.preferredQuoteMark(options);
        } else if (numDoubleQuotes < numSingleQuotes) {
          return Attribute2.DOUBLE_QUOTE;
        } else {
          return Attribute2.SINGLE_QUOTE;
        }
      };
      _proto.preferredQuoteMark = function preferredQuoteMark(options) {
        var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;
        if (quoteMark === void 0) {
          quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
        }
        if (quoteMark === void 0) {
          quoteMark = Attribute2.DOUBLE_QUOTE;
        }
        return quoteMark;
      };
      _proto._syncRawValue = function _syncRawValue() {
        var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
        if (rawValue === this._value) {
          if (this.raws) {
            delete this.raws.value;
          }
        } else {
          this.raws.value = rawValue;
        }
      };
      _proto._handleEscapes = function _handleEscapes(prop, value) {
        if (this._constructed) {
          var escaped = (0, _cssesc["default"])(value, {
            isIdentifier: true
          });
          if (escaped !== value) {
            this.raws[prop] = escaped;
          } else {
            delete this.raws[prop];
          }
        }
      };
      _proto._spacesFor = function _spacesFor(name) {
        var attrSpaces = {
          before: "",
          after: ""
        };
        var spaces = this.spaces[name] || {};
        var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
        return Object.assign(attrSpaces, spaces, rawSpaces);
      };
      _proto._stringFor = function _stringFor(name, spaceName, concat) {
        if (spaceName === void 0) {
          spaceName = name;
        }
        if (concat === void 0) {
          concat = defaultAttrConcat;
        }
        var attrSpaces = this._spacesFor(spaceName);
        return concat(this.stringifyProperty(name), attrSpaces);
      };
      _proto.offsetOf = function offsetOf(name) {
        var count = 1;
        var attributeSpaces = this._spacesFor("attribute");
        count += attributeSpaces.before.length;
        if (name === "namespace" || name === "ns") {
          return this.namespace ? count : -1;
        }
        if (name === "attributeNS") {
          return count;
        }
        count += this.namespaceString.length;
        if (this.namespace) {
          count += 1;
        }
        if (name === "attribute") {
          return count;
        }
        count += this.stringifyProperty("attribute").length;
        count += attributeSpaces.after.length;
        var operatorSpaces = this._spacesFor("operator");
        count += operatorSpaces.before.length;
        var operator = this.stringifyProperty("operator");
        if (name === "operator") {
          return operator ? count : -1;
        }
        count += operator.length;
        count += operatorSpaces.after.length;
        var valueSpaces = this._spacesFor("value");
        count += valueSpaces.before.length;
        var value = this.stringifyProperty("value");
        if (name === "value") {
          return value ? count : -1;
        }
        count += value.length;
        count += valueSpaces.after.length;
        var insensitiveSpaces = this._spacesFor("insensitive");
        count += insensitiveSpaces.before.length;
        if (name === "insensitive") {
          return this.insensitive ? count : -1;
        }
        return -1;
      };
      _proto.toString = function toString() {
        var _this2 = this;
        var selector = [this.rawSpaceBefore, "["];
        selector.push(this._stringFor("qualifiedAttribute", "attribute"));
        if (this.operator && (this.value || this.value === "")) {
          selector.push(this._stringFor("operator"));
          selector.push(this._stringFor("value"));
          selector.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
            if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
              attrSpaces.before = " ";
            }
            return defaultAttrConcat(attrValue, attrSpaces);
          }));
        }
        selector.push("]");
        selector.push(this.rawSpaceAfter);
        return selector.join("");
      };
      _createClass(Attribute2, [{
        key: "quoted",
        get: function get() {
          var qm = this.quoteMark;
          return qm === "'" || qm === '"';
        },
        set: function set(value) {
          warnOfDeprecatedQuotedAssignment();
        }
      }, {
        key: "quoteMark",
        get: function get() {
          return this._quoteMark;
        },
        set: function set(quoteMark) {
          if (!this._constructed) {
            this._quoteMark = quoteMark;
            return;
          }
          if (this._quoteMark !== quoteMark) {
            this._quoteMark = quoteMark;
            this._syncRawValue();
          }
        }
      }, {
        key: "qualifiedAttribute",
        get: function get() {
          return this.qualifiedName(this.raws.attribute || this.attribute);
        }
      }, {
        key: "insensitiveFlag",
        get: function get() {
          return this.insensitive ? "i" : "";
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(v2) {
          if (this._constructed) {
            var _unescapeValue2 = unescapeValue(v2), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
            if (deprecatedUsage) {
              warnOfDeprecatedValueAssignment();
            }
            if (unescaped === this._value && quoteMark === this._quoteMark) {
              return;
            }
            this._value = unescaped;
            this._quoteMark = quoteMark;
            this._syncRawValue();
          } else {
            this._value = v2;
          }
        }
      }, {
        key: "attribute",
        get: function get() {
          return this._attribute;
        },
        set: function set(name) {
          this._handleEscapes("attribute", name);
          this._attribute = name;
        }
      }]);
      return Attribute2;
    }(_namespace["default"]);
    exports["default"] = Attribute;
    Attribute.NO_QUOTE = null;
    Attribute.SINGLE_QUOTE = "'";
    Attribute.DOUBLE_QUOTE = '"';
    var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
      "'": {
        quotes: "single",
        wrap: true
      },
      '"': {
        quotes: "double",
        wrap: true
      }
    }, _CSSESC_QUOTE_OPTIONS[null] = {
      isIdentifier: true
    }, _CSSESC_QUOTE_OPTIONS);
    function defaultAttrConcat(attrValue, attrSpaces) {
      return "" + attrSpaces.before + attrValue + attrSpaces.after;
    }
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/universal.js
var require_universal = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/universal.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    var Universal = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Universal2, _Namespace);
      function Universal2(opts) {
        var _this;
        _this = _Namespace.call(this, opts) || this;
        _this.type = _types.UNIVERSAL;
        _this.value = "*";
        return _this;
      }
      return Universal2;
    }(_namespace["default"]);
    exports["default"] = Universal;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/combinator.js
var require_combinator = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/combinator.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    var Combinator = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Combinator2, _Node);
      function Combinator2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.COMBINATOR;
        return _this;
      }
      return Combinator2;
    }(_node["default"]);
    exports["default"] = Combinator;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/nesting.js
var require_nesting = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/nesting.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    var Nesting = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Nesting2, _Node);
      function Nesting2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.NESTING;
        _this.value = "&";
        return _this;
      }
      return Nesting2;
    }(_node["default"]);
    exports["default"] = Nesting;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/sortAscending.js
var require_sortAscending = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/sortAscending.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = sortAscending;
    function sortAscending(list2) {
      return list2.sort(function(a2, b) {
        return a2 - b;
      });
    }
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/tokenTypes.js
var require_tokenTypes = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/tokenTypes.js"(exports) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports.combinator = exports.word = exports.comment = exports.str = exports.tab = exports.newline = exports.feed = exports.cr = exports.backslash = exports.bang = exports.slash = exports.doubleQuote = exports.singleQuote = exports.space = exports.greaterThan = exports.pipe = exports.equals = exports.plus = exports.caret = exports.tilde = exports.dollar = exports.closeSquare = exports.openSquare = exports.closeParenthesis = exports.openParenthesis = exports.semicolon = exports.colon = exports.comma = exports.at = exports.asterisk = exports.ampersand = void 0;
    var ampersand = 38;
    exports.ampersand = ampersand;
    var asterisk = 42;
    exports.asterisk = asterisk;
    var at = 64;
    exports.at = at;
    var comma = 44;
    exports.comma = comma;
    var colon = 58;
    exports.colon = colon;
    var semicolon = 59;
    exports.semicolon = semicolon;
    var openParenthesis = 40;
    exports.openParenthesis = openParenthesis;
    var closeParenthesis = 41;
    exports.closeParenthesis = closeParenthesis;
    var openSquare = 91;
    exports.openSquare = openSquare;
    var closeSquare = 93;
    exports.closeSquare = closeSquare;
    var dollar = 36;
    exports.dollar = dollar;
    var tilde = 126;
    exports.tilde = tilde;
    var caret = 94;
    exports.caret = caret;
    var plus = 43;
    exports.plus = plus;
    var equals = 61;
    exports.equals = equals;
    var pipe = 124;
    exports.pipe = pipe;
    var greaterThan = 62;
    exports.greaterThan = greaterThan;
    var space = 32;
    exports.space = space;
    var singleQuote = 39;
    exports.singleQuote = singleQuote;
    var doubleQuote = 34;
    exports.doubleQuote = doubleQuote;
    var slash = 47;
    exports.slash = slash;
    var bang = 33;
    exports.bang = bang;
    var backslash = 92;
    exports.backslash = backslash;
    var cr = 13;
    exports.cr = cr;
    var feed = 12;
    exports.feed = feed;
    var newline = 10;
    exports.newline = newline;
    var tab = 9;
    exports.tab = tab;
    var str = singleQuote;
    exports.str = str;
    var comment = -1;
    exports.comment = comment;
    var word = -2;
    exports.word = word;
    var combinator = -3;
    exports.combinator = combinator;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/tokenize.js"(exports) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = tokenize;
    exports.FIELDS = void 0;
    var t = _interopRequireWildcard(require_tokenTypes());
    var _unescapable;
    var _wordDelimiters;
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
    var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
    var hex = {};
    var hexChars = "0123456789abcdefABCDEF";
    for (i3 = 0; i3 < hexChars.length; i3++) {
      hex[hexChars.charCodeAt(i3)] = true;
    }
    var i3;
    function consumeWord(css, start) {
      var next = start;
      var code2;
      do {
        code2 = css.charCodeAt(next);
        if (wordDelimiters[code2]) {
          return next - 1;
        } else if (code2 === t.backslash) {
          next = consumeEscape(css, next) + 1;
        } else {
          next++;
        }
      } while (next < css.length);
      return next - 1;
    }
    function consumeEscape(css, start) {
      var next = start;
      var code2 = css.charCodeAt(next + 1);
      if (unescapable[code2]) {
      } else if (hex[code2]) {
        var hexDigits = 0;
        do {
          next++;
          hexDigits++;
          code2 = css.charCodeAt(next + 1);
        } while (hex[code2] && hexDigits < 6);
        if (hexDigits < 6 && code2 === t.space) {
          next++;
        }
      } else {
        next++;
      }
      return next;
    }
    var FIELDS = {
      TYPE: 0,
      START_LINE: 1,
      START_COL: 2,
      END_LINE: 3,
      END_COL: 4,
      START_POS: 5,
      END_POS: 6
    };
    exports.FIELDS = FIELDS;
    function tokenize(input) {
      var tokens = [];
      var css = input.css.valueOf();
      var _css = css, length = _css.length;
      var offset = -1;
      var line = 1;
      var start = 0;
      var end = 0;
      var code2, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;
      function unclosed(what, fix) {
        if (input.safe) {
          css += fix;
          next = css.length - 1;
        } else {
          throw input.error("Unclosed " + what, line, start - offset, start);
        }
      }
      while (start < length) {
        code2 = css.charCodeAt(start);
        if (code2 === t.newline) {
          offset = start;
          line += 1;
        }
        switch (code2) {
          case t.space:
          case t.tab:
          case t.newline:
          case t.cr:
          case t.feed:
            next = start;
            do {
              next += 1;
              code2 = css.charCodeAt(next);
              if (code2 === t.newline) {
                offset = next;
                line += 1;
              }
            } while (code2 === t.space || code2 === t.newline || code2 === t.tab || code2 === t.cr || code2 === t.feed);
            tokenType = t.space;
            endLine = line;
            endColumn = next - offset - 1;
            end = next;
            break;
          case t.plus:
          case t.greaterThan:
          case t.tilde:
          case t.pipe:
            next = start;
            do {
              next += 1;
              code2 = css.charCodeAt(next);
            } while (code2 === t.plus || code2 === t.greaterThan || code2 === t.tilde || code2 === t.pipe);
            tokenType = t.combinator;
            endLine = line;
            endColumn = start - offset;
            end = next;
            break;
          case t.asterisk:
          case t.ampersand:
          case t.bang:
          case t.comma:
          case t.equals:
          case t.dollar:
          case t.caret:
          case t.openSquare:
          case t.closeSquare:
          case t.colon:
          case t.semicolon:
          case t.openParenthesis:
          case t.closeParenthesis:
            next = start;
            tokenType = code2;
            endLine = line;
            endColumn = start - offset;
            end = next + 1;
            break;
          case t.singleQuote:
          case t.doubleQuote:
            quote = code2 === t.singleQuote ? "'" : '"';
            next = start;
            do {
              escaped = false;
              next = css.indexOf(quote, next + 1);
              if (next === -1) {
                unclosed("quote", quote);
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === t.backslash) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            tokenType = t.str;
            endLine = line;
            endColumn = start - offset;
            end = next + 1;
            break;
          default:
            if (code2 === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
              next = css.indexOf("*/", start + 2) + 1;
              if (next === 0) {
                unclosed("comment", "*/");
              }
              content = css.slice(start, next + 1);
              lines = content.split("\n");
              last = lines.length - 1;
              if (last > 0) {
                nextLine = line + last;
                nextOffset = next - lines[last].length;
              } else {
                nextLine = line;
                nextOffset = offset;
              }
              tokenType = t.comment;
              line = nextLine;
              endLine = nextLine;
              endColumn = next - nextOffset;
            } else if (code2 === t.slash) {
              next = start;
              tokenType = code2;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
            } else {
              next = consumeWord(css, start);
              tokenType = t.word;
              endLine = line;
              endColumn = next - offset;
            }
            end = next + 1;
            break;
        }
        tokens.push([
          tokenType,
          line,
          start - offset,
          endLine,
          endColumn,
          start,
          end
        ]);
        if (nextOffset) {
          offset = nextOffset;
          nextOffset = null;
        }
        start = end;
      }
      return tokens;
    }
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/parser.js
var require_parser = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/parser.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _root = _interopRequireDefault(require_root());
    var _selector = _interopRequireDefault(require_selector());
    var _className = _interopRequireDefault(require_className());
    var _comment = _interopRequireDefault(require_comment());
    var _id = _interopRequireDefault(require_id());
    var _tag = _interopRequireDefault(require_tag());
    var _string = _interopRequireDefault(require_string());
    var _pseudo = _interopRequireDefault(require_pseudo());
    var _attribute = _interopRequireWildcard(require_attribute());
    var _universal = _interopRequireDefault(require_universal());
    var _combinator = _interopRequireDefault(require_combinator());
    var _nesting = _interopRequireDefault(require_nesting());
    var _sortAscending = _interopRequireDefault(require_sortAscending());
    var _tokenize = _interopRequireWildcard(require_tokenize());
    var tokens = _interopRequireWildcard(require_tokenTypes());
    var types = _interopRequireWildcard(require_types());
    var _util = require_util();
    var _WHITESPACE_TOKENS;
    var _Object$assign;
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
    var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
    function tokenStart(token) {
      return {
        line: token[_tokenize.FIELDS.START_LINE],
        column: token[_tokenize.FIELDS.START_COL]
      };
    }
    function tokenEnd(token) {
      return {
        line: token[_tokenize.FIELDS.END_LINE],
        column: token[_tokenize.FIELDS.END_COL]
      };
    }
    function getSource(startLine, startColumn, endLine, endColumn) {
      return {
        start: {
          line: startLine,
          column: startColumn
        },
        end: {
          line: endLine,
          column: endColumn
        }
      };
    }
    function getTokenSource(token) {
      return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
    }
    function getTokenSourceSpan(startToken, endToken) {
      if (!startToken) {
        return void 0;
      }
      return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
    }
    function unescapeProp(node, prop) {
      var value = node[prop];
      if (typeof value !== "string") {
        return;
      }
      if (value.indexOf("\\") !== -1) {
        (0, _util.ensureObject)(node, "raws");
        node[prop] = (0, _util.unesc)(value);
        if (node.raws[prop] === void 0) {
          node.raws[prop] = value;
        }
      }
      return node;
    }
    function indexesOf(array, item) {
      var i3 = -1;
      var indexes = [];
      while ((i3 = array.indexOf(item, i3 + 1)) !== -1) {
        indexes.push(i3);
      }
      return indexes;
    }
    function uniqs() {
      var list2 = Array.prototype.concat.apply([], arguments);
      return list2.filter(function(item, i3) {
        return i3 === list2.indexOf(item);
      });
    }
    var Parser = /* @__PURE__ */ function() {
      function Parser2(rule, options) {
        if (options === void 0) {
          options = {};
        }
        this.rule = rule;
        this.options = Object.assign({
          lossy: false,
          safe: false
        }, options);
        this.position = 0;
        this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
        this.tokens = (0, _tokenize["default"])({
          css: this.css,
          error: this._errorGenerator(),
          safe: this.options.safe
        });
        var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new _root["default"]({
          source: rootSource
        });
        this.root.errorGenerator = this._errorGenerator();
        var selector = new _selector["default"]({
          source: {
            start: {
              line: 1,
              column: 1
            }
          }
        });
        this.root.append(selector);
        this.current = selector;
        this.loop();
      }
      var _proto = Parser2.prototype;
      _proto._errorGenerator = function _errorGenerator() {
        var _this = this;
        return function(message, errorOptions) {
          if (typeof _this.rule === "string") {
            return new Error(message);
          }
          return _this.rule.error(message, errorOptions);
        };
      };
      _proto.attribute = function attribute() {
        var attr = [];
        var startingToken = this.currToken;
        this.position++;
        while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
          attr.push(this.currToken);
          this.position++;
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
          return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
        }
        var len = attr.length;
        var node = {
          source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
        };
        if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
          return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
        }
        var pos = 0;
        var spaceBefore = "";
        var commentBefore = "";
        var lastAdded = null;
        var spaceAfterMeaningfulToken = false;
        while (pos < len) {
          var token = attr[pos];
          var content = this.content(token);
          var next = attr[pos + 1];
          switch (token[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              spaceAfterMeaningfulToken = true;
              if (this.options.lossy) {
                break;
              }
              if (lastAdded) {
                (0, _util.ensureObject)(node, "spaces", lastAdded);
                var prevContent = node.spaces[lastAdded].after || "";
                node.spaces[lastAdded].after = prevContent + content;
                var existingComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || null;
                if (existingComment) {
                  node.raws.spaces[lastAdded].after = existingComment + content;
                }
              } else {
                spaceBefore = spaceBefore + content;
                commentBefore = commentBefore + content;
              }
              break;
            case tokens.asterisk:
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                if (spaceBefore) {
                  (0, _util.ensureObject)(node, "spaces", "attribute");
                  node.spaces.attribute.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                  node.raws.spaces.attribute.before = spaceBefore;
                  commentBefore = "";
                }
                node.namespace = (node.namespace || "") + content;
                var rawValue = (0, _util.getProp)(node, "raws", "namespace") || null;
                if (rawValue) {
                  node.raws.namespace += content;
                }
                lastAdded = "namespace";
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.dollar:
              if (lastAdded === "value") {
                var oldRawValue = (0, _util.getProp)(node, "raws", "value");
                node.value += "$";
                if (oldRawValue) {
                  node.raws.value = oldRawValue + "$";
                }
                break;
              }
            case tokens.caret:
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.combinator:
              if (content === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              }
              if (content !== "|") {
                spaceAfterMeaningfulToken = false;
                break;
              }
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              } else if (!node.namespace && !node.attribute) {
                node.namespace = true;
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.word:
              if (next && this.content(next) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && !node.operator && !node.namespace) {
                node.namespace = content;
                lastAdded = "namespace";
              } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                if (spaceBefore) {
                  (0, _util.ensureObject)(node, "spaces", "attribute");
                  node.spaces.attribute.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                  node.raws.spaces.attribute.before = commentBefore;
                  commentBefore = "";
                }
                node.attribute = (node.attribute || "") + content;
                var _rawValue = (0, _util.getProp)(node, "raws", "attribute") || null;
                if (_rawValue) {
                  node.raws.attribute += content;
                }
                lastAdded = "attribute";
              } else if (!node.value && node.value !== "" || lastAdded === "value" && !spaceAfterMeaningfulToken) {
                var _unescaped = (0, _util.unesc)(content);
                var _oldRawValue = (0, _util.getProp)(node, "raws", "value") || "";
                var oldValue = node.value || "";
                node.value = oldValue + _unescaped;
                node.quoteMark = null;
                if (_unescaped !== content || _oldRawValue) {
                  (0, _util.ensureObject)(node, "raws");
                  node.raws.value = (_oldRawValue || oldValue) + content;
                }
                lastAdded = "value";
              } else {
                var insensitive = content === "i" || content === "I";
                if ((node.value || node.value === "") && (node.quoteMark || spaceAfterMeaningfulToken)) {
                  node.insensitive = insensitive;
                  if (!insensitive || content === "I") {
                    (0, _util.ensureObject)(node, "raws");
                    node.raws.insensitiveFlag = content;
                  }
                  lastAdded = "insensitive";
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, "spaces", "insensitive");
                    node.spaces.insensitive.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node, "raws", "spaces", "insensitive");
                    node.raws.spaces.insensitive.before = commentBefore;
                    commentBefore = "";
                  }
                } else if (node.value || node.value === "") {
                  lastAdded = "value";
                  node.value += content;
                  if (node.raws.value) {
                    node.raws.value += content;
                  }
                }
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.str:
              if (!node.attribute || !node.operator) {
                return this.error("Expected an attribute followed by an operator preceding the string.", {
                  index: token[_tokenize.FIELDS.START_POS]
                });
              }
              var _unescapeValue = (0, _attribute.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
              node.value = unescaped;
              node.quoteMark = quoteMark;
              lastAdded = "value";
              (0, _util.ensureObject)(node, "raws");
              node.raws.value = content;
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.equals:
              if (!node.attribute) {
                return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content);
              }
              if (node.value) {
                return this.error('Unexpected "=" found; an operator was already defined.', {
                  index: token[_tokenize.FIELDS.START_POS]
                });
              }
              node.operator = node.operator ? node.operator + content : content;
              lastAdded = "operator";
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.comment:
              if (lastAdded) {
                if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                  var lastComment = (0, _util.getProp)(node, "spaces", lastAdded, "after") || "";
                  var rawLastComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || lastComment;
                  (0, _util.ensureObject)(node, "raws", "spaces", lastAdded);
                  node.raws.spaces[lastAdded].after = rawLastComment + content;
                } else {
                  var lastValue = node[lastAdded] || "";
                  var rawLastValue = (0, _util.getProp)(node, "raws", lastAdded) || lastValue;
                  (0, _util.ensureObject)(node, "raws");
                  node.raws[lastAdded] = rawLastValue + content;
                }
              } else {
                commentBefore = commentBefore + content;
              }
              break;
            default:
              return this.error('Unexpected "' + content + '" found.', {
                index: token[_tokenize.FIELDS.START_POS]
              });
          }
          pos++;
        }
        unescapeProp(node, "attribute");
        unescapeProp(node, "namespace");
        this.newNode(new _attribute["default"](node));
        this.position++;
      };
      _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
        if (stopPosition < 0) {
          stopPosition = this.tokens.length;
        }
        var startPosition = this.position;
        var nodes = [];
        var space = "";
        var lastComment = void 0;
        do {
          if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
            if (!this.options.lossy) {
              space += this.content();
            }
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
            var spaces = {};
            if (space) {
              spaces.before = space;
              space = "";
            }
            lastComment = new _comment["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              spaces
            });
            nodes.push(lastComment);
          }
        } while (++this.position < stopPosition);
        if (space) {
          if (lastComment) {
            lastComment.spaces.after = space;
          } else if (!this.options.lossy) {
            var firstToken = this.tokens[startPosition];
            var lastToken = this.tokens[this.position - 1];
            nodes.push(new _string["default"]({
              value: "",
              source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces: {
                before: space,
                after: ""
              }
            }));
          }
        }
        return nodes;
      };
      _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
        var _this2 = this;
        if (requiredSpace === void 0) {
          requiredSpace = false;
        }
        var space = "";
        var rawSpace = "";
        nodes.forEach(function(n) {
          var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);
          var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);
          space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
          rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
        });
        if (rawSpace === space) {
          rawSpace = void 0;
        }
        var result = {
          space,
          rawSpace
        };
        return result;
      };
      _proto.isNamedCombinator = function isNamedCombinator(position) {
        if (position === void 0) {
          position = this.position;
        }
        return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
      };
      _proto.namedCombinator = function namedCombinator() {
        if (this.isNamedCombinator()) {
          var nameRaw = this.content(this.tokens[this.position + 1]);
          var name = (0, _util.unesc)(nameRaw).toLowerCase();
          var raws = {};
          if (name !== nameRaw) {
            raws.value = "/" + nameRaw + "/";
          }
          var node = new _combinator["default"]({
            value: "/" + name + "/",
            source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
            raws
          });
          this.position = this.position + 3;
          return node;
        } else {
          this.unexpected();
        }
      };
      _proto.combinator = function combinator() {
        var _this3 = this;
        if (this.content() === "|") {
          return this.namespace();
        }
        var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
        if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
          var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          if (nodes.length > 0) {
            var last = this.current.last;
            if (last) {
              var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
              if (rawSpace !== void 0) {
                last.rawSpaceAfter += rawSpace;
              }
              last.spaces.after += space;
            } else {
              nodes.forEach(function(n) {
                return _this3.newNode(n);
              });
            }
          }
          return;
        }
        var firstToken = this.currToken;
        var spaceOrDescendantSelectorNodes = void 0;
        if (nextSigTokenPos > this.position) {
          spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
        }
        var node;
        if (this.isNamedCombinator()) {
          node = this.namedCombinator();
        } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
          node = new _combinator["default"]({
            value: this.content(),
            source: getTokenSource(this.currToken),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
          });
          this.position++;
        } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
        } else if (!spaceOrDescendantSelectorNodes) {
          this.unexpected();
        }
        if (node) {
          if (spaceOrDescendantSelectorNodes) {
            var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
            node.spaces.before = _space;
            node.rawSpaceBefore = _rawSpace;
          }
        } else {
          var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
          if (!_rawSpace2) {
            _rawSpace2 = _space2;
          }
          var spaces = {};
          var raws = {
            spaces: {}
          };
          if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
            spaces.before = _space2.slice(0, _space2.length - 1);
            raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
          } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
            spaces.after = _space2.slice(1);
            raws.spaces.after = _rawSpace2.slice(1);
          } else {
            raws.value = _rawSpace2;
          }
          node = new _combinator["default"]({
            value: " ",
            source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
            sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
            spaces,
            raws
          });
        }
        if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
          node.spaces.after = this.optionalSpace(this.content());
          this.position++;
        }
        return this.newNode(node);
      };
      _proto.comma = function comma() {
        if (this.position === this.tokens.length - 1) {
          this.root.trailingComma = true;
          this.position++;
          return;
        }
        this.current._inferEndPosition();
        var selector = new _selector["default"]({
          source: {
            start: tokenStart(this.tokens[this.position + 1])
          }
        });
        this.current.parent.append(selector);
        this.current = selector;
        this.position++;
      };
      _proto.comment = function comment() {
        var current = this.currToken;
        this.newNode(new _comment["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.error = function error(message, opts) {
        throw this.root.error(message, opts);
      };
      _proto.missingBackslash = function missingBackslash() {
        return this.error("Expected a backslash preceding the semicolon.", {
          index: this.currToken[_tokenize.FIELDS.START_POS]
        });
      };
      _proto.missingParenthesis = function missingParenthesis() {
        return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.missingSquareBracket = function missingSquareBracket() {
        return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.unexpected = function unexpected() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.namespace = function namespace() {
        var before = this.prevToken && this.content(this.prevToken) || true;
        if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
          this.position++;
          return this.word(before);
        } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
          this.position++;
          return this.universal(before);
        }
      };
      _proto.nesting = function nesting() {
        if (this.nextToken) {
          var nextContent = this.content(this.nextToken);
          if (nextContent === "|") {
            this.position++;
            return;
          }
        }
        var current = this.currToken;
        this.newNode(new _nesting["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.parentheses = function parentheses() {
        var last = this.current.last;
        var unbalanced = 1;
        this.position++;
        if (last && last.type === types.PSEUDO) {
          var selector = new _selector["default"]({
            source: {
              start: tokenStart(this.tokens[this.position - 1])
            }
          });
          var cache2 = this.current;
          last.append(selector);
          this.current = selector;
          while (this.position < this.tokens.length && unbalanced) {
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              unbalanced++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              unbalanced--;
            }
            if (unbalanced) {
              this.parse();
            } else {
              this.current.source.end = tokenEnd(this.currToken);
              this.current.parent.source.end = tokenEnd(this.currToken);
              this.position++;
            }
          }
          this.current = cache2;
        } else {
          var parenStart = this.currToken;
          var parenValue = "(";
          var parenEnd;
          while (this.position < this.tokens.length && unbalanced) {
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              unbalanced++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              unbalanced--;
            }
            parenEnd = this.currToken;
            parenValue += this.parseParenthesisToken(this.currToken);
            this.position++;
          }
          if (last) {
            last.appendToPropertyAndEscape("value", parenValue, parenValue);
          } else {
            this.newNode(new _string["default"]({
              value: parenValue,
              source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
              sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
            }));
          }
        }
        if (unbalanced) {
          return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        }
      };
      _proto.pseudo = function pseudo() {
        var _this4 = this;
        var pseudoStr = "";
        var startingToken = this.currToken;
        while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
          pseudoStr += this.content();
          this.position++;
        }
        if (!this.currToken) {
          return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
          this.splitWord(false, function(first, length) {
            pseudoStr += first;
            _this4.newNode(new _pseudo["default"]({
              value: pseudoStr,
              source: getTokenSourceSpan(startingToken, _this4.currToken),
              sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
            }));
            if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              _this4.error("Misplaced parenthesis.", {
                index: _this4.nextToken[_tokenize.FIELDS.START_POS]
              });
            }
          });
        } else {
          return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
        }
      };
      _proto.space = function space() {
        var content = this.content();
        if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node) {
          return node.type === "comment";
        })) {
          this.spaces = this.optionalSpace(content);
          this.position++;
        } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          this.current.last.spaces.after = this.optionalSpace(content);
          this.position++;
        } else {
          this.combinator();
        }
      };
      _proto.string = function string() {
        var current = this.currToken;
        this.newNode(new _string["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.universal = function universal(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === "|") {
          this.position++;
          return this.namespace();
        }
        var current = this.currToken;
        this.newNode(new _universal["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }), namespace);
        this.position++;
      };
      _proto.splitWord = function splitWord(namespace, firstCallback) {
        var _this5 = this;
        var nextToken = this.nextToken;
        var word = this.content();
        while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
          this.position++;
          var current = this.content();
          word += current;
          if (current.lastIndexOf("\\") === current.length - 1) {
            var next = this.nextToken;
            if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
              word += this.requiredSpace(this.content(next));
              this.position++;
            }
          }
          nextToken = this.nextToken;
        }
        var hasClass = indexesOf(word, ".").filter(function(i3) {
          var escapedDot = word[i3 - 1] === "\\";
          var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
          return !escapedDot && !isKeyframesPercent;
        });
        var hasId = indexesOf(word, "#").filter(function(i3) {
          return word[i3 - 1] !== "\\";
        });
        var interpolations = indexesOf(word, "#{");
        if (interpolations.length) {
          hasId = hasId.filter(function(hashIndex) {
            return !~interpolations.indexOf(hashIndex);
          });
        }
        var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
        indices.forEach(function(ind, i3) {
          var index = indices[i3 + 1] || word.length;
          var value = word.slice(ind, index);
          if (i3 === 0 && firstCallback) {
            return firstCallback.call(_this5, value, indices.length);
          }
          var node;
          var current2 = _this5.currToken;
          var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i3];
          var source = getSource(current2[1], current2[2] + ind, current2[3], current2[2] + (index - 1));
          if (~hasClass.indexOf(ind)) {
            var classNameOpts = {
              value: value.slice(1),
              source,
              sourceIndex
            };
            node = new _className["default"](unescapeProp(classNameOpts, "value"));
          } else if (~hasId.indexOf(ind)) {
            var idOpts = {
              value: value.slice(1),
              source,
              sourceIndex
            };
            node = new _id["default"](unescapeProp(idOpts, "value"));
          } else {
            var tagOpts = {
              value,
              source,
              sourceIndex
            };
            unescapeProp(tagOpts, "value");
            node = new _tag["default"](tagOpts);
          }
          _this5.newNode(node, namespace);
          namespace = null;
        });
        this.position++;
      };
      _proto.word = function word(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === "|") {
          this.position++;
          return this.namespace();
        }
        return this.splitWord(namespace);
      };
      _proto.loop = function loop() {
        while (this.position < this.tokens.length) {
          this.parse(true);
        }
        this.current._inferEndPosition();
        return this.root;
      };
      _proto.parse = function parse(throwOnParenthesis) {
        switch (this.currToken[_tokenize.FIELDS.TYPE]) {
          case tokens.space:
            this.space();
            break;
          case tokens.comment:
            this.comment();
            break;
          case tokens.openParenthesis:
            this.parentheses();
            break;
          case tokens.closeParenthesis:
            if (throwOnParenthesis) {
              this.missingParenthesis();
            }
            break;
          case tokens.openSquare:
            this.attribute();
            break;
          case tokens.dollar:
          case tokens.caret:
          case tokens.equals:
          case tokens.word:
            this.word();
            break;
          case tokens.colon:
            this.pseudo();
            break;
          case tokens.comma:
            this.comma();
            break;
          case tokens.asterisk:
            this.universal();
            break;
          case tokens.ampersand:
            this.nesting();
            break;
          case tokens.slash:
          case tokens.combinator:
            this.combinator();
            break;
          case tokens.str:
            this.string();
            break;
          case tokens.closeSquare:
            this.missingSquareBracket();
          case tokens.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      };
      _proto.expected = function expected(description, index, found) {
        if (Array.isArray(description)) {
          var last = description.pop();
          description = description.join(", ") + " or " + last;
        }
        var an = /^[aeiou]/.test(description[0]) ? "an" : "a";
        if (!found) {
          return this.error("Expected " + an + " " + description + ".", {
            index
          });
        }
        return this.error("Expected " + an + " " + description + ', found "' + found + '" instead.', {
          index
        });
      };
      _proto.requiredSpace = function requiredSpace(space) {
        return this.options.lossy ? " " : space;
      };
      _proto.optionalSpace = function optionalSpace(space) {
        return this.options.lossy ? "" : space;
      };
      _proto.lossySpace = function lossySpace(space, required) {
        if (this.options.lossy) {
          return required ? " " : "";
        } else {
          return space;
        }
      };
      _proto.parseParenthesisToken = function parseParenthesisToken(token) {
        var content = this.content(token);
        if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
          return this.requiredSpace(content);
        } else {
          return content;
        }
      };
      _proto.newNode = function newNode(node, namespace) {
        if (namespace) {
          if (/^ +$/.test(namespace)) {
            if (!this.options.lossy) {
              this.spaces = (this.spaces || "") + namespace;
            }
            namespace = true;
          }
          node.namespace = namespace;
          unescapeProp(node, "namespace");
        }
        if (this.spaces) {
          node.spaces.before = this.spaces;
          this.spaces = "";
        }
        return this.current.append(node);
      };
      _proto.content = function content(token) {
        if (token === void 0) {
          token = this.currToken;
        }
        return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
      };
      _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
        if (startPosition === void 0) {
          startPosition = this.position + 1;
        }
        var searchPosition = startPosition;
        while (searchPosition < this.tokens.length) {
          if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
            searchPosition++;
            continue;
          } else {
            return searchPosition;
          }
        }
        return -1;
      };
      _createClass(Parser2, [{
        key: "currToken",
        get: function get() {
          return this.tokens[this.position];
        }
      }, {
        key: "nextToken",
        get: function get() {
          return this.tokens[this.position + 1];
        }
      }, {
        key: "prevToken",
        get: function get() {
          return this.tokens[this.position - 1];
        }
      }]);
      return Parser2;
    }();
    exports["default"] = Parser;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/processor.js
var require_processor = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/processor.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _parser = _interopRequireDefault(require_parser());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var Processor = /* @__PURE__ */ function() {
      function Processor2(func, options) {
        this.func = func || function noop() {
        };
        this.funcRes = null;
        this.options = options;
      }
      var _proto = Processor2.prototype;
      _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
        if (options === void 0) {
          options = {};
        }
        var merged = Object.assign({}, this.options, options);
        if (merged.updateSelector === false) {
          return false;
        } else {
          return typeof rule !== "string";
        }
      };
      _proto._isLossy = function _isLossy(options) {
        if (options === void 0) {
          options = {};
        }
        var merged = Object.assign({}, this.options, options);
        if (merged.lossless === false) {
          return true;
        } else {
          return false;
        }
      };
      _proto._root = function _root(rule, options) {
        if (options === void 0) {
          options = {};
        }
        var parser = new _parser["default"](rule, this._parseOptions(options));
        return parser.root;
      };
      _proto._parseOptions = function _parseOptions(options) {
        return {
          lossy: this._isLossy(options)
        };
      };
      _proto._run = function _run(rule, options) {
        var _this = this;
        if (options === void 0) {
          options = {};
        }
        return new Promise(function(resolve, reject) {
          try {
            var root = _this._root(rule, options);
            Promise.resolve(_this.func(root)).then(function(transform2) {
              var string = void 0;
              if (_this._shouldUpdateSelector(rule, options)) {
                string = root.toString();
                rule.selector = string;
              }
              return {
                transform: transform2,
                root,
                string
              };
            }).then(resolve, reject);
          } catch (e2) {
            reject(e2);
            return;
          }
        });
      };
      _proto._runSync = function _runSync(rule, options) {
        if (options === void 0) {
          options = {};
        }
        var root = this._root(rule, options);
        var transform2 = this.func(root);
        if (transform2 && typeof transform2.then === "function") {
          throw new Error("Selector processor returned a promise to a synchronous call.");
        }
        var string = void 0;
        if (options.updateSelector && typeof rule !== "string") {
          string = root.toString();
          rule.selector = string;
        }
        return {
          transform: transform2,
          root,
          string
        };
      };
      _proto.ast = function ast(rule, options) {
        return this._run(rule, options).then(function(result) {
          return result.root;
        });
      };
      _proto.astSync = function astSync(rule, options) {
        return this._runSync(rule, options).root;
      };
      _proto.transform = function transform2(rule, options) {
        return this._run(rule, options).then(function(result) {
          return result.transform;
        });
      };
      _proto.transformSync = function transformSync(rule, options) {
        return this._runSync(rule, options).transform;
      };
      _proto.process = function process2(rule, options) {
        return this._run(rule, options).then(function(result) {
          return result.string || result.root.toString();
        });
      };
      _proto.processSync = function processSync(rule, options) {
        var result = this._runSync(rule, options);
        return result.string || result.root.toString();
      };
      return Processor2;
    }();
    exports["default"] = Processor;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/constructors.js
var require_constructors = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/constructors.js"(exports) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;
    var _attribute = _interopRequireDefault(require_attribute());
    var _className = _interopRequireDefault(require_className());
    var _combinator = _interopRequireDefault(require_combinator());
    var _comment = _interopRequireDefault(require_comment());
    var _id = _interopRequireDefault(require_id());
    var _nesting = _interopRequireDefault(require_nesting());
    var _pseudo = _interopRequireDefault(require_pseudo());
    var _root = _interopRequireDefault(require_root());
    var _selector = _interopRequireDefault(require_selector());
    var _string = _interopRequireDefault(require_string());
    var _tag = _interopRequireDefault(require_tag());
    var _universal = _interopRequireDefault(require_universal());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var attribute = function attribute2(opts) {
      return new _attribute["default"](opts);
    };
    exports.attribute = attribute;
    var className = function className2(opts) {
      return new _className["default"](opts);
    };
    exports.className = className;
    var combinator = function combinator2(opts) {
      return new _combinator["default"](opts);
    };
    exports.combinator = combinator;
    var comment = function comment2(opts) {
      return new _comment["default"](opts);
    };
    exports.comment = comment;
    var id = function id2(opts) {
      return new _id["default"](opts);
    };
    exports.id = id;
    var nesting = function nesting2(opts) {
      return new _nesting["default"](opts);
    };
    exports.nesting = nesting;
    var pseudo = function pseudo2(opts) {
      return new _pseudo["default"](opts);
    };
    exports.pseudo = pseudo;
    var root = function root2(opts) {
      return new _root["default"](opts);
    };
    exports.root = root;
    var selector = function selector2(opts) {
      return new _selector["default"](opts);
    };
    exports.selector = selector;
    var string = function string2(opts) {
      return new _string["default"](opts);
    };
    exports.string = string;
    var tag = function tag2(opts) {
      return new _tag["default"](opts);
    };
    exports.tag = tag;
    var universal = function universal2(opts) {
      return new _universal["default"](opts);
    };
    exports.universal = universal;
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/guards.js
var require_guards = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/guards.js"(exports) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports.isNode = isNode;
    exports.isPseudoElement = isPseudoElement;
    exports.isPseudoClass = isPseudoClass;
    exports.isContainer = isContainer;
    exports.isNamespace = isNamespace;
    exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;
    var _types = require_types();
    var _IS_TYPE;
    var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
    function isNode(node) {
      return typeof node === "object" && IS_TYPE[node.type];
    }
    function isNodeType(type, node) {
      return isNode(node) && node.type === type;
    }
    var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
    exports.isAttribute = isAttribute;
    var isClassName = isNodeType.bind(null, _types.CLASS);
    exports.isClassName = isClassName;
    var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
    exports.isCombinator = isCombinator;
    var isComment = isNodeType.bind(null, _types.COMMENT);
    exports.isComment = isComment;
    var isIdentifier = isNodeType.bind(null, _types.ID);
    exports.isIdentifier = isIdentifier;
    var isNesting = isNodeType.bind(null, _types.NESTING);
    exports.isNesting = isNesting;
    var isPseudo = isNodeType.bind(null, _types.PSEUDO);
    exports.isPseudo = isPseudo;
    var isRoot = isNodeType.bind(null, _types.ROOT);
    exports.isRoot = isRoot;
    var isSelector = isNodeType.bind(null, _types.SELECTOR);
    exports.isSelector = isSelector;
    var isString2 = isNodeType.bind(null, _types.STRING);
    exports.isString = isString2;
    var isTag = isNodeType.bind(null, _types.TAG);
    exports.isTag = isTag;
    var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
    exports.isUniversal = isUniversal;
    function isPseudoElement(node) {
      return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after" || node.value.toLowerCase() === ":first-letter" || node.value.toLowerCase() === ":first-line");
    }
    function isPseudoClass(node) {
      return isPseudo(node) && !isPseudoElement(node);
    }
    function isContainer(node) {
      return !!(isNode(node) && node.walk);
    }
    function isNamespace(node) {
      return isAttribute(node) || isTag(node);
    }
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/index.js
var require_selectors = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/selectors/index.js"(exports) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _types[key])
        return;
      exports[key] = _types[key];
    });
    var _constructors = require_constructors();
    Object.keys(_constructors).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _constructors[key])
        return;
      exports[key] = _constructors[key];
    });
    var _guards = require_guards();
    Object.keys(_guards).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _guards[key])
        return;
      exports[key] = _guards[key];
    });
  }
});

// node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/postcss-selector-parser@6.0.10/node_modules/postcss-selector-parser/dist/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _processor = _interopRequireDefault(require_processor());
    var selectors = _interopRequireWildcard(require_selectors());
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var parser = function parser2(processor) {
      return new _processor["default"](processor);
    };
    Object.assign(parser, selectors);
    delete parser.__esModule;
    var _default = parser;
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/escapeCommas.js
var require_escapeCommas = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/escapeCommas.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => escapeCommas
    });
    function escapeCommas(className) {
      return className.replace(/\\,/g, "\\2c ");
    }
  }
});

// node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/color.js
var require_color = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/color.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      parseColor: () => parseColor,
      formatColor: () => formatColor
    });
    var _colorName = /* @__PURE__ */ _interopRequireDefault(require_color_name());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var HEX = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
    var SHORT_HEX = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
    var VALUE = /(?:\d+|\d*\.\d+)%?/;
    var SEP = /(?:\s*,\s*|\s+)/;
    var ALPHA_SEP = /\s*[,/]\s*/;
    var CUSTOM_PROPERTY = /var\(--(?:[^ )]*?)\)/;
    var RGB = new RegExp(`^(rgb)a?\\(\\s*(${VALUE.source}|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`);
    var HSL = new RegExp(`^(hsl)a?\\(\\s*((?:${VALUE.source})(?:deg|rad|grad|turn)?|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`);
    function parseColor(value, { loose = false } = {}) {
      var ref, ref1;
      if (typeof value !== "string") {
        return null;
      }
      value = value.trim();
      if (value === "transparent") {
        return {
          mode: "rgb",
          color: [
            "0",
            "0",
            "0"
          ],
          alpha: "0"
        };
      }
      if (value in _colorName.default) {
        return {
          mode: "rgb",
          color: _colorName.default[value].map((v2) => v2.toString())
        };
      }
      let hex = value.replace(SHORT_HEX, (_, r, g, b, a2) => [
        "#",
        r,
        r,
        g,
        g,
        b,
        b,
        a2 ? a2 + a2 : ""
      ].join("")).match(HEX);
      if (hex !== null) {
        return {
          mode: "rgb",
          color: [
            parseInt(hex[1], 16),
            parseInt(hex[2], 16),
            parseInt(hex[3], 16)
          ].map((v2) => v2.toString()),
          alpha: hex[4] ? (parseInt(hex[4], 16) / 255).toString() : void 0
        };
      }
      var ref2;
      let match = (ref2 = value.match(RGB)) !== null && ref2 !== void 0 ? ref2 : value.match(HSL);
      if (match === null) {
        return null;
      }
      let color2 = [
        match[2],
        match[3],
        match[4]
      ].filter(Boolean).map((v2) => v2.toString());
      if (!loose && color2.length !== 3) {
        return null;
      }
      if (color2.length < 3 && !color2.some((part) => /^var\(.*?\)$/.test(part))) {
        return null;
      }
      return {
        mode: match[1],
        color: color2,
        alpha: (ref = match[5]) === null || ref === void 0 ? void 0 : (ref1 = ref.toString) === null || ref1 === void 0 ? void 0 : ref1.call(ref)
      };
    }
    function formatColor({ mode, color: color2, alpha }) {
      let hasAlpha = alpha !== void 0;
      return `${mode}(${color2.join(" ")}${hasAlpha ? ` / ${alpha}` : ""})`;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/withAlphaVariable.js
var require_withAlphaVariable = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/withAlphaVariable.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      withAlphaValue: () => withAlphaValue,
      default: () => withAlphaVariable
    });
    var _color = require_color();
    function withAlphaValue(color2, alphaValue, defaultValue) {
      if (typeof color2 === "function") {
        return color2({
          opacityValue: alphaValue
        });
      }
      let parsed = (0, _color.parseColor)(color2, {
        loose: true
      });
      if (parsed === null) {
        return defaultValue;
      }
      return (0, _color.formatColor)({
        ...parsed,
        alpha: alphaValue
      });
    }
    function withAlphaVariable({ color: color2, property, variable }) {
      let properties = [].concat(property);
      if (typeof color2 === "function") {
        return {
          [variable]: "1",
          ...Object.fromEntries(properties.map((p2) => {
            return [
              p2,
              color2({
                opacityVariable: variable,
                opacityValue: `var(${variable})`
              })
            ];
          }))
        };
      }
      const parsed = (0, _color.parseColor)(color2);
      if (parsed === null) {
        return Object.fromEntries(properties.map((p2) => [
          p2,
          color2
        ]));
      }
      if (parsed.alpha !== void 0) {
        return Object.fromEntries(properties.map((p2) => [
          p2,
          color2
        ]));
      }
      return {
        [variable]: "1",
        ...Object.fromEntries(properties.map((p2) => {
          return [
            p2,
            (0, _color.formatColor)({
              ...parsed,
              alpha: `var(${variable})`
            })
          ];
        }))
      };
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/lib/regex.js
var require_regex = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/lib/regex.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      pattern: () => pattern,
      withoutCapturing: () => withoutCapturing,
      any: () => any,
      optional: () => optional,
      zeroOrMore: () => zeroOrMore,
      nestedBrackets: () => nestedBrackets,
      escape: () => escape
    });
    var REGEX_SPECIAL = /[\\^$.*+?()[\]{}|]/g;
    var REGEX_HAS_SPECIAL = RegExp(REGEX_SPECIAL.source);
    function toSource(source) {
      source = Array.isArray(source) ? source : [
        source
      ];
      source = source.map((item) => item instanceof RegExp ? item.source : item);
      return source.join("");
    }
    function pattern(source) {
      return new RegExp(toSource(source), "g");
    }
    function withoutCapturing(source) {
      return new RegExp(`(?:${toSource(source)})`, "g");
    }
    function any(sources) {
      return `(?:${sources.map(toSource).join("|")})`;
    }
    function optional(source) {
      return `(?:${toSource(source)})?`;
    }
    function zeroOrMore(source) {
      return `(?:${toSource(source)})*`;
    }
    function nestedBrackets(open, close, depth = 1) {
      return withoutCapturing([
        escape(open),
        /[^\s]*/,
        depth === 1 ? `[^${escape(open)}${escape(close)}s]*` : any([
          `[^${escape(open)}${escape(close)}s]*`,
          nestedBrackets(open, close, depth - 1)
        ]),
        /[^\s]*/,
        escape(close)
      ]);
    }
    function escape(string) {
      return string && REGEX_HAS_SPECIAL.test(string) ? string.replace(REGEX_SPECIAL, "\\$&") : string || "";
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/splitAtTopLevelOnly.js
var require_splitAtTopLevelOnly = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/splitAtTopLevelOnly.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "splitAtTopLevelOnly", {
      enumerable: true,
      get: () => splitAtTopLevelOnly
    });
    var _regex = /* @__PURE__ */ _interopRequireWildcard(require_regex());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function* splitAtTopLevelOnly(input, separator) {
      let SPECIALS = new RegExp(`[(){}\\[\\]${_regex.escape(separator)}]`, "g");
      let depth = 0;
      let lastIndex = 0;
      let found = false;
      let separatorIndex = 0;
      let separatorStart = 0;
      let separatorLength = separator.length;
      for (let match of input.matchAll(SPECIALS)) {
        let matchesSeparator = match[0] === separator[separatorIndex];
        let atEndOfSeparator = separatorIndex === separatorLength - 1;
        let matchesFullSeparator = matchesSeparator && atEndOfSeparator;
        if (match[0] === "(")
          depth++;
        if (match[0] === ")")
          depth--;
        if (match[0] === "[")
          depth++;
        if (match[0] === "]")
          depth--;
        if (match[0] === "{")
          depth++;
        if (match[0] === "}")
          depth--;
        if (matchesSeparator && depth === 0) {
          if (separatorStart === 0) {
            separatorStart = match.index;
          }
          separatorIndex++;
        }
        if (matchesFullSeparator && depth === 0) {
          found = true;
          yield input.substring(lastIndex, separatorStart);
          lastIndex = separatorStart + separatorLength;
        }
        if (separatorIndex === separatorLength) {
          separatorIndex = 0;
          separatorStart = 0;
        }
      }
      if (found) {
        yield input.substring(lastIndex);
      } else {
        yield input;
      }
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/parseBoxShadowValue.js
var require_parseBoxShadowValue = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/parseBoxShadowValue.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      parseBoxShadowValue: () => parseBoxShadowValue,
      formatBoxShadowValue: () => formatBoxShadowValue
    });
    var _splitAtTopLevelOnly = require_splitAtTopLevelOnly();
    var KEYWORDS = /* @__PURE__ */ new Set([
      "inset",
      "inherit",
      "initial",
      "revert",
      "unset"
    ]);
    var SPACE = /\ +(?![^(]*\))/g;
    var LENGTH = /^-?(\d+|\.\d+)(.*?)$/g;
    function parseBoxShadowValue(input) {
      let shadows = Array.from((0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(input, ","));
      return shadows.map((shadow) => {
        let value = shadow.trim();
        let result = {
          raw: value
        };
        let parts = value.split(SPACE);
        let seen = /* @__PURE__ */ new Set();
        for (let part of parts) {
          LENGTH.lastIndex = 0;
          if (!seen.has("KEYWORD") && KEYWORDS.has(part)) {
            result.keyword = part;
            seen.add("KEYWORD");
          } else if (LENGTH.test(part)) {
            if (!seen.has("X")) {
              result.x = part;
              seen.add("X");
            } else if (!seen.has("Y")) {
              result.y = part;
              seen.add("Y");
            } else if (!seen.has("BLUR")) {
              result.blur = part;
              seen.add("BLUR");
            } else if (!seen.has("SPREAD")) {
              result.spread = part;
              seen.add("SPREAD");
            }
          } else {
            if (!result.color) {
              result.color = part;
            } else {
              if (!result.unknown)
                result.unknown = [];
              result.unknown.push(part);
            }
          }
        }
        result.valid = result.x !== void 0 && result.y !== void 0;
        return result;
      });
    }
    function formatBoxShadowValue(shadows) {
      return shadows.map((shadow) => {
        if (!shadow.valid) {
          return shadow.raw;
        }
        return [
          shadow.keyword,
          shadow.x,
          shadow.y,
          shadow.blur,
          shadow.spread,
          shadow.color
        ].filter(Boolean).join(" ");
      }).join(", ");
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/dataTypes.js
var require_dataTypes = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/dataTypes.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      normalize: () => normalize,
      url: () => url,
      number: () => number,
      percentage: () => percentage,
      length: () => length,
      lineWidth: () => lineWidth,
      shadow: () => shadow,
      color: () => color2,
      image: () => image2,
      gradient: () => gradient,
      position: () => position,
      familyName: () => familyName,
      genericName: () => genericName,
      absoluteSize: () => absoluteSize,
      relativeSize: () => relativeSize
    });
    var _color = require_color();
    var _parseBoxShadowValue = require_parseBoxShadowValue();
    var cssFunctions = [
      "min",
      "max",
      "clamp",
      "calc"
    ];
    var COMMA = /,(?![^(]*\))/g;
    var UNDERSCORE = /_(?![^(]*\))/g;
    function normalize(value, isRoot = true) {
      if (value.includes("url(")) {
        return value.split(/(url\(.*?\))/g).filter(Boolean).map((part) => {
          if (/^url\(.*?\)$/.test(part)) {
            return part;
          }
          return normalize(part, false);
        }).join("");
      }
      value = value.replace(/([^\\])_+/g, (fullMatch, characterBefore) => characterBefore + " ".repeat(fullMatch.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_");
      if (isRoot) {
        value = value.trim();
      }
      value = value.replace(/(calc|min|max|clamp)\(.+\)/g, (match) => {
        return match.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ");
      });
      return value;
    }
    function url(value) {
      return value.startsWith("url(");
    }
    function number(value) {
      return !isNaN(Number(value)) || cssFunctions.some((fn) => new RegExp(`^${fn}\\(.+?`).test(value));
    }
    function percentage(value) {
      return value.split(UNDERSCORE).every((part) => {
        return /%$/g.test(part) || cssFunctions.some((fn) => new RegExp(`^${fn}\\(.+?%`).test(part));
      });
    }
    var lengthUnits = [
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px",
      "em",
      "ex",
      "ch",
      "rem",
      "lh",
      "vw",
      "vh",
      "vmin",
      "vmax"
    ];
    var lengthUnitsPattern = `(?:${lengthUnits.join("|")})`;
    function length(value) {
      return value.split(UNDERSCORE).every((part) => {
        return part === "0" || new RegExp(`${lengthUnitsPattern}$`).test(part) || cssFunctions.some((fn) => new RegExp(`^${fn}\\(.+?${lengthUnitsPattern}`).test(part));
      });
    }
    var lineWidths = /* @__PURE__ */ new Set([
      "thin",
      "medium",
      "thick"
    ]);
    function lineWidth(value) {
      return lineWidths.has(value);
    }
    function shadow(value) {
      let parsedShadows = (0, _parseBoxShadowValue.parseBoxShadowValue)(normalize(value));
      for (let parsedShadow of parsedShadows) {
        if (!parsedShadow.valid) {
          return false;
        }
      }
      return true;
    }
    function color2(value) {
      let colors = 0;
      let result = value.split(UNDERSCORE).every((part) => {
        part = normalize(part);
        if (part.startsWith("var("))
          return true;
        if ((0, _color.parseColor)(part, {
          loose: true
        }) !== null)
          return colors++, true;
        return false;
      });
      if (!result)
        return false;
      return colors > 0;
    }
    function image2(value) {
      let images = 0;
      let result = value.split(COMMA).every((part) => {
        part = normalize(part);
        if (part.startsWith("var("))
          return true;
        if (url(part) || gradient(part) || [
          "element(",
          "image(",
          "cross-fade(",
          "image-set("
        ].some((fn) => part.startsWith(fn))) {
          images++;
          return true;
        }
        return false;
      });
      if (!result)
        return false;
      return images > 0;
    }
    var gradientTypes = /* @__PURE__ */ new Set([
      "linear-gradient",
      "radial-gradient",
      "repeating-linear-gradient",
      "repeating-radial-gradient",
      "conic-gradient"
    ]);
    function gradient(value) {
      value = normalize(value);
      for (let type of gradientTypes) {
        if (value.startsWith(`${type}(`)) {
          return true;
        }
      }
      return false;
    }
    var validPositions = /* @__PURE__ */ new Set([
      "center",
      "top",
      "right",
      "bottom",
      "left"
    ]);
    function position(value) {
      let positions = 0;
      let result = value.split(UNDERSCORE).every((part) => {
        part = normalize(part);
        if (part.startsWith("var("))
          return true;
        if (validPositions.has(part) || length(part) || percentage(part)) {
          positions++;
          return true;
        }
        return false;
      });
      if (!result)
        return false;
      return positions > 0;
    }
    function familyName(value) {
      let fonts = 0;
      let result = value.split(COMMA).every((part) => {
        part = normalize(part);
        if (part.startsWith("var("))
          return true;
        if (part.includes(" ")) {
          if (!/(['"])([^"']+)\1/g.test(part)) {
            return false;
          }
        }
        if (/^\d/g.test(part)) {
          return false;
        }
        fonts++;
        return true;
      });
      if (!result)
        return false;
      return fonts > 0;
    }
    var genericNames = /* @__PURE__ */ new Set([
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui",
      "ui-serif",
      "ui-sans-serif",
      "ui-monospace",
      "ui-rounded",
      "math",
      "emoji",
      "fangsong"
    ]);
    function genericName(value) {
      return genericNames.has(value);
    }
    var absoluteSizes = /* @__PURE__ */ new Set([
      "xx-small",
      "x-small",
      "small",
      "medium",
      "large",
      "x-large",
      "x-large",
      "xxx-large"
    ]);
    function absoluteSize(value) {
      return absoluteSizes.has(value);
    }
    var relativeSizes = /* @__PURE__ */ new Set([
      "larger",
      "smaller"
    ]);
    function relativeSize(value) {
      return relativeSizes.has(value);
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/pluginUtils.js
var require_pluginUtils = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/pluginUtils.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      updateAllClasses: () => updateAllClasses,
      asValue: () => asValue,
      parseColorFormat: () => parseColorFormat,
      asColor: () => asColor,
      asLookupValue: () => asLookupValue,
      coerceValue: () => coerceValue
    });
    var _postcssSelectorParser = /* @__PURE__ */ _interopRequireDefault(require_dist());
    var _escapeCommas = /* @__PURE__ */ _interopRequireDefault(require_escapeCommas());
    var _withAlphaVariable = require_withAlphaVariable();
    var _dataTypes = require_dataTypes();
    var _negateValue = /* @__PURE__ */ _interopRequireDefault(require_negateValue());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function updateAllClasses(selectors, updateClass) {
      let parser = (0, _postcssSelectorParser.default)((selectors2) => {
        selectors2.walkClasses((sel) => {
          let updatedClass = updateClass(sel.value);
          sel.value = updatedClass;
          if (sel.raws && sel.raws.value) {
            sel.raws.value = (0, _escapeCommas.default)(sel.raws.value);
          }
        });
      });
      let result = parser.processSync(selectors);
      return result;
    }
    function resolveArbitraryValue(modifier, validate) {
      if (!isArbitraryValue(modifier)) {
        return void 0;
      }
      let value = modifier.slice(1, -1);
      if (!validate(value)) {
        return void 0;
      }
      return (0, _dataTypes.normalize)(value);
    }
    function asNegativeValue(modifier, lookup = {}, validate) {
      let positiveValue = lookup[modifier];
      if (positiveValue !== void 0) {
        return (0, _negateValue.default)(positiveValue);
      }
      if (isArbitraryValue(modifier)) {
        let resolved = resolveArbitraryValue(modifier, validate);
        if (resolved === void 0) {
          return void 0;
        }
        return (0, _negateValue.default)(resolved);
      }
    }
    function asValue(modifier, options = {}, { validate = () => true } = {}) {
      var ref;
      let value = (ref = options.values) === null || ref === void 0 ? void 0 : ref[modifier];
      if (value !== void 0) {
        return value;
      }
      if (options.supportsNegativeValues && modifier.startsWith("-")) {
        return asNegativeValue(modifier.slice(1), options.values, validate);
      }
      return resolveArbitraryValue(modifier, validate);
    }
    function isArbitraryValue(input) {
      return input.startsWith("[") && input.endsWith("]");
    }
    function splitAlpha(modifier) {
      let slashIdx = modifier.lastIndexOf("/");
      if (slashIdx === -1 || slashIdx === modifier.length - 1) {
        return [
          modifier
        ];
      }
      return [
        modifier.slice(0, slashIdx),
        modifier.slice(slashIdx + 1)
      ];
    }
    function parseColorFormat(value) {
      if (typeof value === "string" && value.includes("<alpha-value>")) {
        let oldValue = value;
        return ({ opacityValue = 1 }) => oldValue.replace("<alpha-value>", opacityValue);
      }
      return value;
    }
    function asColor(modifier, options = {}, { tailwindConfig = {} } = {}) {
      var ref;
      if (((ref = options.values) === null || ref === void 0 ? void 0 : ref[modifier]) !== void 0) {
        var ref1;
        return parseColorFormat((ref1 = options.values) === null || ref1 === void 0 ? void 0 : ref1[modifier]);
      }
      let [color2, alpha] = splitAlpha(modifier);
      if (alpha !== void 0) {
        var ref2, ref3, ref4;
        var ref5;
        let normalizedColor = (ref5 = (ref2 = options.values) === null || ref2 === void 0 ? void 0 : ref2[color2]) !== null && ref5 !== void 0 ? ref5 : isArbitraryValue(color2) ? color2.slice(1, -1) : void 0;
        if (normalizedColor === void 0) {
          return void 0;
        }
        normalizedColor = parseColorFormat(normalizedColor);
        if (isArbitraryValue(alpha)) {
          return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, alpha.slice(1, -1));
        }
        if (((ref3 = tailwindConfig.theme) === null || ref3 === void 0 ? void 0 : (ref4 = ref3.opacity) === null || ref4 === void 0 ? void 0 : ref4[alpha]) === void 0) {
          return void 0;
        }
        return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, tailwindConfig.theme.opacity[alpha]);
      }
      return asValue(modifier, options, {
        validate: _dataTypes.color
      });
    }
    function asLookupValue(modifier, options = {}) {
      var ref;
      return (ref = options.values) === null || ref === void 0 ? void 0 : ref[modifier];
    }
    function guess(validate) {
      return (modifier, options) => {
        return asValue(modifier, options, {
          validate
        });
      };
    }
    var typeMap = {
      any: asValue,
      color: asColor,
      url: guess(_dataTypes.url),
      image: guess(_dataTypes.image),
      length: guess(_dataTypes.length),
      percentage: guess(_dataTypes.percentage),
      position: guess(_dataTypes.position),
      lookup: asLookupValue,
      "generic-name": guess(_dataTypes.genericName),
      "family-name": guess(_dataTypes.familyName),
      number: guess(_dataTypes.number),
      "line-width": guess(_dataTypes.lineWidth),
      "absolute-size": guess(_dataTypes.absoluteSize),
      "relative-size": guess(_dataTypes.relativeSize),
      shadow: guess(_dataTypes.shadow)
    };
    var supportedTypes = Object.keys(typeMap);
    function splitAtFirst(input, delim) {
      let idx = input.indexOf(delim);
      if (idx === -1)
        return [
          void 0,
          input
        ];
      return [
        input.slice(0, idx),
        input.slice(idx + 1)
      ];
    }
    function coerceValue(types, modifier, options, tailwindConfig) {
      if (isArbitraryValue(modifier)) {
        let arbitraryValue = modifier.slice(1, -1);
        let [explicitType, value] = splitAtFirst(arbitraryValue, ":");
        if (!/^[\w-_]+$/g.test(explicitType)) {
          value = arbitraryValue;
        } else if (explicitType !== void 0 && !supportedTypes.includes(explicitType)) {
          return [];
        }
        if (value.length > 0 && supportedTypes.includes(explicitType)) {
          return [
            asValue(`[${value}]`, options),
            explicitType
          ];
        }
      }
      for (let type of [].concat(types)) {
        let result = typeMap[type](modifier, options, {
          tailwindConfig
        });
        if (result !== void 0)
          return [
            result,
            type
          ];
      }
      return [];
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/toColorValue.js
var require_toColorValue = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/toColorValue.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => toColorValue
    });
    function toColorValue(maybeFunction) {
      return typeof maybeFunction === "function" ? maybeFunction({}) : maybeFunction;
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/resolveConfig.js
var require_resolveConfig = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/resolveConfig.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => resolveConfig2
    });
    var _negateValue = /* @__PURE__ */ _interopRequireDefault(require_negateValue());
    var _corePluginList = /* @__PURE__ */ _interopRequireDefault(require_corePluginList());
    var _configurePlugins = /* @__PURE__ */ _interopRequireDefault(require_configurePlugins());
    var _defaultConfigStub = /* @__PURE__ */ _interopRequireDefault(require_defaultConfig_stub());
    var _colors = /* @__PURE__ */ _interopRequireDefault(require_colors());
    var _defaults = require_defaults();
    var _toPath = require_toPath();
    var _normalizeConfig = require_normalizeConfig();
    var _isPlainObject = /* @__PURE__ */ _interopRequireDefault(require_isPlainObject());
    var _cloneDeep = require_cloneDeep();
    var _pluginUtils = require_pluginUtils();
    var _withAlphaVariable = require_withAlphaVariable();
    var _toColorValue = /* @__PURE__ */ _interopRequireDefault(require_toColorValue());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function isFunction(input) {
      return typeof input === "function";
    }
    function isObject2(input) {
      return typeof input === "object" && input !== null;
    }
    function mergeWith(target, ...sources) {
      let customizer = sources.pop();
      for (let source of sources) {
        for (let k in source) {
          let merged = customizer(target[k], source[k]);
          if (merged === void 0) {
            if (isObject2(target[k]) && isObject2(source[k])) {
              target[k] = mergeWith(target[k], source[k], customizer);
            } else {
              target[k] = source[k];
            }
          } else {
            target[k] = merged;
          }
        }
      }
      return target;
    }
    var configUtils = {
      colors: _colors.default,
      negative(scale) {
        return Object.keys(scale).filter((key) => scale[key] !== "0").reduce((negativeScale, key) => {
          let negativeValue = (0, _negateValue.default)(scale[key]);
          if (negativeValue !== void 0) {
            negativeScale[`-${key}`] = negativeValue;
          }
          return negativeScale;
        }, {});
      },
      breakpoints(screens2) {
        return Object.keys(screens2).filter((key) => typeof screens2[key] === "string").reduce((breakpoints, key) => ({
          ...breakpoints,
          [`screen-${key}`]: screens2[key]
        }), {});
      }
    };
    function value(valueToResolve, ...args) {
      return isFunction(valueToResolve) ? valueToResolve(...args) : valueToResolve;
    }
    function collectExtends(items) {
      return items.reduce((merged, { extend }) => {
        return mergeWith(merged, extend, (mergedValue, extendValue) => {
          if (mergedValue === void 0) {
            return [
              extendValue
            ];
          }
          if (Array.isArray(mergedValue)) {
            return [
              extendValue,
              ...mergedValue
            ];
          }
          return [
            extendValue,
            mergedValue
          ];
        });
      }, {});
    }
    function mergeThemes(themes) {
      return {
        ...themes.reduce((merged, theme) => (0, _defaults.defaults)(merged, theme), {}),
        extend: collectExtends(themes)
      };
    }
    function mergeExtensionCustomizer(merged, value2) {
      if (Array.isArray(merged) && isObject2(merged[0])) {
        return merged.concat(value2);
      }
      if (Array.isArray(value2) && isObject2(value2[0]) && isObject2(merged)) {
        return [
          merged,
          ...value2
        ];
      }
      if (Array.isArray(value2)) {
        return value2;
      }
      return void 0;
    }
    function mergeExtensions({ extend, ...theme }) {
      return mergeWith(theme, extend, (themeValue, extensions) => {
        if (!isFunction(themeValue) && !extensions.some(isFunction)) {
          return mergeWith({}, themeValue, ...extensions, mergeExtensionCustomizer);
        }
        return (resolveThemePath, utils) => mergeWith({}, ...[
          themeValue,
          ...extensions
        ].map((e2) => value(e2, resolveThemePath, utils)), mergeExtensionCustomizer);
      });
    }
    function* toPaths(key) {
      let path = (0, _toPath.toPath)(key);
      if (path.length === 0) {
        return;
      }
      yield path;
      if (Array.isArray(key)) {
        return;
      }
      let pattern = /^(.*?)\s*\/\s*([^/]+)$/;
      let matches = key.match(pattern);
      if (matches !== null) {
        let [, prefix, alpha] = matches;
        let newPath = (0, _toPath.toPath)(prefix);
        newPath.alpha = alpha;
        yield newPath;
      }
    }
    function resolveFunctionKeys(object) {
      const resolvePath = (key, defaultValue) => {
        for (const path of toPaths(key)) {
          let index = 0;
          let val = object;
          while (val !== void 0 && val !== null && index < path.length) {
            val = val[path[index++]];
            let shouldResolveAsFn = isFunction(val) && (path.alpha === void 0 || index <= path.length - 1);
            val = shouldResolveAsFn ? val(resolvePath, configUtils) : val;
          }
          if (val !== void 0) {
            if (path.alpha !== void 0) {
              let normalized = (0, _pluginUtils.parseColorFormat)(val);
              return (0, _withAlphaVariable.withAlphaValue)(normalized, path.alpha, (0, _toColorValue.default)(normalized));
            }
            if ((0, _isPlainObject.default)(val)) {
              return (0, _cloneDeep.cloneDeep)(val);
            }
            return val;
          }
        }
        return defaultValue;
      };
      Object.assign(resolvePath, {
        theme: resolvePath,
        ...configUtils
      });
      return Object.keys(object).reduce((resolved, key) => {
        resolved[key] = isFunction(object[key]) ? object[key](resolvePath, configUtils) : object[key];
        return resolved;
      }, {});
    }
    function extractPluginConfigs(configs) {
      let allConfigs = [];
      configs.forEach((config2) => {
        allConfigs = [
          ...allConfigs,
          config2
        ];
        var ref;
        const plugins = (ref = config2 === null || config2 === void 0 ? void 0 : config2.plugins) !== null && ref !== void 0 ? ref : [];
        if (plugins.length === 0) {
          return;
        }
        plugins.forEach((plugin) => {
          if (plugin.__isOptionsFunction) {
            plugin = plugin();
          }
          var ref2;
          allConfigs = [
            ...allConfigs,
            ...extractPluginConfigs([
              (ref2 = plugin === null || plugin === void 0 ? void 0 : plugin.config) !== null && ref2 !== void 0 ? ref2 : {}
            ])
          ];
        });
      });
      return allConfigs;
    }
    function resolveCorePlugins(corePluginConfigs) {
      const result = [
        ...corePluginConfigs
      ].reduceRight((resolved, corePluginConfig) => {
        if (isFunction(corePluginConfig)) {
          return corePluginConfig({
            corePlugins: resolved
          });
        }
        return (0, _configurePlugins.default)(corePluginConfig, resolved);
      }, _corePluginList.default);
      return result;
    }
    function resolvePluginLists(pluginLists) {
      const result = [
        ...pluginLists
      ].reduceRight((resolved, pluginList) => {
        return [
          ...resolved,
          ...pluginList
        ];
      }, []);
      return result;
    }
    function resolveConfig2(configs) {
      let allConfigs = [
        ...extractPluginConfigs(configs),
        {
          prefix: "",
          important: false,
          separator: ":",
          variantOrder: _defaultConfigStub.default.variantOrder
        }
      ];
      var ref, ref1;
      return (0, _normalizeConfig.normalizeConfig)((0, _defaults.defaults)({
        theme: resolveFunctionKeys(mergeExtensions(mergeThemes(allConfigs.map((t) => {
          return (ref = t === null || t === void 0 ? void 0 : t.theme) !== null && ref !== void 0 ? ref : {};
        })))),
        corePlugins: resolveCorePlugins(allConfigs.map((c2) => c2.corePlugins)),
        plugins: resolvePluginLists(configs.map((c2) => {
          return (ref1 = c2 === null || c2 === void 0 ? void 0 : c2.plugins) !== null && ref1 !== void 0 ? ref1 : [];
        }))
      }, ...allConfigs));
    }
  }
});

// src/vendor/twrnc/picocolors.js
var picocolors_exports = {};
__export(picocolors_exports, {
  default: () => picocolors_default
});
var picocolors_default;
var init_picocolors = __esm({
  "src/vendor/twrnc/picocolors.js"() {
    init_esm_shims();
    picocolors_default = {
      yellow: (s2) => s2
    };
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/featureFlags.js
var require_featureFlags = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/featureFlags.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      flagEnabled: () => flagEnabled,
      issueFlagNotices: () => issueFlagNotices,
      default: () => _default
    });
    var _picocolors = /* @__PURE__ */ _interopRequireDefault((init_picocolors(), __toCommonJS(picocolors_exports)));
    var _log = /* @__PURE__ */ _interopRequireDefault((init_log(), __toCommonJS(log_exports)));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var defaults = {
      optimizeUniversalDefaults: false
    };
    var featureFlags = {
      future: [
        "hoverOnlyWhenSupported",
        "respectDefaultRingColorOpacity"
      ],
      experimental: [
        "optimizeUniversalDefaults",
        "matchVariant"
      ]
    };
    function flagEnabled(config2, flag) {
      if (featureFlags.future.includes(flag)) {
        var ref;
        var ref1, ref2;
        return config2.future === "all" || ((ref2 = (ref1 = config2 === null || config2 === void 0 ? void 0 : (ref = config2.future) === null || ref === void 0 ? void 0 : ref[flag]) !== null && ref1 !== void 0 ? ref1 : defaults[flag]) !== null && ref2 !== void 0 ? ref2 : false);
      }
      if (featureFlags.experimental.includes(flag)) {
        var ref3;
        var ref4, ref5;
        return config2.experimental === "all" || ((ref5 = (ref4 = config2 === null || config2 === void 0 ? void 0 : (ref3 = config2.experimental) === null || ref3 === void 0 ? void 0 : ref3[flag]) !== null && ref4 !== void 0 ? ref4 : defaults[flag]) !== null && ref5 !== void 0 ? ref5 : false);
      }
      return false;
    }
    function experimentalFlagsEnabled(config2) {
      if (config2.experimental === "all") {
        return featureFlags.experimental;
      }
      var ref;
      return Object.keys((ref = config2 === null || config2 === void 0 ? void 0 : config2.experimental) !== null && ref !== void 0 ? ref : {}).filter((flag) => featureFlags.experimental.includes(flag) && config2.experimental[flag]);
    }
    function issueFlagNotices(config2) {
      if (process.env.JEST_WORKER_ID !== void 0) {
        return;
      }
      if (experimentalFlagsEnabled(config2).length > 0) {
        let changes = experimentalFlagsEnabled(config2).map((s2) => _picocolors.default.yellow(s2)).join(", ");
        _log.default.warn("experimental-flags-enabled", [
          `You have enabled experimental features: ${changes}`,
          "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
        ]);
      }
    }
    var _default = featureFlags;
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/getAllConfigs.js
var require_getAllConfigs = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/util/getAllConfigs.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => getAllConfigs
    });
    var _defaultConfigStubJs = /* @__PURE__ */ _interopRequireDefault(require_defaultConfig_stub());
    var _featureFlags = require_featureFlags();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function getAllConfigs(config2) {
      var ref;
      const configs = ((ref = config2 === null || config2 === void 0 ? void 0 : config2.presets) !== null && ref !== void 0 ? ref : [
        _defaultConfigStubJs.default
      ]).slice().reverse().flatMap((preset) => getAllConfigs(typeof preset === "function" ? preset() : preset));
      const features = {
        respectDefaultRingColorOpacity: {
          theme: {
            ringColor: {
              DEFAULT: "#3b82f67f"
            }
          }
        }
      };
      const experimentals = Object.keys(features).filter((feature) => (0, _featureFlags.flagEnabled)(config2, feature)).map((feature) => features[feature]);
      return [
        config2,
        ...experimentals,
        ...configs
      ];
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/public/resolve-config.js
var require_resolve_config = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/lib/public/resolve-config.js"(exports) {
    "use strict";
    init_esm_shims();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: () => resolveConfig2
    });
    var _resolveConfig = /* @__PURE__ */ _interopRequireDefault(require_resolveConfig());
    var _getAllConfigs = /* @__PURE__ */ _interopRequireDefault(require_getAllConfigs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function resolveConfig2(...configs) {
      let [, ...defaultConfigs] = (0, _getAllConfigs.default)(configs[0]);
      return (0, _resolveConfig.default)([
        ...configs,
        ...defaultConfigs
      ]);
    }
  }
});

// node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/resolveConfig.js
var require_resolveConfig2 = __commonJS({
  "node_modules/.pnpm/tailwindcss@3.1.8/node_modules/tailwindcss/resolveConfig.js"(exports, module) {
    init_esm_shims();
    var resolveConfig2 = require_resolve_config();
    module.exports = (resolveConfig2.__esModule ? resolveConfig2 : { default: resolveConfig2 }).default;
  }
});

// src/index.ts
init_esm_shims();

// src/satori.ts
init_esm_shims();

// src/yoga/index.ts
init_esm_shims();

// src/yoga/yoga-prebuilt.wasm.ts
init_esm_shims();
var yoga_prebuilt_wasm_default = {};

// src/yoga/index.ts
var Yoga;
Yoga = yoga_prebuilt_wasm_default.default;
function init(yoga) {
  Yoga = yoga;
}
function getYoga() {
  return Yoga;
}

// src/layout.ts
init_esm_shims();

// src/utils.ts
init_esm_shims();

// src/vendor/parse-css-dimension/index.js
init_esm_shims();
var e = (t, r) => () => (r || t((r = { exports: {} }).exports, r), r.exports);
var u = e((k, g) => {
  g.exports = ["em", "ex", "ch", "rem", "vh", "vw", "vmin", "vmax", "px", "mm", "cm", "in", "pt", "pc", "mozmm"];
});
var a = e((z, v2) => {
  v2.exports = ["deg", "grad", "rad", "turn"];
});
var c = e((L, w) => {
  w.exports = ["dpi", "dpcm", "dppx"];
});
var h = e(($, y) => {
  y.exports = ["Hz", "kHz"];
});
var m = e((j, b) => {
  b.exports = ["s", "ms"];
});
var q = u();
var f = a();
var p = c();
var l = h();
var d = m();
function s(t) {
  if (/\.\D?$/.test(t))
    throw new Error("The dot should be followed by a number");
  if (/^[+-]{2}/.test(t))
    throw new Error("Only one leading +/- is allowed");
  if (x(t) > 1)
    throw new Error("Only one dot is allowed");
  if (/%$/.test(t)) {
    this.type = "percentage", this.value = o(t), this.unit = "%";
    return;
  }
  var r = O(t);
  if (!r) {
    this.type = "number", this.value = o(t);
    return;
  }
  this.type = F(r), this.value = o(t.substr(0, t.length - r.length)), this.unit = r;
}
s.prototype.valueOf = function() {
  return this.value;
};
s.prototype.toString = function() {
  return this.value + (this.unit || "");
};
function U(t) {
  return new s(t);
}
function x(t) {
  var r = t.match(/\./g);
  return r ? r.length : 0;
}
function o(t) {
  var r = parseFloat(t);
  if (isNaN(r))
    throw new Error("Invalid number: " + t);
  return r;
}
var E = [].concat(f, l, q, p, d);
function O(t) {
  var r = t.match(/\D+$/), n = r && r[0];
  if (n && E.indexOf(n) === -1)
    throw new Error("Invalid unit: " + n);
  return n;
}
var D = Object.assign(i(f, "angle"), i(l, "frequency"), i(p, "resolution"), i(d, "time"));
function i(t, r) {
  return Object.fromEntries(t.map((n) => [n, r]));
}
function F(t) {
  return D[t] || "length";
}

// src/utils.ts
function isReactElement(node) {
  const type = typeof node;
  if (type === "number" || type === "bigint" || type === "string" || type === "boolean") {
    return false;
  }
  return true;
}
function isClass(f2) {
  return /^class\s/.test(f2.toString());
}
function normalizeChildren(children) {
  const flattend = typeof children === "undefined" ? [] : [].concat(children).flat(Infinity);
  const res = [];
  for (let i3 = 0; i3 < flattend.length; i3++) {
    let value = flattend[i3];
    if (typeof value === "undefined" || typeof value === "boolean" || value === null) {
      continue;
    }
    if (typeof value === "number") {
      value = String(value);
    }
    if (typeof value === "string" && res.length && typeof res[res.length - 1] === "string") {
      res[res.length - 1] += value;
    } else {
      res.push(value);
    }
  }
  return res;
}
function lengthToNumber(length, baseFontSize, baseLength, inheritedStyle, percentage = false) {
  if (typeof length === "number")
    return length;
  try {
    length = length.trim();
    if (/[ /\(,]/.test(length))
      return;
    const parsed = new U(length);
    if (parsed.type === "length") {
      switch (parsed.unit) {
        case "em":
          return parsed.value * baseFontSize;
        case "rem":
          return parsed.value * 16;
        case "vw":
          return ~~(parsed.value * inheritedStyle._viewportWidth / 100);
        case "vh":
          return ~~(parsed.value * inheritedStyle._viewportHeight / 100);
        default:
          return parsed.value;
      }
    } else if (parsed.type === "angle") {
      switch (parsed.unit) {
        case "deg":
          return parsed.value;
        case "rad":
          return parsed.value * 180 / Math.PI;
        default:
          return parsed.value;
      }
    } else if (parsed.type === "percentage") {
      if (percentage) {
        return parsed.value / 100 * baseLength;
      }
    }
  } catch (err) {
  }
}
function multiply(m1, m2) {
  return [
    m1[0] * m2[0] + m1[2] * m2[1],
    m1[1] * m2[0] + m1[3] * m2[1],
    m1[0] * m2[2] + m1[2] * m2[3],
    m1[1] * m2[2] + m1[3] * m2[3],
    m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
    m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
  ];
}
function v(field, map, fallback, errorIfNotAllowedForProperty) {
  let value = map[field];
  if (typeof value === "undefined") {
    if (errorIfNotAllowedForProperty && typeof field !== "undefined") {
      throw new Error(
        `Invalid value for CSS property "${errorIfNotAllowedForProperty}". Allowed values: ${Object.keys(
          map
        ).map((v2) => `"${v2}"`).join(" | ")}. Received: "${field}".`
      );
    }
    value = fallback;
  }
  return value;
}
var locale = void 0;
var wordSegmenter;
var graphemeSegmenter;
var wordSeparators = [
  32,
  160,
  4961,
  65792,
  65793,
  4153,
  4241,
  10
].map((point) => String.fromCodePoint(point));
function segment(content, granularity) {
  if (!wordSegmenter || !graphemeSegmenter) {
    if (!(typeof Intl !== "undefined" && "Segmenter" in Intl)) {
      throw new Error(
        "Intl.Segmenter does not exist, please use import a polyfill."
      );
    }
    wordSegmenter = new Intl.Segmenter(locale, { granularity: "word" });
    graphemeSegmenter = new Intl.Segmenter(locale, {
      granularity: "grapheme"
    });
  }
  return granularity === "word" ? [...wordSegmenter.segment(content)].map((seg) => seg.segment) : [...graphemeSegmenter.segment(content)].map((seg) => seg.segment);
}
function buildXMLString(type, attrs, children) {
  let attrString = "";
  for (const [k, v2] of Object.entries(attrs)) {
    if (typeof v2 !== "undefined") {
      attrString += ` ${k}="${v2}"`;
    }
  }
  if (children) {
    return `<${type}${attrString}>${children}</${type}>`;
  }
  return `<${type}${attrString}/>`;
}
function createLRU(max = 20) {
  const store = /* @__PURE__ */ new Map();
  function set(key, value) {
    if (store.size >= max) {
      const keyToDelete = store.keys().next().value;
      store.delete(keyToDelete);
    }
    store.set(key, value);
  }
  function get(key) {
    const hasKey = store.has(key);
    if (!hasKey)
      return void 0;
    const entry = store.get(key);
    store.delete(key);
    store.set(key, entry);
    return entry;
  }
  return {
    set,
    get
  };
}
var ATTRIBUTE_MAPPING = {
  accentHeight: "accent-height",
  alignmentBaseline: "alignment-baseline",
  arabicForm: "arabic-form",
  baselineShift: "baseline-shift",
  capHeight: "cap-height",
  clipPath: "clip-path",
  clipRule: "clip-rule",
  colorInterpolation: "color-interpolation",
  colorInterpolationFilters: "color-interpolation-filters",
  colorProfile: "color-profile",
  colorRendering: "color-rendering",
  dominantBaseline: "dominant-baseline",
  enableBackground: "enable-background",
  fillOpacity: "fill-opacity",
  fillRule: "fill-rule",
  floodColor: "flood-color",
  floodOpacity: "flood-opacity",
  fontFamily: "font-family",
  fontSize: "font-size",
  fontSizeAdjust: "font-size-adjust",
  fontStretch: "font-stretch",
  fontStyle: "font-style",
  fontVariant: "font-variant",
  fontWeight: "font-weight",
  glyphName: "glyph-name",
  glyphOrientationHorizontal: "glyph-orientation-horizontal",
  glyphOrientationVertical: "glyph-orientation-vertical",
  horizAdvX: "horiz-adv-x",
  horizOriginX: "horiz-origin-x",
  imageRendering: "image-rendering",
  letterSpacing: "letter-spacing",
  lightingColor: "lighting-color",
  markerEnd: "marker-end",
  markerMid: "marker-mid",
  markerStart: "marker-start",
  overlinePosition: "overline-position",
  overlineThickness: "overline-thickness",
  paintOrder: "paint-order",
  panose1: "panose-1",
  pointerEvents: "pointer-events",
  renderingIntent: "rendering-intent",
  shapeRendering: "shape-rendering",
  stopColor: "stop-color",
  stopOpacity: "stop-opacity",
  strikethroughPosition: "strikethrough-position",
  strikethroughThickness: "strikethrough-thickness",
  strokeDasharray: "stroke-dasharray",
  strokeDashoffset: "stroke-dashoffset",
  strokeLinecap: "stroke-linecap",
  strokeLinejoin: "stroke-linejoin",
  strokeMiterlimit: "stroke-miterlimit",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  textAnchor: "text-anchor",
  textDecoration: "text-decoration",
  textRendering: "text-rendering",
  underlinePosition: "underline-position",
  underlineThickness: "underline-thickness",
  unicodeBidi: "unicode-bidi",
  unicodeRange: "unicode-range",
  unitsPerEm: "units-per-em",
  vAlphabetic: "v-alphabetic",
  vHanging: "v-hanging",
  vIdeographic: "v-ideographic",
  vMathematical: "v-mathematical",
  vectorEffect: "vector-effect",
  vertAdvY: "vert-adv-y",
  vertOriginX: "vert-origin-x",
  vertOriginY: "vert-origin-y",
  wordSpacing: "word-spacing",
  writingMode: "writing-mode",
  xHeight: "x-height",
  xlinkActuate: "xlink:actuate",
  xlinkArcrole: "xlink:arcrole",
  xlinkHref: "xlink:href",
  xlinkRole: "xlink:role",
  xlinkShow: "xlink:show",
  xlinkTitle: "xlink:title",
  xlinkType: "xlink:type",
  xmlBase: "xml:base",
  xmlLang: "xml:lang",
  xmlSpace: "xml:space",
  xmlnsXlink: "xmlns:xlink"
};
var SVGSymbols = /[\r\n%#()<>?[\\\]^`{|}"']/g;
function translateSVGNodeToSVGString(node) {
  if (!node)
    return "";
  if (Array.isArray(node)) {
    return node.map(translateSVGNodeToSVGString).join("");
  }
  if (typeof node !== "object")
    return String(node);
  const type = node.type;
  if (type === "text") {
    throw new Error(
      "<text> nodes are not currently supported, please convert them to <path>"
    );
  }
  const { children, ...restProps } = node.props || {};
  return `<${type}${Object.entries(restProps).map(([k, v2]) => {
    return ` ${ATTRIBUTE_MAPPING[k] || k}="${v2}"`;
  }).join("")}>${translateSVGNodeToSVGString(children)}</${type}>`;
}
function SVGNodeToImage(node) {
  let {
    viewBox,
    viewbox,
    width,
    height,
    className,
    style,
    children,
    ...restProps
  } = node.props || {};
  viewBox || (viewBox = viewbox);
  const viewBoxSize = viewBox.split(" ").map((v2) => parseInt(v2, 10));
  restProps.xmlns = "http://www.w3.org/2000/svg";
  restProps.viewBox = viewBox;
  restProps.width = viewBoxSize[2];
  restProps.height = viewBoxSize[3];
  return `data:image/svg+xml;utf8,${`<svg${Object.entries(restProps).map(([k, v2]) => {
    return ` ${ATTRIBUTE_MAPPING[k] || k}="${v2}"`;
  }).join("")}>${translateSVGNodeToSVGString(children)}</svg>`.replace(
    SVGSymbols,
    encodeURIComponent
  )}`;
}

// src/handler/index.ts
init_esm_shims();

// src/handler/presets.ts
init_esm_shims();
var DEFAULT_DISPLAY = "flex";
var presets_default = {
  p: {
    display: DEFAULT_DISPLAY,
    marginTop: "1em",
    marginBottom: "1em"
  },
  div: {
    display: DEFAULT_DISPLAY
  },
  blockquote: {
    display: DEFAULT_DISPLAY,
    marginTop: "1em",
    marginBottom: "1em",
    marginLeft: 40,
    marginRight: 40
  },
  center: {
    display: DEFAULT_DISPLAY,
    textAlign: "center"
  },
  hr: {
    display: DEFAULT_DISPLAY,
    marginTop: "0.5em",
    marginBottom: "0.5em",
    marginLeft: "auto",
    marginRight: "auto",
    borderWidth: 1,
    borderStyle: "solid"
  },
  h1: {
    display: DEFAULT_DISPLAY,
    fontSize: "2em",
    marginTop: "0.67em",
    marginBottom: "0.67em",
    marginLeft: 0,
    marginRight: 0,
    fontWeight: "bold"
  },
  h2: {
    display: DEFAULT_DISPLAY,
    fontSize: "1.5em",
    marginTop: "0.83em",
    marginBottom: "0.83em",
    marginLeft: 0,
    marginRight: 0,
    fontWeight: "bold"
  },
  h3: {
    display: DEFAULT_DISPLAY,
    fontSize: "1.17em",
    marginTop: "1em",
    marginBottom: "1em",
    marginLeft: 0,
    marginRight: 0,
    fontWeight: "bold"
  },
  h4: {
    display: DEFAULT_DISPLAY,
    marginTop: "1.33em",
    marginBottom: "1.33em",
    marginLeft: 0,
    marginRight: 0,
    fontWeight: "bold"
  },
  h5: {
    display: DEFAULT_DISPLAY,
    fontSize: "0.83em",
    marginTop: "1.67em",
    marginBottom: "1.67em",
    marginLeft: 0,
    marginRight: 0,
    fontWeight: "bold"
  },
  h6: {
    display: DEFAULT_DISPLAY,
    fontSize: "0.67em",
    marginTop: "2.33em",
    marginBottom: "2.33em",
    marginLeft: 0,
    marginRight: 0,
    fontWeight: "bold"
  },
  u: {
    textDecoration: "underline"
  },
  strong: {
    fontWeight: "bold"
  },
  b: {
    fontWeight: "bold"
  },
  i: {
    fontStyle: "italic"
  },
  em: {
    fontStyle: "italic"
  },
  code: {
    fontFamily: "monospace"
  },
  kbd: {
    fontFamily: "monospace"
  },
  pre: {
    display: DEFAULT_DISPLAY,
    fontFamily: "monospace",
    whiteSpace: "pre",
    marginTop: "1em",
    marginBottom: "1em"
  },
  mark: {
    backgroundColor: "yellow",
    color: "black"
  },
  big: {
    fontSize: "larger"
  },
  small: {
    fontSize: "smaller"
  },
  s: {
    textDecoration: "line-through"
  }
};

// src/handler/inheritable.ts
init_esm_shims();
var list = /* @__PURE__ */ new Set([
  "color",
  "font",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "lineHeight",
  "textAlign",
  "textTransform",
  "textShadowOffset",
  "textShadowColor",
  "textShadowRadius",
  "textDecorationLine",
  "textDecorationStyle",
  "textDecorationColor",
  "whiteSpace",
  "transform",
  "wordBreak",
  "opacity",
  "filter",
  "_viewportWidth",
  "_viewportHeight",
  "_inheritedClipPathId",
  "_inheritedMaskId",
  "_inheritedBackgroundClipTextPath"
]);
function inheritable(style) {
  const inheritedStyle = {};
  for (const prop in style) {
    if (list.has(prop)) {
      inheritedStyle[prop] = style[prop];
    }
  }
  return inheritedStyle;
}

// src/handler/expand.ts
init_esm_shims();
import { getPropertyName, getStylesForProperty } from "css-to-react-native";
import { parseElementStyle } from "css-background-parser";
import { parse as parseBoxShadow } from "css-box-shadow";

// src/transform-origin.ts
init_esm_shims();
import valueParser from "postcss-value-parser";
function parseUnit(word, baseFontSize) {
  try {
    const parsed = new U(word);
    switch (parsed.unit) {
      case "px":
        return { absolute: parsed.value };
      case "em":
        return { absolute: parsed.value * baseFontSize };
      case "rem":
        return { absolute: parsed.value * 16 };
      case "%":
        return { relative: parsed.value };
      default:
        return {};
    }
  } catch (e2) {
    return {};
  }
}
function handleWord(word, baseFontSize, unitIsHorizontal) {
  switch (word) {
    case "top":
      return { yRelative: 0 };
    case "left":
      return { xRelative: 0 };
    case "right":
      return { xRelative: 100 };
    case "bottom":
      return { yRelative: 100 };
    case "center":
      return {};
    default:
      const parsedUnit = parseUnit(word, baseFontSize);
      return parsedUnit.absolute ? {
        [unitIsHorizontal ? "xAbsolute" : "yAbsolute"]: parsedUnit.absolute
      } : parsedUnit.relative ? {
        [unitIsHorizontal ? "xRelative" : "yRelative"]: parsedUnit.relative
      } : {};
  }
}
function parseTranformOrigin(value, baseFontSize) {
  if (typeof value === "number") {
    return { xAbsolute: value };
  }
  let words;
  try {
    words = valueParser(value).nodes.filter((node) => node.type === "word").map((node) => node.value);
  } catch (e2) {
    return {};
  }
  if (words.length === 1) {
    return handleWord(words[0], baseFontSize, true);
  } else if (words.length === 2) {
    if (words[0] === "top" || words[0] === "bottom" || words[1] === "left" || words[1] === "right") {
      words.reverse();
    }
    return {
      ...handleWord(words[0], baseFontSize, true),
      ...handleWord(words[1], baseFontSize, false)
    };
  } else {
    return {};
  }
}

// src/handler/expand.ts
var optOutPx = /* @__PURE__ */ new Set([
  "flex",
  "flexGrow",
  "flexShrink",
  "flexBasis",
  "fontWeight",
  "lineHeight",
  "opacity",
  "scale",
  "scaleX",
  "scaleY"
]);
var keepNumber = /* @__PURE__ */ new Set(["lineHeight"]);
function handleFallbackColor(prop, parsed, rawInput, currentColor) {
  if (prop === "textDecoration" && !rawInput.includes(parsed.textDecorationColor)) {
    parsed.textDecorationColor = currentColor;
  }
  return parsed;
}
function purify(name, value) {
  if (typeof value === "number") {
    if (!optOutPx.has(name))
      return value + "px";
    if (keepNumber.has(name))
      return value;
    return String(value);
  }
  return value;
}
function handleSpecialCase(name, value, currentColor) {
  if (name === "lineHeight") {
    return { lineHeight: purify(name, value) };
  }
  if (name === "fontFamily") {
    return {
      fontFamily: value.split(",").map((v2) => {
        return v2.trim().replace(/(^['"])|(['"]$)/g, "").toLocaleLowerCase();
      })
    };
  }
  if (name === "borderRadius") {
    if (typeof value !== "string" || !value.includes("/")) {
      return;
    }
    const [horizontal, vertical] = value.split("/");
    const vh = getStylesForProperty(name, horizontal, true);
    const vv = getStylesForProperty(name, vertical, true);
    for (const k in vh) {
      vv[k] = purify(name, vh[k]) + " " + purify(name, vv[k]);
    }
    return vv;
  }
  if (/^border(Top|Right|Bottom|Left)?$/.test(name)) {
    const resolved = getStylesForProperty("border", value, true);
    if (resolved.borderWidth === 1 && !String(value).includes("1px")) {
      resolved.borderWidth = 3;
    }
    if (resolved.borderColor === "black" && !String(value).includes("black")) {
      resolved.borderColor = currentColor;
    }
    const purified = {
      Width: purify(name + "Width", resolved.borderWidth),
      Style: v(
        resolved.borderStyle,
        {
          solid: "solid",
          dashed: "dashed"
        },
        "solid",
        name + "Style"
      ),
      Color: resolved.borderColor
    };
    const full = {};
    for (const k of name === "border" ? ["Top", "Right", "Bottom", "Left"] : [name.slice(6)]) {
      for (const p2 in purified) {
        full["border" + k + p2] = purified[p2];
      }
    }
    return full;
  }
  if (name === "boxShadow") {
    if (!value) {
      throw new Error('Invalid `boxShadow` value: "' + value + '".');
    }
    return {
      [name]: typeof value === "string" ? parseBoxShadow(value) : value
    };
  }
  if (name === "transform") {
    if (typeof value !== "string")
      throw new Error("Invalid `transform` value.");
    const symbols = {};
    const replaced = value.replace(/(-?[\d.]+%)/g, (_, v2) => {
      const symbol = ~~(Math.random() * 1e9);
      symbols[symbol] = v2;
      return symbol + "px";
    });
    const parsed = getStylesForProperty("transform", replaced, true);
    for (const t of parsed.transform) {
      for (const k in t) {
        if (symbols[t[k]]) {
          t[k] = symbols[t[k]];
        }
      }
    }
    return parsed;
  }
  if (name === "background") {
    value = value.toString().trim();
    if (/^(linear-gradient|radial-gradient|url)\(/.test(value)) {
      return getStylesForProperty("backgroundImage", value, true);
    }
    return getStylesForProperty("background", value, true);
  }
  return;
}
function getErrorHint(name) {
  if (name === "transform") {
    return " Only absolute lengths such as `10px` are supported.";
  }
  return "";
}
var RGB_SLASH = /rgb\((\d+)\s+(\d+)\s+(\d+)\s*\/\s*([\.\d]+)\)/;
function normalizeColor(value) {
  if (typeof value === "string") {
    if (RGB_SLASH.test(value.trim())) {
      return value.trim().replace(RGB_SLASH, (_, r, g, b, a2) => {
        return `rgba(${r}, ${g}, ${b}, ${a2})`;
      });
    }
  }
  if (typeof value === "object" && value !== null) {
    for (const k in value) {
      value[k] = normalizeColor(value[k]);
    }
    return value;
  }
  return value;
}
function expand(style, inheritedStyle) {
  var _a2;
  const transformedStyle = {};
  for (const prop in style) {
    if (prop.startsWith("_")) {
      transformedStyle[prop] = style[prop];
      continue;
    }
    const name = getPropertyName(prop);
    const currentColor = style.color || inheritedStyle.color;
    try {
      const resolvedStyle = handleSpecialCase(name, style[prop], currentColor) || handleFallbackColor(
        name,
        getStylesForProperty(name, purify(name, style[prop]), true),
        style[prop],
        currentColor
      );
      Object.assign(transformedStyle, resolvedStyle);
    } catch (err) {
      throw new Error(
        err.message + (err.message.includes(style[prop]) ? "\n  " + getErrorHint(name) : `
  in CSS rule \`${name}: ${style[prop]}\`.${getErrorHint(
          name
        )}`)
      );
    }
  }
  if (transformedStyle.backgroundImage) {
    const { backgrounds } = parseElementStyle(transformedStyle);
    transformedStyle.backgroundImage = backgrounds;
  }
  let baseFontSize = typeof transformedStyle.fontSize === "number" ? transformedStyle.fontSize : inheritedStyle.fontSize;
  if (typeof baseFontSize === "string") {
    try {
      const parsed = new U(baseFontSize);
      switch (parsed.unit) {
        case "em":
          baseFontSize = parsed.value * inheritedStyle.fontSize;
          break;
        case "rem":
          baseFontSize = parsed.value * 16;
          break;
      }
    } catch (err) {
      baseFontSize = 16;
    }
  }
  if (typeof transformedStyle.fontSize !== "undefined") {
    transformedStyle.fontSize = baseFontSize;
  }
  if (transformedStyle.transformOrigin) {
    transformedStyle.transformOrigin = parseTranformOrigin(
      transformedStyle.transformOrigin,
      baseFontSize
    );
  }
  for (const prop in transformedStyle) {
    let value = transformedStyle[prop];
    if (prop === "lineHeight") {
      if (typeof value === "string") {
        value = transformedStyle[prop] = lengthToNumber(
          value,
          baseFontSize,
          baseFontSize,
          inheritedStyle,
          true
        ) / baseFontSize;
      }
    } else {
      if (typeof value === "string") {
        const len = lengthToNumber(
          value,
          baseFontSize,
          baseFontSize,
          inheritedStyle
        );
        if (typeof len !== "undefined")
          transformedStyle[prop] = len;
        value = transformedStyle[prop];
      }
      if (typeof value === "string" || typeof value === "object") {
        const color2 = normalizeColor(value);
        if (color2)
          transformedStyle[prop] = color2;
        value = transformedStyle[prop];
      }
    }
    if (prop === "opacity") {
      value = transformedStyle[prop] = value * inheritedStyle.opacity;
    }
    if (prop === "transform") {
      const transforms = value;
      for (const transform2 of transforms) {
        const type = Object.keys(transform2)[0];
        const v2 = transform2[type];
        const len = typeof v2 === "string" ? (_a2 = lengthToNumber(v2, baseFontSize, baseFontSize, inheritedStyle)) != null ? _a2 : v2 : v2;
        transform2[type] = len;
      }
    }
  }
  return transformedStyle;
}

// src/handler/image.ts
init_esm_shims();
function parseJPEG(buf) {
  const view = new DataView(buf);
  let offset = 4;
  const len = view.byteLength;
  while (offset < len) {
    const i3 = view.getUint16(offset, false);
    if (i3 > len) {
      throw new TypeError("Invalid JPEG");
    }
    const next = view.getUint8(i3 + 1 + offset);
    if (next === 192 || next === 193 || next === 194) {
      return [
        view.getUint16(i3 + 7 + offset, false),
        view.getUint16(i3 + 5 + offset, false)
      ];
    }
    offset += i3 + 2;
  }
  throw new TypeError("Invalid JPEG");
}
function parseGIF(buf) {
  const view = new Uint8Array(buf.slice(6, 10));
  return [view[0] | view[1] << 8, view[2] | view[3] << 8];
}
function parsePNG(buf) {
  const v2 = new DataView(buf);
  return [v2.getUint16(18, false), v2.getUint16(22, false)];
}
var cache = createLRU(100);
var inflightRequests = /* @__PURE__ */ new Map();
var ALLOWED_IMAGE_TYPES = [
  "image/png",
  "image/jpeg",
  "image/gif",
  "image/svg+xml"
];
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  for (let i3 = 0; i3 < bytes.byteLength; i3++) {
    binary += String.fromCharCode(bytes[i3]);
  }
  return btoa(binary);
}
async function resolveImageData(src) {
  if (!src) {
    throw new Error("Image source is not provided.");
  }
  if (src.startsWith("data:")) {
    return [src];
  }
  if (!globalThis.fetch) {
    throw new Error("`fetch` is required to be polyfilled to load images.");
  }
  if (inflightRequests.has(src)) {
    return inflightRequests.get(src);
  }
  const cached = cache.get(src);
  if (cached) {
    return cached;
  }
  const promise = new Promise((resolve, reject) => {
    fetch(src).then((res) => {
      const type = res.headers.get("content-type");
      if (type === "image/svg+xml" || type === "application/svg+xml") {
        return res.text();
      }
      return res.arrayBuffer();
    }).then((data) => {
      if (typeof data === "string") {
        try {
          const newSrc2 = `data:image/svg+xml;base64,${btoa(data)}`;
          const svgTag = data.match(/<svg[^>]*>/)[0];
          let viewBox = svgTag.match(/viewBox="0 0 (\d+) (\d+)"/);
          const width = svgTag.match(/width="(\d+)"/);
          const height = svgTag.match(/height="(\d+)"/);
          if (!viewBox && width && height) {
            viewBox = [null, width[1], height[1]];
          }
          const ratio = +viewBox[1] / +viewBox[2];
          const imageSize2 = width && height ? [+width[1], +height[1]] : width ? [+width[1], +width[1] / ratio] : height ? [+height[1] * ratio, +height[1]] : [+viewBox[1], +viewBox[2]];
          cache.set(src, [newSrc2, ...imageSize2]);
          resolve([newSrc2, ...imageSize2]);
          return;
        } catch (e2) {
          throw new Error(`Failed to parse SVG image: ${e2.message}`);
        }
      }
      let imageType;
      let imageSize;
      const magicBytes = new Uint8Array(data.slice(0, 4));
      const magicString = [...magicBytes].map((byte) => byte.toString(16)).join("");
      switch (magicString) {
        case "89504e47":
          imageType = "image/png";
          imageSize = parsePNG(data);
          break;
        case "47494638":
          imageType = "image/gif";
          imageSize = parseGIF(data);
          break;
        case "ffd8ffe0":
        case "ffd8ffe1":
        case "ffd8ffe2":
        case "ffd8ffe3":
        case "ffd8ffe8":
        case "ffd8ffed":
        case "ffd8ffdb":
          imageType = "image/jpeg";
          imageSize = parseJPEG(data);
          break;
      }
      if (!ALLOWED_IMAGE_TYPES.includes(imageType)) {
        throw new Error(`Unsupported image type: ${imageType || "unknown"}`);
      }
      const newSrc = `data:${imageType};base64,${arrayBufferToBase64(data)}`;
      cache.set(src, [newSrc, ...imageSize]);
      resolve([newSrc, ...imageSize]);
    }).catch((err) => {
      reject(new Error(`Can't load image ${src}: ` + err.message));
    });
  });
  inflightRequests.set(src, promise);
  return promise;
}

// src/handler/index.ts
async function handler(node, type, inheritedStyle, definedStyle, props) {
  const Yoga2 = getYoga();
  const style = {
    ...inheritedStyle,
    ...expand(presets_default[type], inheritedStyle),
    ...expand(definedStyle, inheritedStyle)
  };
  if (type === "img") {
    let [resolvedSrc, imageWidth, imageHeight] = await resolveImageData(
      props.src
    );
    if (imageWidth === void 0 && imageHeight === void 0) {
      if (props.width === void 0 || props.height === void 0) {
        throw new Error(
          "Image size cannot be determined. Please provide the width and height of the image."
        );
      }
      imageWidth = parseInt(props.width);
      imageHeight = parseInt(props.height);
    }
    const r = imageHeight / imageWidth;
    let extraWidthHorizontal = (style.borderLeftWidth || 0) + (style.borderRightWidth || 0) + (style.paddingLeft || 0) + (style.paddingRight || 0);
    let extraWidthVertical = (style.borderTopWidth || 0) + (style.borderBottomWidth || 0) + (style.paddingTop || 0) + (style.paddingBottom || 0);
    let displayedWidth = style.width || props.width;
    let displayedHeight = style.height || props.height;
    const calculateInsetRatio = typeof displayedWidth !== "string" && typeof displayedHeight !== "string";
    if (displayedWidth !== void 0 && calculateInsetRatio) {
      displayedWidth -= extraWidthHorizontal;
    }
    if (displayedHeight !== void 0 && calculateInsetRatio) {
      displayedHeight -= extraWidthVertical;
    }
    if (displayedWidth === void 0 && displayedHeight === void 0) {
      displayedWidth = imageWidth;
      displayedHeight = imageHeight;
    }
    if (displayedWidth === void 0) {
      node.setAspectRatio(1 / r);
    }
    if (displayedHeight === void 0) {
      node.setAspectRatio(1 / r);
    }
    style.width = calculateInsetRatio ? displayedWidth + extraWidthHorizontal : displayedWidth;
    style.height = calculateInsetRatio ? displayedHeight + extraWidthVertical : displayedHeight;
    style.__src = resolvedSrc;
  }
  if (type === "svg") {
    const viewBox = props.viewBox || props.viewbox;
    const viewBoxSize = viewBox.split(" ").map((v2) => parseInt(v2, 10));
    const ratio = viewBoxSize[3] / viewBoxSize[2];
    let { width, height } = props;
    if (typeof width === "undefined" && height) {
      if (typeof height === "string" && height.endsWith("%")) {
        width = parseInt(height) / ratio + "%";
      } else {
        width = parseInt(height) / ratio;
      }
    } else if (typeof height === "undefined" && width) {
      if (typeof width === "string" && width.endsWith("%")) {
        height = parseInt(width) * ratio + "%";
      } else {
        height = parseInt(width) * ratio;
      }
    } else {
      width || (width = viewBoxSize[2]);
      height || (height = viewBoxSize[3]);
    }
    if (!style.width)
      style.width = width;
    if (!style.height)
      style.height = height;
  }
  node.setDisplay(
    v(
      style.display,
      {
        flex: Yoga2.DISPLAY_FLEX,
        none: Yoga2.DISPLAY_NONE
      },
      Yoga2.DISPLAY_FLEX,
      "display"
    )
  );
  node.setAlignContent(
    v(
      style.alignContent,
      {
        stretch: Yoga2.ALIGN_STRETCH,
        center: Yoga2.ALIGN_CENTER,
        "flex-start": Yoga2.ALIGN_FLEX_START,
        "flex-end": Yoga2.ALIGN_FLEX_END,
        "space-between": Yoga2.ALIGN_SPACE_BETWEEN,
        "space-around": Yoga2.ALIGN_SPACE_AROUND,
        baseline: Yoga2.ALIGN_BASELINE,
        normal: Yoga2.ALIGN_AUTO
      },
      Yoga2.ALIGN_AUTO,
      "alignContent"
    )
  );
  node.setAlignItems(
    v(
      style.alignItems,
      {
        stretch: Yoga2.ALIGN_STRETCH,
        center: Yoga2.ALIGN_CENTER,
        "flex-start": Yoga2.ALIGN_FLEX_START,
        "flex-end": Yoga2.ALIGN_FLEX_END,
        baseline: Yoga2.ALIGN_BASELINE,
        normal: Yoga2.ALIGN_AUTO
      },
      Yoga2.ALIGN_FLEX_START,
      "alignItems"
    )
  );
  node.setAlignSelf(
    v(
      style.alignSelf,
      {
        stretch: Yoga2.ALIGN_STRETCH,
        center: Yoga2.ALIGN_CENTER,
        "flex-start": Yoga2.ALIGN_FLEX_START,
        "flex-end": Yoga2.ALIGN_FLEX_END,
        baseline: Yoga2.ALIGN_BASELINE,
        normal: Yoga2.ALIGN_AUTO
      },
      Yoga2.ALIGN_AUTO,
      "alignSelf"
    )
  );
  node.setJustifyContent(
    v(
      style.justifyContent,
      {
        center: Yoga2.JUSTIFY_CENTER,
        "flex-start": Yoga2.JUSTIFY_FLEX_START,
        "flex-end": Yoga2.JUSTIFY_FLEX_END,
        "space-between": Yoga2.JUSTIFY_SPACE_BETWEEN,
        "space-around": Yoga2.JUSTIFY_SPACE_AROUND
      },
      Yoga2.JUSTIFY_FLEX_START,
      "justifyContent"
    )
  );
  node.setFlexDirection(
    v(
      style.flexDirection,
      {
        row: Yoga2.FLEX_DIRECTION_ROW,
        column: Yoga2.FLEX_DIRECTION_COLUMN,
        "row-reverse": Yoga2.FLEX_DIRECTION_ROW_REVERSE,
        "column-reverse": Yoga2.FLEX_DIRECTION_COLUMN_REVERSE
      },
      Yoga2.FLEX_DIRECTION_ROW,
      "flexDirection"
    )
  );
  node.setFlexWrap(
    v(
      style.flexWrap,
      {
        wrap: Yoga2.WRAP_WRAP,
        nowrap: Yoga2.WRAP_NO_WRAP,
        "wrap-reverse": Yoga2.WRAP_WRAP_REVERSE
      },
      Yoga2.WRAP_NO_WRAP,
      "flexWrap"
    )
  );
  if (typeof style.flexBasis !== "undefined") {
    node.setFlexBasis(style.flexBasis);
  }
  node.setFlexGrow(
    typeof style.flexGrow === "undefined" ? 0 : style.flexGrow
  );
  node.setFlexShrink(
    typeof style.flexShrink === "undefined" ? 0 : style.flexShrink
  );
  if (typeof style.maxHeight !== "undefined") {
    node.setMaxHeight(style.maxHeight);
  }
  if (typeof style.maxWidth !== "undefined") {
    node.setMaxWidth(style.maxWidth);
  }
  if (typeof style.minHeight !== "undefined") {
    node.setMinHeight(style.minHeight);
  }
  if (typeof style.minWidth !== "undefined") {
    node.setMinWidth(style.minWidth);
  }
  node.setOverflow(
    v(
      style.overflow,
      {
        visible: Yoga2.OVERFLOW_VISIBLE,
        hidden: Yoga2.OVERFLOW_HIDDEN
      },
      Yoga2.OVERFLOW_VISIBLE,
      "overflow"
    )
  );
  node.setMargin(Yoga2.EDGE_TOP, style.marginTop || 0);
  node.setMargin(Yoga2.EDGE_BOTTOM, style.marginBottom || 0);
  node.setMargin(Yoga2.EDGE_LEFT, style.marginLeft || 0);
  node.setMargin(Yoga2.EDGE_RIGHT, style.marginRight || 0);
  node.setBorder(Yoga2.EDGE_TOP, style.borderTopWidth || 0);
  node.setBorder(Yoga2.EDGE_BOTTOM, style.borderBottomWidth || 0);
  node.setBorder(Yoga2.EDGE_LEFT, style.borderLeftWidth || 0);
  node.setBorder(Yoga2.EDGE_RIGHT, style.borderRightWidth || 0);
  node.setPadding(Yoga2.EDGE_TOP, style.paddingTop || 0);
  node.setPadding(Yoga2.EDGE_BOTTOM, style.paddingBottom || 0);
  node.setPadding(Yoga2.EDGE_LEFT, style.paddingLeft || 0);
  node.setPadding(Yoga2.EDGE_RIGHT, style.paddingRight || 0);
  node.setPositionType(
    v(
      style.position,
      {
        absolute: Yoga2.POSITION_TYPE_ABSOLUTE,
        relative: Yoga2.POSITION_TYPE_RELATIVE
      },
      Yoga2.POSITION_TYPE_RELATIVE,
      "position"
    )
  );
  if (typeof style.top !== "undefined") {
    node.setPosition(Yoga2.EDGE_TOP, style.top);
  }
  if (typeof style.bottom !== "undefined") {
    node.setPosition(Yoga2.EDGE_BOTTOM, style.bottom);
  }
  if (typeof style.left !== "undefined") {
    node.setPosition(Yoga2.EDGE_LEFT, style.left);
  }
  if (typeof style.right !== "undefined") {
    node.setPosition(Yoga2.EDGE_RIGHT, style.right);
  }
  if (typeof style.height !== "undefined") {
    node.setHeight(style.height);
  } else {
    node.setHeightAuto();
  }
  if (typeof style.width !== "undefined") {
    node.setWidth(style.width);
  } else {
    node.setWidthAuto();
  }
  return [style, inheritable(style)];
}

// src/text.ts
init_esm_shims();

// src/builder/text.ts
init_esm_shims();

// src/builder/transform.ts
init_esm_shims();
var baseMatrix = [1, 0, 0, 1, 0, 0];
function resolveTransforms(transforms, width, height) {
  let matrix = [...baseMatrix];
  for (const transform2 of transforms) {
    const type = Object.keys(transform2)[0];
    let v2 = transform2[type];
    if (typeof v2 === "string") {
      if (type === "translateX") {
        v2 = parseFloat(v2) / 100 * width;
        transform2[type] = v2;
      } else if (type === "translateY") {
        v2 = parseFloat(v2) / 100 * height;
        transform2[type] = v2;
      } else {
        throw new Error(`Invalid transform: "${type}: ${v2}".`);
      }
    }
    let len = v2;
    const transformMatrix = [...baseMatrix];
    switch (type) {
      case "translateX":
        transformMatrix[4] = len;
        break;
      case "translateY":
        transformMatrix[5] = len;
        break;
      case "scale":
        transformMatrix[0] = len;
        transformMatrix[3] = len;
        break;
      case "scaleX":
        transformMatrix[0] = len;
        break;
      case "scaleY":
        transformMatrix[3] = len;
        break;
      case "rotate":
        const rad = len * Math.PI / 180;
        const c2 = Math.cos(rad);
        const s2 = Math.sin(rad);
        transformMatrix[0] = c2;
        transformMatrix[1] = s2;
        transformMatrix[2] = -s2;
        transformMatrix[3] = c2;
        break;
      case "skewX":
        transformMatrix[2] = Math.tan(len * Math.PI / 180);
        break;
      case "skewY":
        transformMatrix[1] = Math.tan(len * Math.PI / 180);
        break;
    }
    matrix = multiply(transformMatrix, matrix);
  }
  transforms.splice(0, transforms.length);
  transforms.push(...matrix);
  transforms.__resolved = true;
}
function transform({
  left,
  top,
  width,
  height
}, transforms, isInheritingTransform, transformOrigin) {
  var _a2, _b, _c, _d;
  let result;
  if (!transforms.__resolved) {
    resolveTransforms(transforms, width, height);
  }
  let matrix = transforms;
  if (isInheritingTransform) {
    result = matrix;
  } else {
    const xOrigin = (_b = transformOrigin == null ? void 0 : transformOrigin.xAbsolute) != null ? _b : ((_a2 = transformOrigin == null ? void 0 : transformOrigin.xRelative) != null ? _a2 : 50) * width / 100;
    const yOrigin = (_d = transformOrigin == null ? void 0 : transformOrigin.yAbsolute) != null ? _d : ((_c = transformOrigin == null ? void 0 : transformOrigin.yRelative) != null ? _c : 50) * height / 100;
    const x2 = left + xOrigin;
    const y = top + yOrigin;
    result = multiply(
      [1, 0, 0, 1, x2, y],
      multiply(matrix, [1, 0, 0, 1, -x2, -y])
    );
    if (matrix.__parent) {
      result = multiply(matrix.__parent, result);
    }
    matrix.splice(0, 6, ...result);
  }
  return `matrix(${result.map((v2) => v2.toFixed(2)).join(",")})`;
}

// src/builder/text.ts
function container({
  left,
  top,
  width,
  height,
  isInheritingTransform
}, style) {
  let matrix = "";
  let opacity2 = 1;
  if (style.transform) {
    matrix = transform(
      {
        left,
        top,
        width,
        height
      },
      style.transform,
      isInheritingTransform,
      style.transformOrigin
    );
  }
  if (style.opacity !== void 0) {
    opacity2 = +style.opacity;
  }
  return { matrix, opacity: opacity2 };
}
function text({
  id,
  content,
  filter,
  left,
  top,
  width,
  height,
  matrix,
  opacity: opacity2,
  image: image2,
  clipPathId,
  debug,
  shape,
  decorationShape
}, style) {
  let extra = "";
  if (debug) {
    extra = buildXMLString("rect", {
      x: left,
      y: top - height,
      width,
      height,
      fill: "transparent",
      stroke: "#575eff",
      "stroke-width": 1,
      transform: matrix || void 0,
      "clip-path": clipPathId ? `url(#${clipPathId})` : void 0
    });
  }
  if (image2) {
    const shapeProps2 = {
      href: image2,
      x: left,
      y: top,
      width,
      height,
      transform: matrix || void 0,
      "clip-path": clipPathId ? `url(#${clipPathId})` : void 0,
      style: style.filter ? `filter:${style.filter}` : void 0
    };
    return [
      (filter ? `${filter}<g filter="url(#satori_s-${id})">` : "") + buildXMLString("image", {
        ...shapeProps2,
        opacity: opacity2 !== 1 ? opacity2 : void 0
      }) + (decorationShape || "") + (filter ? "</g>" : "") + extra,
      ""
    ];
  }
  const shapeProps = {
    x: left,
    y: top,
    width,
    height,
    "font-weight": style.fontWeight,
    "font-style": style.fontStyle,
    "font-size": style.fontSize,
    "font-family": style.fontFamily,
    "letter-spacing": style.letterSpacing || void 0,
    transform: matrix || void 0,
    "clip-path": clipPathId ? `url(#${clipPathId})` : void 0,
    style: style.filter ? `filter:${style.filter}` : void 0
  };
  return [
    (filter ? `${filter}<g filter="url(#satori_s-${id})">` : "") + buildXMLString(
      "text",
      {
        ...shapeProps,
        fill: style.color,
        opacity: opacity2 !== 1 ? opacity2 : void 0
      },
      content
    ) + (decorationShape || "") + (filter ? "</g>" : "") + extra,
    shape ? buildXMLString("text", shapeProps, content) : ""
  ];
}

// src/builder/shadow.ts
init_esm_shims();
function shiftPath(path, dx, dy) {
  return path.replace(
    /([MA])([0-9.-]+),([0-9.-]+)/g,
    function(_, command, x2, y) {
      return command + (parseFloat(x2) + dx) + "," + (parseFloat(y) + dy);
    }
  );
}
function dropShadow({ id, width, height }, style) {
  if (!style.shadowColor || !style.shadowOffset || typeof style.shadowRadius === "undefined") {
    return "";
  }
  const grow = style.shadowRadius * style.shadowRadius / 4;
  const left = Math.min(style.shadowOffset.width - grow, 0);
  const right = Math.max(style.shadowOffset.width + grow + width, width);
  const top = Math.min(style.shadowOffset.height - grow, 0);
  const bottom = Math.max(style.shadowOffset.height + grow + height, height);
  return `<defs><filter id="satori_s-${id}" x="${left / width * 100}%" y="${top / height * 100}%" width="${(right - left) / width * 100}%" height="${(bottom - top) / height * 100}%"><feDropShadow dx="${style.shadowOffset.width}" dy="${style.shadowOffset.height}" stdDeviation="${style.shadowRadius / 2}" flood-color="${style.shadowColor}" flood-opacity="1"/></filter></defs>`;
}
function boxShadow({
  width,
  height,
  shape,
  opacity: opacity2,
  id
}, style) {
  if (!style.boxShadow)
    return null;
  let shadow = "";
  let innerShadow = "";
  for (let i3 = style.boxShadow.length - 1; i3 >= 0; i3--) {
    let s2 = "";
    const shadowStyle = style.boxShadow[i3];
    if (shadowStyle.spreadRadius && shadowStyle.inset) {
      shadowStyle.spreadRadius = -shadowStyle.spreadRadius;
    }
    const grow = shadowStyle.blurRadius * shadowStyle.blurRadius / 4 + (shadowStyle.spreadRadius || 0);
    const left = Math.min(
      -grow - (shadowStyle.inset ? shadowStyle.offsetX : 0),
      0
    );
    const right = Math.max(
      grow + width - (shadowStyle.inset ? shadowStyle.offsetX : 0),
      width
    );
    const top = Math.min(
      -grow - (shadowStyle.inset ? shadowStyle.offsetY : 0),
      0
    );
    const bottom = Math.max(
      grow + height - (shadowStyle.inset ? shadowStyle.offsetY : 0),
      height
    );
    const sid = `satori_s-${id}-${i3}`;
    const maskId = `satori_ms-${id}-${i3}`;
    const shapeWithSpread = shadowStyle.spreadRadius ? shape.replace(
      'stroke-width="0"',
      `stroke-width="${shadowStyle.spreadRadius * 2}"`
    ) : shape;
    s2 += buildXMLString(
      "mask",
      {
        id: maskId,
        maskUnits: "userSpaceOnUse"
      },
      buildXMLString("rect", {
        x: 0,
        y: 0,
        width: style._viewportWidth,
        height: style._viewportHeight,
        fill: shadowStyle.inset ? "#000" : "#fff"
      }) + shapeWithSpread.replace(
        'fill="#fff"',
        shadowStyle.inset ? 'fill="#fff"' : 'fill="#000"'
      ).replace('stroke="#fff"', "")
    );
    let finalShape = shapeWithSpread.replace(/d="([^"]+)"/, (_, path) => {
      return 'd="' + shiftPath(path, shadowStyle.offsetX, shadowStyle.offsetY) + '"';
    }).replace(/x="([^"]+)"/, (_, x2) => {
      return 'x="' + (parseFloat(x2) + shadowStyle.offsetX) + '"';
    }).replace(/y="([^"]+)"/, (_, y) => {
      return 'y="' + (parseFloat(y) + shadowStyle.offsetY) + '"';
    });
    if (shadowStyle.spreadRadius && shadowStyle.spreadRadius < 0) {
      s2 += buildXMLString(
        "mask",
        {
          id: maskId + "-neg",
          maskUnits: "userSpaceOnUse"
        },
        finalShape.replace('stroke="#fff"', 'stroke="#000"').replace(
          /stroke-width="[^"]+"/,
          `stroke-width="${-shadowStyle.spreadRadius * 2}"`
        )
      );
    }
    if (shadowStyle.spreadRadius && shadowStyle.spreadRadius < 0) {
      finalShape = buildXMLString(
        "g",
        {
          mask: `url(#${maskId}-neg)`
        },
        finalShape
      );
    }
    s2 += buildXMLString(
      "defs",
      {},
      buildXMLString(
        "filter",
        {
          id: sid,
          x: `${left / width * 100}%`,
          y: `${top / height * 100}%`,
          width: `${(right - left) / width * 100}%`,
          height: `${(bottom - top) / height * 100}%`
        },
        buildXMLString("feGaussianBlur", {
          stdDeviation: shadowStyle.blurRadius / 2,
          result: "b"
        }) + buildXMLString("feFlood", {
          "flood-color": shadowStyle.color,
          in: "SourceGraphic",
          result: "f"
        }) + buildXMLString("feComposite", {
          in: "f",
          in2: "b",
          operator: shadowStyle.inset ? "out" : "in"
        })
      )
    ) + buildXMLString(
      "g",
      {
        mask: `url(#${maskId})`,
        filter: `url(#${sid})`,
        opacity: opacity2
      },
      finalShape
    );
    if (shadowStyle.inset) {
      innerShadow += s2;
    } else {
      shadow += s2;
    }
  }
  return [shadow, innerShadow];
}

// src/builder/text-decoration.ts
init_esm_shims();
function decoration({
  width,
  left,
  top,
  ascender,
  clipPathId
}, style) {
  const {
    textDecorationColor,
    textDecorationStyle,
    textDecorationLine,
    fontSize: fontSize2
  } = style;
  if (!textDecorationLine || textDecorationLine === "none")
    return "";
  const height = Math.max(1, fontSize2 * 0.1);
  const y = textDecorationLine === "line-through" ? top + ascender * 0.5 : textDecorationLine === "underline" ? top + ascender * 1.1 : top;
  const dasharray = textDecorationStyle === "dashed" ? `${height * 1.2} ${height * 2}` : textDecorationStyle === "dotted" ? `0 ${height * 2}` : void 0;
  return buildXMLString("line", {
    x1: left,
    y1: y,
    x2: left + width,
    y2: y,
    stroke: textDecorationColor,
    "stroke-width": height,
    "stroke-dasharray": dasharray,
    "stroke-linecap": textDecorationStyle === "dotted" ? "round" : "square",
    "clip-path": clipPathId ? `url(#${clipPathId})` : void 0
  });
}

// src/text.ts
var locale2 = void 0;
async function* buildTextNodes(content, context) {
  var _a2;
  const Yoga2 = getYoga();
  const {
    parentStyle,
    inheritedStyle,
    parent,
    font,
    id,
    isInheritingTransform,
    debug,
    embedFont,
    graphemeImages,
    canLoadAdditionalAssets
  } = context;
  if (parentStyle.textTransform === "uppercase") {
    content = content.toLocaleUpperCase(locale2);
  } else if (parentStyle.textTransform === "lowercase") {
    content = content.toLocaleLowerCase(locale2);
  } else if (parentStyle.textTransform === "capitalize") {
    content = segment(content, "word").map((word) => {
      return segment(word, "grapheme").map((grapheme, index) => {
        return index === 0 ? grapheme.toLocaleUpperCase(locale2) : grapheme;
      }).join("");
    }).join("");
  }
  const segmenter = v(
    parentStyle.wordBreak,
    {
      normal: "word",
      "break-all": "grapheme",
      "break-word": "grapheme",
      "keep-all": "word"
    },
    "word",
    "wordBreak"
  );
  const words = segment(content, segmenter);
  const textContainer = Yoga2.Node.create();
  textContainer.setAlignItems(Yoga2.ALIGN_BASELINE);
  textContainer.setJustifyContent(
    v(
      parentStyle.textAlign,
      {
        left: Yoga2.JUSTIFY_FLEX_START,
        right: Yoga2.JUSTIFY_FLEX_END,
        center: Yoga2.JUSTIFY_CENTER,
        justify: Yoga2.JUSTIFY_SPACE_BETWEEN,
        start: Yoga2.JUSTIFY_FLEX_START,
        end: Yoga2.JUSTIFY_FLEX_END
      },
      Yoga2.JUSTIFY_FLEX_START,
      "textAlign"
    )
  );
  parent.insertChild(textContainer, parent.getChildCount());
  const {
    textAlign,
    textOverflow,
    whiteSpace,
    lineHeight: lineHeight2,
    filter: cssFilter,
    _inheritedBackgroundClipTextPath
  } = parentStyle;
  const baseFontSize = parentStyle.fontSize;
  let engine = font.getEngine(
    baseFontSize,
    lineHeight2,
    parentStyle
  );
  const wordsMissingFont = canLoadAdditionalAssets ? words.filter((word) => !engine.has(word)) : [];
  yield wordsMissingFont;
  if (wordsMissingFont.length) {
    engine = font.getEngine(
      baseFontSize,
      lineHeight2,
      parentStyle
    );
  }
  let lineWidths = [];
  let baselines = [];
  let lineSegmentNumber = [];
  let wordsInLayout = [];
  const wordWidthCache = /* @__PURE__ */ new Map();
  const measureWithCache = (segments) => {
    let total = 0;
    for (const s2 of segments) {
      if (wordWidthCache.has(s2)) {
        total += wordWidthCache.get(s2);
        continue;
      }
      const width = engine.measure(s2, parentStyle);
      wordWidthCache.set(s2, width);
      total += width;
    }
    return total;
  };
  let minWidth = 0;
  let remainingSegment = [];
  let extraWidth = 0;
  for (const word of words) {
    let breakSegment = false;
    const isImage = graphemeImages && graphemeImages[word];
    if (whiteSpace === "pre") {
      breakSegment = word[0] === "\n";
    } else if (whiteSpace !== "nowrap") {
      if (isImage || wordSeparators.includes(word[0])) {
        breakSegment = true;
      }
    }
    if (!breakSegment) {
      if (!wordSeparators.includes(word[0]) || !remainingSegment.length) {
        remainingSegment.push(word === "\n" ? " " : word);
      }
    } else {
      if (whiteSpace === "nowrap") {
        extraWidth += measureWithCache(remainingSegment) + parentStyle.fontSize;
      } else {
        minWidth = Math.max(minWidth, measureWithCache(remainingSegment));
        if (isImage) {
          minWidth = Math.max(minWidth, parentStyle.fontSize);
        }
      }
      remainingSegment = [];
    }
  }
  minWidth = Math.max(minWidth, measureWithCache(remainingSegment) + extraWidth);
  const currentMinWidth = parent.getMinWidth();
  const currentMaxWidth = parent.getMaxWidth();
  const currentWidth = parent.getWidth();
  if (isNaN(currentWidth.value) && (isNaN(currentMinWidth.value) || currentMinWidth.unit === 1 && currentMinWidth.value > minWidth)) {
    if (!isNaN(currentMaxWidth.value)) {
      if (currentMaxWidth.unit === 1) {
        minWidth = Math.min(minWidth, currentMaxWidth.value);
      } else {
      }
    }
    parent.setMinWidth(minWidth);
  }
  if (typeof parentStyle.flexShrink === "undefined") {
    parent.setFlexShrink(1);
  }
  const shouldAlwaysBreakLine = whiteSpace === "pre-wrap" || whiteSpace === "pre";
  textContainer.setMeasureFunc((width) => {
    let lines = 0;
    let remainingSpace = "";
    let remainingSpaceWidth = 0;
    let currentWidth2 = 0;
    let maxWidth = 0;
    let lineIndex = -1;
    let height = 0;
    let currentLineHeight = 0;
    let currentBaselineOffset = 0;
    lineWidths = [];
    lineSegmentNumber = [0];
    for (let i3 = 0; i3 < words.length; i3++) {
      const word = words[i3];
      if (!shouldAlwaysBreakLine && wordSeparators.includes(
        word[0]
      )) {
        if (!remainingSpace) {
          remainingSpace = " ";
        }
        remainingSpaceWidth = measureWithCache([remainingSpace]);
        wordsInLayout[i3] = null;
      } else {
        const forceBreak = shouldAlwaysBreakLine && word === "\n";
        const w = forceBreak ? 0 : graphemeImages && graphemeImages[word] ? parentStyle.fontSize : measureWithCache([word]);
        if (!currentWidth2) {
          remainingSpace = "";
          remainingSpaceWidth = 0;
        }
        const allowedToPutAtBeginning = remainingSpaceWidth || ",.!?:-@)>]}%#".indexOf(word[0]) < 0;
        const allowedToJustify = !currentWidth2 || !!remainingSpaceWidth;
        if (forceBreak || i3 && allowedToPutAtBeginning && currentWidth2 + remainingSpaceWidth + w > width && whiteSpace !== "nowrap" && whiteSpace !== "pre") {
          lineWidths.push(currentWidth2);
          baselines.push(currentBaselineOffset);
          lines++;
          height += currentLineHeight;
          currentWidth2 = w;
          currentLineHeight = w ? engine.height(word) : 0;
          currentBaselineOffset = w ? engine.baseline(word) : 0;
          lineSegmentNumber.push(1);
          lineIndex = -1;
          if (!forceBreak) {
            maxWidth = Math.max(maxWidth, width);
          }
        } else {
          currentWidth2 += remainingSpaceWidth + w;
          const glyphHeight = engine.height(word);
          if (glyphHeight > currentLineHeight) {
            currentLineHeight = glyphHeight;
            currentBaselineOffset = engine.baseline(word);
          }
          if (allowedToJustify) {
            lineSegmentNumber[lineSegmentNumber.length - 1]++;
          }
        }
        remainingSpace = "";
        remainingSpaceWidth = 0;
        if (allowedToJustify) {
          lineIndex++;
        }
        maxWidth = Math.max(maxWidth, currentWidth2);
        wordsInLayout[i3] = {
          y: height,
          x: currentWidth2 - w,
          width: w,
          line: lines,
          lineIndex
        };
      }
    }
    if (currentWidth2) {
      lines++;
      lineWidths.push(currentWidth2);
      baselines.push(currentBaselineOffset);
      height += currentLineHeight;
    }
    return { width: maxWidth, height };
  });
  const [x2, y] = yield;
  let result = "";
  let backgroundClipDef = "";
  const clipPathId = inheritedStyle._inheritedClipPathId;
  const overflowMaskId = inheritedStyle._inheritedMaskId;
  const {
    left: containerLeft,
    top: containerTop,
    width: containerWidth,
    height: containerHeight
  } = textContainer.getComputedLayout();
  const parentContainerInnerWidth = parent.getComputedWidth() - parent.getComputedPadding(Yoga2.EDGE_LEFT) - parent.getComputedPadding(Yoga2.EDGE_RIGHT) - parent.getComputedBorder(Yoga2.EDGE_LEFT) - parent.getComputedBorder(Yoga2.EDGE_RIGHT);
  const left = x2 + containerLeft;
  const top = y + containerTop;
  const { matrix, opacity: opacity2 } = container(
    {
      left: containerLeft,
      top: containerTop,
      width: containerWidth,
      height: containerHeight,
      isInheritingTransform
    },
    parentStyle
  );
  let filter = "";
  if (parentStyle.textShadowOffset) {
    filter = dropShadow(
      {
        width: containerWidth,
        height: containerHeight,
        id
      },
      {
        shadowColor: parentStyle.textShadowColor,
        shadowOffset: parentStyle.textShadowOffset,
        shadowRadius: parentStyle.textShadowRadius
      }
    );
  }
  let decorationShape = "";
  let mergedPath = "";
  let extra = "";
  let skippedLine = -1;
  let ellipsisWidth = textOverflow === "ellipsis" ? measureWithCache(["\u2026"]) : 0;
  let spaceWidth = textOverflow === "ellipsis" ? measureWithCache([" "]) : 0;
  let decorationLines = {};
  for (let i3 = 0; i3 < words.length; i3++) {
    if (!wordsInLayout[i3])
      continue;
    const layout2 = wordsInLayout[i3];
    let word = words[i3];
    let path = null;
    const image2 = graphemeImages ? graphemeImages[word] : null;
    let topOffset = layout2.y;
    let leftOffset = layout2.x;
    const width = layout2.width;
    const line = layout2.line;
    if (line === skippedLine) {
      continue;
    }
    let extendedWidth = false;
    if (lineWidths.length > 1) {
      const remainingWidth = containerWidth - lineWidths[line];
      if (textAlign === "right" || textAlign === "end") {
        leftOffset += remainingWidth;
      } else if (textAlign === "center") {
        leftOffset += remainingWidth / 2;
      } else if (textAlign === "justify") {
        if (line < lineWidths.length - 1) {
          const segments = lineSegmentNumber[line];
          const gutter = segments > 1 ? remainingWidth / (segments - 1) : 0;
          leftOffset += gutter * layout2.lineIndex;
          extendedWidth = true;
        }
      }
    }
    if (!decorationLines[line]) {
      decorationLines[line] = [
        leftOffset,
        extendedWidth ? containerWidth : lineWidths[line]
      ];
    }
    if (textOverflow === "ellipsis") {
      if (lineWidths[line] > parentContainerInnerWidth) {
        if (layout2.x + width + ellipsisWidth + spaceWidth > parentContainerInnerWidth) {
          const chars = segment(word, "grapheme");
          let subset = "";
          let resolvedWidth = 0;
          for (const char of chars) {
            const w = layout2.x + measureWithCache([subset + char]);
            if (subset && w + ellipsisWidth > parentContainerInnerWidth) {
              break;
            }
            subset += char;
            resolvedWidth = w;
          }
          word = subset + "\u2026";
          skippedLine = line;
          decorationLines[line][1] = resolvedWidth;
        }
      }
    }
    const baselineOfLine = baselines[line];
    const baselineOfWord = engine.baseline(word);
    const heightOfWord = engine.height(word);
    const baselineDelta = baselineOfLine - baselineOfWord;
    if (image2) {
      topOffset += 0;
    } else if (embedFont) {
      path = engine.getSVG(word, {
        ...parentStyle,
        left: left + leftOffset,
        top: top + topOffset + baselineOfWord + baselineDelta,
        letterSpacing: parentStyle.letterSpacing
      });
      if (debug) {
        extra += buildXMLString("rect", {
          x: left + leftOffset,
          y: top + topOffset + baselineDelta,
          width: layout2.width,
          height: heightOfWord,
          fill: "transparent",
          stroke: "#575eff",
          "stroke-width": 1,
          transform: matrix ? matrix : void 0,
          "clip-path": clipPathId ? `url(#${clipPathId})` : void 0
        }) + buildXMLString("line", {
          x1: left + leftOffset,
          x2: left + leftOffset + layout2.width,
          y1: top + topOffset + baselineDelta + baselineOfWord,
          y2: top + topOffset + baselineDelta + baselineOfWord,
          stroke: "#14c000",
          "stroke-width": 1,
          transform: matrix ? matrix : void 0,
          "clip-path": clipPathId ? `url(#${clipPathId})` : void 0
        });
      }
    } else {
      topOffset += baselineOfWord + baselineDelta;
    }
    if (parentStyle.textDecorationLine) {
      if (line !== ((_a2 = wordsInLayout[i3 + 1]) == null ? void 0 : _a2.line) || skippedLine === line) {
        const deco = decorationLines[line];
        if (deco && !deco[2]) {
          decorationShape += decoration(
            {
              left: left + deco[0],
              top: top + heightOfWord * +line,
              width: deco[1],
              ascender: engine.baseline(word),
              clipPathId
            },
            parentStyle
          );
          deco[2] = 1;
        }
      }
    }
    if (path !== null) {
      mergedPath += path + " ";
    } else {
      const [t, shape] = text(
        {
          content: word,
          filter,
          id,
          left: left + leftOffset,
          top: top + topOffset,
          width,
          height: heightOfWord,
          matrix,
          opacity: opacity2,
          image: image2,
          clipPathId,
          debug,
          shape: !!_inheritedBackgroundClipTextPath,
          decorationShape
        },
        parentStyle
      );
      result += t;
      backgroundClipDef += shape;
      decorationShape = "";
    }
  }
  if (mergedPath) {
    const p2 = parentStyle.color !== "transparent" && opacity2 !== 0 ? buildXMLString("path", {
      fill: parentStyle.color,
      d: mergedPath,
      transform: matrix ? matrix : void 0,
      opacity: opacity2 !== 1 ? opacity2 : void 0,
      "clip-path": clipPathId ? `url(#${clipPathId})` : void 0,
      mask: overflowMaskId ? `url(#${overflowMaskId})` : void 0,
      style: cssFilter ? `filter:${cssFilter}` : void 0
    }) : "";
    if (!!_inheritedBackgroundClipTextPath) {
      backgroundClipDef = buildXMLString("path", {
        d: mergedPath,
        transform: matrix ? matrix : void 0
      });
    }
    result += (filter ? filter + buildXMLString(
      "g",
      { filter: `url(#satori_s-${id})` },
      p2 + decorationShape
    ) : p2 + decorationShape) + extra;
  }
  if (backgroundClipDef) {
    ;
    parentStyle._inheritedBackgroundClipTextPath.value += backgroundClipDef;
  }
  return result;
}

// src/builder/rect.ts
init_esm_shims();

// src/builder/background-image.ts
init_esm_shims();

// src/vendor/gradient-parser/index.js
init_esm_shims();
var GradientParser = GradientParser || {};
var FALLBACK_LINEAR_ORIENTATION = { type: "directional", value: "bottom" };
GradientParser.parse = function() {
  var tokens = {
    linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
    repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
    radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
    repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  var input = "";
  function error(msg) {
    var err = new Error(input + ": " + msg);
    err.source = input;
    throw err;
  }
  function getAST() {
    var ast = matchListDefinitions();
    if (input.length > 0) {
      error("Invalid input not EOF");
    }
    return ast;
  }
  function matchListDefinitions() {
    return matchListing(matchDefinition);
  }
  function matchDefinition() {
    return matchGradient(
      "linear-gradient",
      tokens.linearGradient,
      matchLinearOrientation,
      FALLBACK_LINEAR_ORIENTATION
    ) || matchGradient(
      "repeating-linear-gradient",
      tokens.repeatingLinearGradient,
      matchLinearOrientation,
      FALLBACK_LINEAR_ORIENTATION
    ) || matchGradient(
      "radial-gradient",
      tokens.radialGradient,
      matchListRadialOrientations
    ) || matchGradient(
      "repeating-radial-gradient",
      tokens.repeatingRadialGradient,
      matchListRadialOrientations
    );
  }
  function matchGradient(gradientType, pattern, orientationMatcher, fallbackOrientation) {
    return matchCall(pattern, function(captures) {
      var orientation = orientationMatcher();
      if (orientation) {
        if (!scan(tokens.comma)) {
          error("Missing comma before color stops");
        }
      } else {
        orientation = fallbackOrientation;
      }
      return {
        type: gradientType,
        orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchCall(pattern, callback) {
    var captures = scan(pattern);
    if (captures) {
      if (!scan(tokens.startCall)) {
        error("Missing (");
      }
      var result = callback(captures);
      if (!scan(tokens.endCall)) {
        error("Missing )");
      }
      return result;
    }
  }
  function matchLinearOrientation() {
    return matchSideOrCorner() || matchAngle();
  }
  function matchSideOrCorner() {
    return match("directional", tokens.sideOrCorner, 1);
  }
  function matchAngle() {
    return match("angular", tokens.angleValue, 1);
  }
  function matchListRadialOrientations() {
    var radialOrientations, radialOrientation = matchRadialOrientation(), lookaheadCache;
    if (radialOrientation) {
      radialOrientations = [];
      radialOrientations.push(radialOrientation);
      lookaheadCache = input;
      if (scan(tokens.comma)) {
        radialOrientation = matchRadialOrientation();
        if (radialOrientation) {
          radialOrientations.push(radialOrientation);
        } else {
          input = lookaheadCache;
        }
      }
    }
    return radialOrientations;
  }
  function matchRadialOrientation() {
    var radialType = matchCircle() || matchEllipse();
    if (radialType) {
      radialType.at = matchAtPosition();
    } else {
      var extent = matchExtentKeyword();
      if (extent) {
        radialType = extent;
        var positionAt = matchAtPosition();
        if (positionAt) {
          radialType.at = positionAt;
        }
      } else {
        var defaultPosition = matchPositioning();
        if (defaultPosition) {
          radialType = {
            type: "default-radial",
            at: defaultPosition
          };
        }
      }
    }
    return radialType;
  }
  function matchCircle() {
    var circle = match("shape", /^(circle)/i, 0);
    if (circle) {
      circle.style = matchLength() || matchExtentKeyword();
    }
    return circle;
  }
  function matchEllipse() {
    var ellipse = match("shape", /^(ellipse)/i, 0);
    if (ellipse) {
      ellipse.style = matchDistance() || matchExtentKeyword();
    }
    return ellipse;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      var positioning = matchPositioning();
      if (!positioning) {
        error("Missing positioning value");
      }
      return positioning;
    }
  }
  function matchPositioning() {
    var location = matchCoordinates();
    if (location.x || location.y) {
      return {
        type: "position",
        value: location
      };
    }
  }
  function matchCoordinates() {
    return {
      x: matchDistance(),
      y: matchDistance()
    };
  }
  function matchListing(matcher) {
    var captures = matcher(), result = [];
    if (captures) {
      result.push(captures);
      while (scan(tokens.comma)) {
        captures = matcher();
        if (captures) {
          result.push(captures);
        } else {
          error("One extra comma");
        }
      }
    }
    return result;
  }
  function matchColorStop() {
    var color2 = matchColor();
    if (!color2) {
      error("Expected color definition");
    }
    color2.length = matchDistance();
    return color2;
  }
  function matchColor() {
    return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
  }
  function matchLiteralColor() {
    return match("literal", tokens.literalColor, 0);
  }
  function matchHexColor() {
    return match("hex", tokens.hexColor, 1);
  }
  function matchRGBColor() {
    return matchCall(tokens.rgbColor, function() {
      return {
        type: "rgb",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchRGBAColor() {
    return matchCall(tokens.rgbaColor, function() {
      return {
        type: "rgba",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchNumber() {
    return scan(tokens.number)[1];
  }
  function matchDistance() {
    return match("%", tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();
  }
  function matchPositionKeyword() {
    return match("position-keyword", tokens.positionKeywords, 1);
  }
  function matchLength() {
    return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    var captures = scan(pattern);
    if (captures) {
      return {
        type,
        value: captures[captureIndex]
      };
    }
  }
  function scan(regexp) {
    var captures, blankCaptures;
    blankCaptures = /^[\n\r\t\s]+/.exec(input);
    if (blankCaptures) {
      consume(blankCaptures[0].length);
    }
    captures = regexp.exec(input);
    if (captures) {
      consume(captures[0].length);
    }
    return captures;
  }
  function consume(size) {
    input = input.substr(size);
  }
  return function(code2) {
    input = code2.toString();
    return getAST();
  };
}();
var gradient_parser_default = GradientParser;

// src/builder/background-image.ts
function resolveColorFromStop(stop) {
  if (stop.type === "literal")
    return stop.value;
  if (stop.type === "hex")
    return `#${stop.value}`;
  if (stop.type === "rgb")
    return `rgb(${stop.value.join(",")})`;
  if (stop.type === "rgba")
    return `rgba(${stop.value.join(",")})`;
  return "transparent";
}
function toAbsoluteValue(v2, base) {
  if (typeof v2 === "string" && v2.endsWith("%")) {
    return base * parseFloat(v2) / 100;
  }
  return +v2;
}
function parseLengthPairs(str, {
  x: x2,
  y,
  defaultX,
  defaultY
}) {
  return (str ? str.split(" ").map((value) => {
    try {
      const parsed = new U(value);
      return parsed.type === "length" || parsed.type === "number" ? parsed.value : parsed.value + parsed.unit;
    } catch (e2) {
      return null;
    }
  }).filter((v2) => v2 !== null) : [defaultX, defaultY]).map((v2, index) => toAbsoluteValue(v2, [x2, y][index]));
}
function normalizeStops(totalLength, colorStops) {
  const stops = [];
  for (const stop of colorStops) {
    const color2 = resolveColorFromStop(stop);
    if (!stops.length) {
      stops.push({
        offset: 0,
        color: color2
      });
      if (typeof stop.length === "undefined")
        continue;
      if (stop.length.value === "0")
        continue;
    }
    const offset = typeof stop.length === "undefined" ? void 0 : stop.length.type === "%" ? stop.length.value / 100 : stop.length.value / totalLength;
    stops.push({
      offset,
      color: color2
    });
  }
  if (!stops.length) {
    stops.push({
      offset: 0,
      color: "transparent"
    });
  }
  const lastStop = stops[stops.length - 1];
  if (lastStop.offset !== 1) {
    if (typeof lastStop.offset === "undefined") {
      lastStop.offset = 1;
    } else {
      stops.push({
        offset: 1,
        color: lastStop.color
      });
    }
  }
  let previousStop = 0;
  let nextStop = 1;
  for (let i3 = 0; i3 < stops.length; i3++) {
    if (typeof stops[i3].offset === "undefined") {
      if (nextStop < i3)
        nextStop = i3;
      while (typeof stops[nextStop].offset === "undefined")
        nextStop++;
      stops[i3].offset = (stops[nextStop].offset - stops[previousStop].offset) / (nextStop - previousStop) * (i3 - previousStop) + stops[previousStop].offset;
    } else {
      previousStop = i3;
    }
  }
  return stops;
}
async function backgroundImage({ id, width, height }, { image: image2, size, position, repeat }) {
  repeat = repeat || "repeat";
  const repeatX = repeat === "repeat-x" || repeat === "repeat";
  const repeatY = repeat === "repeat-y" || repeat === "repeat";
  const dimensions = parseLengthPairs(size, {
    x: width,
    y: height,
    defaultX: width,
    defaultY: height
  });
  const offsets = parseLengthPairs(position, {
    x: width,
    y: height,
    defaultX: 0,
    defaultY: 0
  });
  if (image2.startsWith("linear-gradient(")) {
    const parsed = gradient_parser_default.parse(image2)[0];
    const [xDelta, yDelta] = dimensions;
    let x1, y1, x2, y2;
    if (parsed.orientation.type === "directional") {
      ;
      [x1, y1, x2, y2] = {
        top: [0, 1, 0, 0],
        bottom: [0, 0, 0, 1],
        left: [1, 0, 0, 0],
        right: [0, 0, 1, 0]
      }[parsed.orientation.value];
    } else if (parsed.orientation.type === "angular") {
      const angle = +parsed.orientation.value / 180 * Math.PI - Math.PI / 2;
      const c2 = Math.cos(angle);
      const s2 = Math.sin(angle);
      x1 = 0;
      y1 = 0;
      x2 = c2;
      y2 = s2;
      if (x2 < 0) {
        x1 -= x2;
        x2 = 0;
      }
      if (y2 < 0) {
        y1 -= y2;
        y2 = 0;
      }
    }
    const stops = normalizeStops(width, parsed.colorStops);
    const gradientId = `satori_bi${id}`;
    const patternId = `satori_pattern_${id}`;
    const defs = buildXMLString(
      "pattern",
      {
        id: patternId,
        x: offsets[0] / width,
        y: offsets[1] / height,
        width: repeatX ? xDelta / width : "1",
        height: repeatY ? yDelta / height : "1",
        patternUnits: "objectBoundingBox"
      },
      buildXMLString(
        "linearGradient",
        {
          id: gradientId,
          x1,
          y1,
          x2,
          y2
        },
        stops.map(
          (stop) => buildXMLString("stop", {
            offset: stop.offset * 100 + "%",
            "stop-color": stop.color
          })
        ).join("")
      ) + buildXMLString("rect", {
        x: 0,
        y: 0,
        width: xDelta,
        height: yDelta,
        fill: `url(#${gradientId})`
      })
    );
    return [patternId, defs];
  }
  if (image2.startsWith("radial-gradient(")) {
    const parsed = gradient_parser_default.parse(image2)[0];
    const orientation = parsed.orientation[0];
    const [xDelta, yDelta] = dimensions;
    let shape = "circle";
    let cx = xDelta / 2;
    let cy = yDelta / 2;
    if (orientation.type === "shape") {
      shape = orientation.value;
      if (!orientation.at) {
      } else if (orientation.at.type === "position") {
        cx = orientation.at.value.x.value;
        cy = orientation.at.value.y.value;
      } else {
        throw new Error(
          "orientation.at.type not implemented: " + orientation.at.type
        );
      }
    } else {
      throw new Error("orientation.type not implemented: " + orientation.type);
    }
    const stops = normalizeStops(width, parsed.colorStops);
    const gradientId = `satori_radial_${id}`;
    const patternId = `satori_pattern_${id}`;
    const maskId = `satori_mask_${id}`;
    const spread = {};
    const fx = Math.max(Math.abs(xDelta - cx), Math.abs(cx));
    const fy = Math.max(Math.abs(yDelta - cy), Math.abs(cy));
    if (shape === "circle") {
      spread.r = Math.sqrt(fx * fx + fy * fy);
    } else if (shape === "ellipse") {
      const ratio = fy !== 0 ? fx / fy : 1;
      spread.ry = Math.sqrt(fx * fx + fy * fy * ratio * ratio) / ratio;
      spread.rx = spread.ry * ratio;
    }
    const defs = buildXMLString(
      "pattern",
      {
        id: patternId,
        x: offsets[0] / width,
        y: offsets[1] / height,
        width: repeatX ? xDelta / width : "1",
        height: repeatY ? yDelta / height : "1",
        patternUnits: "objectBoundingBox"
      },
      buildXMLString(
        "radialGradient",
        {
          id: gradientId
        },
        stops.map(
          (stop) => buildXMLString("stop", {
            offset: stop.offset,
            "stop-color": stop.color
          })
        ).join("")
      ) + buildXMLString(
        "mask",
        {
          id: maskId
        },
        buildXMLString("rect", {
          x: 0,
          y: 0,
          width: xDelta,
          height: yDelta,
          fill: "#fff"
        })
      ) + buildXMLString(shape, {
        cx,
        cy,
        width: xDelta,
        height: yDelta,
        ...spread,
        fill: `url(#${gradientId})`,
        mask: `url(#${maskId})`
      })
    );
    const result = [patternId, defs];
    return result;
  }
  if (image2.startsWith("url(")) {
    const dimensionsWithoutFallback = parseLengthPairs(size, {
      x: width,
      y: height,
      defaultX: 0,
      defaultY: 0
    });
    const [src, imageWidth, imageHeight] = await resolveImageData(
      image2.slice(4, -1)
    );
    const resolvedWidth = dimensionsWithoutFallback[0] || imageWidth;
    const resolvedHeight = dimensionsWithoutFallback[1] || imageHeight;
    return [
      `satori_bi${id}`,
      buildXMLString(
        "pattern",
        {
          id: `satori_bi${id}`,
          patternContentUnits: "userSpaceOnUse",
          patternUnits: "userSpaceOnUse",
          x: offsets[0],
          y: offsets[1],
          width: repeatX ? resolvedWidth : "100%",
          height: repeatY ? resolvedHeight : "100%"
        },
        buildXMLString("image", {
          x: 0,
          y: 0,
          width: resolvedWidth,
          height: resolvedHeight,
          preserveAspectRatio: "none",
          href: src
        })
      )
    ];
  }
  throw new Error(`Invalid background image: "${image2}"`);
}

// src/builder/border-radius.ts
init_esm_shims();
function svgArcCenterOffset([rx, ry]) {
  if (Math.round(rx * 1e3) === 0 && Math.round(ry * 1e3) === 0) {
    return 0;
  }
  return Math.round(rx * ry / Math.sqrt(rx * rx + ry * ry) * 1e3) / 1e3;
}
function resolveSize(a2, b, limit) {
  if (limit < a2 + b) {
    if (limit / 2 < a2 && limit / 2 < b) {
      a2 = b = limit / 2;
    } else if (limit / 2 < a2) {
      a2 = limit - b;
    } else if (limit / 2 < b) {
      b = limit - a2;
    }
  }
  return [a2, b];
}
function makeSmaller(arr) {
  arr[0] = arr[1] = Math.min(arr[0], arr[1]);
}
function resolveRadius(v2, width, height, fontSize2, style) {
  if (typeof v2 === "string") {
    const sides = v2.split(" ").map((s2) => s2.trim());
    const singleValue = !sides[1] && !sides[0].endsWith("%");
    sides[1] = sides[1] || sides[0];
    return [
      singleValue,
      [
        Math.min(lengthToNumber(sides[0], fontSize2, width, style, true), width),
        Math.min(
          lengthToNumber(sides[1], fontSize2, height, style, true),
          height
        )
      ]
    ];
  }
  if (typeof v2 === "number") {
    return [true, [Math.min(v2, width), Math.min(v2, height)]];
  }
  return [true, void 0];
}
function radius({
  left,
  top,
  width,
  height
}, style, partialSides) {
  let {
    borderTopLeftRadius,
    borderTopRightRadius,
    borderBottomLeftRadius,
    borderBottomRightRadius,
    fontSize: fontSize2
  } = style;
  let singleAbsValueTopLeftCorner;
  let singleAbsValueTopRightCorner;
  let singleAbsValueBottomLeftCorner;
  let singleAbsValueBottomRightCorner;
  [singleAbsValueTopLeftCorner, borderTopLeftRadius] = resolveRadius(
    borderTopLeftRadius,
    width,
    height,
    fontSize2,
    style
  );
  [singleAbsValueTopRightCorner, borderTopRightRadius] = resolveRadius(
    borderTopRightRadius,
    width,
    height,
    fontSize2,
    style
  );
  [singleAbsValueBottomLeftCorner, borderBottomLeftRadius] = resolveRadius(
    borderBottomLeftRadius,
    width,
    height,
    fontSize2,
    style
  );
  [singleAbsValueBottomRightCorner, borderBottomRightRadius] = resolveRadius(
    borderBottomRightRadius,
    width,
    height,
    fontSize2,
    style
  );
  if (!partialSides && !borderTopLeftRadius && !borderTopRightRadius && !borderBottomLeftRadius && !borderBottomRightRadius) {
    return "";
  }
  borderTopLeftRadius || (borderTopLeftRadius = [0, 0]);
  borderTopRightRadius || (borderTopRightRadius = [0, 0]);
  borderBottomLeftRadius || (borderBottomLeftRadius = [0, 0]);
  borderBottomRightRadius || (borderBottomRightRadius = [0, 0]);
  [borderTopLeftRadius[0], borderTopRightRadius[0]] = resolveSize(
    borderTopLeftRadius[0],
    borderTopRightRadius[0],
    width
  );
  [borderBottomLeftRadius[0], borderBottomRightRadius[0]] = resolveSize(
    borderBottomLeftRadius[0],
    borderBottomRightRadius[0],
    width
  );
  [borderTopLeftRadius[1], borderBottomLeftRadius[1]] = resolveSize(
    borderTopLeftRadius[1],
    borderBottomLeftRadius[1],
    height
  );
  [borderTopRightRadius[1], borderBottomRightRadius[1]] = resolveSize(
    borderTopRightRadius[1],
    borderBottomRightRadius[1],
    height
  );
  if (singleAbsValueTopLeftCorner) {
    makeSmaller(borderTopLeftRadius);
  }
  if (singleAbsValueTopRightCorner) {
    makeSmaller(borderTopRightRadius);
  }
  if (singleAbsValueBottomLeftCorner) {
    makeSmaller(borderBottomLeftRadius);
  }
  if (singleAbsValueBottomRightCorner) {
    makeSmaller(borderBottomRightRadius);
  }
  const p2 = [];
  p2[0] = [borderTopRightRadius, borderTopRightRadius];
  p2[1] = [
    borderBottomRightRadius,
    [-borderBottomRightRadius[0], borderBottomRightRadius[1]]
  ];
  p2[2] = [
    borderBottomLeftRadius,
    [-borderBottomLeftRadius[0], -borderBottomLeftRadius[1]]
  ];
  p2[3] = [
    borderTopLeftRadius,
    [borderTopLeftRadius[0], -borderTopLeftRadius[1]]
  ];
  const T = `h${width - borderTopLeftRadius[0] - borderTopRightRadius[0]} a${p2[0][0]} 0 0 1 ${p2[0][1]}`;
  const R = `v${height - borderTopRightRadius[1] - borderBottomRightRadius[1]} a${p2[1][0]} 0 0 1 ${p2[1][1]}`;
  const B = `h${borderBottomRightRadius[0] + borderBottomLeftRadius[0] - width} a${p2[2][0]} 0 0 1 ${p2[2][1]}`;
  const L = `v${borderBottomLeftRadius[1] + borderTopLeftRadius[1] - height} a${p2[3][0]} 0 0 1 ${p2[3][1]}`;
  if (partialSides) {
    let getArc = function(i3) {
      const c0 = svgArcCenterOffset(
        [
          borderTopLeftRadius,
          borderTopRightRadius,
          borderBottomRightRadius,
          borderBottomLeftRadius
        ][i3]
      );
      return i3 === 0 ? [
        [
          left + borderTopLeftRadius[0] - c0,
          top + borderTopLeftRadius[1] - c0
        ],
        [left + borderTopLeftRadius[0], top]
      ] : i3 === 1 ? [
        [
          left + width - borderTopRightRadius[0] + c0,
          top + borderTopRightRadius[1] - c0
        ],
        [left + width, top + borderTopRightRadius[1]]
      ] : i3 === 2 ? [
        [
          left + width - borderBottomRightRadius[0] + c0,
          top + height - borderBottomRightRadius[1] + c0
        ],
        [left + width - borderBottomRightRadius[0], top + height]
      ] : [
        [
          left + borderBottomLeftRadius[0] - c0,
          top + height - borderBottomLeftRadius[1] + c0
        ],
        [left, top + height - borderBottomLeftRadius[1]]
      ];
    };
    let start = partialSides.indexOf(false);
    if (!partialSides.includes(true))
      throw new Error("Invalid `partialSides`.");
    if (start === -1) {
      start = 0;
    } else {
      while (!partialSides[start]) {
        start = (start + 1) % 4;
      }
    }
    let result = "";
    const arc0 = getArc(start);
    let l2 = `M${arc0[0]} A${p2[(start + 3) % 4][0]} 0 0 1 ${arc0[1]}`;
    let len = 0;
    for (; len < 4 && partialSides[(start + len) % 4]; len++) {
      result += l2 + " ";
      l2 = [T, R, B, L][(start + len) % 4];
    }
    const end = (start + len) % 4;
    result += l2.split(" ")[0];
    const arc1 = getArc(end);
    result += ` A${p2[(end + 3) % 4][0]} 0 0 1 ${arc1[0]}`;
    return result;
  }
  return `M${left + borderTopLeftRadius[0]},${top} ${T} ${R} ${B} ${L}`;
}

// src/builder/overflow.ts
init_esm_shims();

// src/builder/content-mask.ts
init_esm_shims();

// src/builder/border.ts
init_esm_shims();
function compareBorderDirections(a2, b, style) {
  return style[a2 + "Width"] === style[b + "Width"] && style[a2 + "Style"] === style[b + "Style"] && style[a2 + "Color"] === style[b + "Color"];
}
function getBorderClipPath({
  id,
  currentClipPathId,
  borderPath,
  borderType,
  left,
  top,
  width,
  height
}, style) {
  const hasBorder = style.borderTopWidth || style.borderRightWidth || style.borderBottomWidth || style.borderLeftWidth;
  if (!hasBorder)
    return null;
  const rectClipId = `satori_bc-${id}`;
  const defs = buildXMLString(
    "clipPath",
    {
      id: rectClipId,
      "clip-path": currentClipPathId ? `url(#${currentClipPathId})` : void 0
    },
    buildXMLString(borderType, {
      x: left,
      y: top,
      width,
      height,
      d: borderPath ? borderPath : void 0
    })
  );
  return [defs, rectClipId];
}
function border({
  left,
  top,
  width,
  height,
  props,
  asContentMask,
  maskBorderOnly
}, style) {
  const directions = ["borderTop", "borderRight", "borderBottom", "borderLeft"];
  if (!asContentMask && !directions.some((direction) => style[direction + "Width"]))
    return "";
  let fullBorder = "";
  let start = 0;
  while (start > 0 && compareBorderDirections(
    directions[start],
    directions[(start + 3) % 4],
    style
  )) {
    start = (start + 3) % 4;
  }
  let partialSides = [false, false, false, false];
  let currentStyle = [];
  for (let _i = 0; _i < 4; _i++) {
    const i3 = (start + _i) % 4;
    const ni = (start + _i + 1) % 4;
    const d2 = directions[i3];
    const nd = directions[ni];
    partialSides[i3] = true;
    currentStyle = [
      style[d2 + "Width"],
      style[d2 + "Style"],
      style[d2 + "Color"],
      d2
    ];
    if (!compareBorderDirections(d2, nd, style)) {
      const w = (currentStyle[0] || 0) + (asContentMask && !maskBorderOnly ? style[d2.replace("border", "padding")] || 0 : 0);
      if (w) {
        fullBorder += buildXMLString("path", {
          width,
          height,
          ...props,
          fill: "none",
          stroke: asContentMask ? "#000" : currentStyle[2],
          "stroke-width": w * 2,
          "stroke-dasharray": !asContentMask && currentStyle[1] === "dashed" ? w * 2 + " " + w : void 0,
          d: radius(
            { left, top, width, height },
            style,
            partialSides
          )
        });
      }
      partialSides = [false, false, false, false];
    }
  }
  if (partialSides.some(Boolean)) {
    const w = (currentStyle[0] || 0) + (asContentMask && !maskBorderOnly ? style[currentStyle[3].replace("border", "padding")] || 0 : 0);
    if (w) {
      fullBorder += buildXMLString("path", {
        width,
        height,
        ...props,
        fill: "none",
        stroke: asContentMask ? "#000" : currentStyle[2],
        "stroke-width": w * 2,
        "stroke-dasharray": !asContentMask && currentStyle[1] === "dashed" ? w * 2 + " " + w : void 0,
        d: radius(
          { left, top, width, height },
          style,
          partialSides
        )
      });
    }
  }
  return fullBorder;
}

// src/builder/content-mask.ts
function contentMask({
  id,
  left,
  top,
  width,
  height,
  matrix,
  borderOnly
}, style) {
  const offsetLeft = (style.borderLeftWidth || 0) + (borderOnly ? 0 : style.paddingLeft || 0);
  const offsetTop = (style.borderTopWidth || 0) + (borderOnly ? 0 : style.paddingTop || 0);
  const offsetRight = (style.borderRightWidth || 0) + (borderOnly ? 0 : style.paddingRight || 0);
  const offsetBottom = (style.borderBottomWidth || 0) + (borderOnly ? 0 : style.paddingBottom || 0);
  const contentArea = {
    x: left + offsetLeft,
    y: top + offsetTop,
    width: width - offsetLeft - offsetRight,
    height: height - offsetTop - offsetBottom
  };
  const contentMask2 = buildXMLString(
    "mask",
    { id },
    buildXMLString("rect", {
      ...contentArea,
      fill: "#fff",
      mask: style._inheritedMaskId ? `url(#${style._inheritedMaskId})` : void 0
    }) + border(
      {
        left,
        top,
        width,
        height,
        props: {
          transform: matrix ? matrix : void 0
        },
        asContentMask: true,
        maskBorderOnly: borderOnly
      },
      style
    )
  );
  return contentMask2;
}

// src/builder/overflow.ts
function overflow({
  left,
  top,
  width,
  height,
  path,
  matrix,
  id
}, style) {
  if (style.overflow !== "hidden") {
    return "";
  }
  const contentMask2 = contentMask(
    {
      id: `satori_om-${id}`,
      left,
      top,
      width,
      height,
      matrix,
      borderOnly: true
    },
    style
  );
  return buildXMLString(
    "clipPath",
    {
      id: `satori_cp-${id}`,
      "clip-path": style._inheritedClipPathId ? `url(#${style._inheritedClipPathId})` : void 0
    },
    buildXMLString(path ? "path" : "rect", {
      x: left,
      y: top,
      width,
      height,
      d: path ? path : void 0
    })
  ) + contentMask2;
}

// src/builder/rect.ts
async function rect({
  id,
  left,
  top,
  width,
  height,
  isInheritingTransform,
  debug
}, style) {
  if (style.display === "none")
    return "";
  let type = "rect";
  let matrix = "";
  let defs = "";
  let fills = [];
  let opacity2 = 1;
  let extra = "";
  if (style.backgroundColor) {
    fills.push(style.backgroundColor);
  }
  if (style.opacity !== void 0) {
    opacity2 = +style.opacity;
  }
  if (style.transform) {
    matrix = transform(
      {
        left,
        top,
        width,
        height
      },
      style.transform,
      isInheritingTransform,
      style.transformOrigin
    );
  }
  let backgroundShapes = "";
  if (style.backgroundImage) {
    const backgrounds = [];
    for (let index = 0; index < style.backgroundImage.length; index++) {
      const background = style.backgroundImage[index];
      const image2 = await backgroundImage(
        { id: id + "_" + index, width, height },
        background
      );
      if (image2) {
        backgrounds.unshift(image2);
      }
    }
    for (const background of backgrounds) {
      fills.push(`url(#${background[0]})`);
      defs += background[1];
      if (background[2]) {
        backgroundShapes += background[2];
      }
    }
  }
  const path = radius(
    { left, top, width, height },
    style
  );
  if (path) {
    type = "path";
  }
  const clip = overflow(
    { left, top, width, height, path, id, matrix },
    style
  );
  const clipPathId = style._inheritedClipPathId;
  const overflowMaskId = style._inheritedMaskId;
  if (debug) {
    extra = buildXMLString("rect", {
      x: left,
      y: top,
      width,
      height,
      fill: "transparent",
      stroke: "#ff5757",
      "stroke-width": 1,
      transform: matrix || void 0,
      "clip-path": clipPathId ? `url(#${clipPathId})` : void 0
    });
  }
  const { backgroundClip, filter: cssFilter } = style;
  const currentClipPath = backgroundClip === "text" ? `url(#satori_bct-${id})` : clipPathId ? `url(#${clipPathId})` : void 0;
  let shape = fills.map(
    (fill) => buildXMLString(type, {
      x: left,
      y: top,
      width,
      height,
      fill,
      d: path ? path : void 0,
      transform: matrix ? matrix : void 0,
      "clip-path": currentClipPath,
      style: cssFilter ? `filter:${cssFilter}` : void 0,
      mask: overflowMaskId ? `url(#${overflowMaskId})` : void 0
    })
  ).join("");
  const borderClip = getBorderClipPath(
    {
      id,
      left,
      top,
      width,
      height,
      currentClipPathId: clipPathId,
      borderPath: path,
      borderType: type
    },
    style
  );
  if (borderClip) {
    defs += borderClip[0];
    const rectClipId = borderClip[1];
    shape += border(
      {
        left,
        top,
        width,
        height,
        props: {
          transform: matrix ? matrix : void 0,
          "clip-path": `url(#${rectClipId})`
        }
      },
      style
    );
  }
  const shadow = boxShadow(
    {
      width,
      height,
      id,
      opacity: opacity2,
      shape: buildXMLString(type, {
        x: left,
        y: top,
        width,
        height,
        fill: "#fff",
        stroke: "#fff",
        "stroke-width": 0,
        d: path ? path : void 0,
        transform: matrix ? matrix : void 0,
        "clip-path": currentClipPath,
        mask: overflowMaskId ? `url(#${overflowMaskId})` : void 0
      })
    },
    style
  );
  return (defs ? buildXMLString("defs", {}, defs) : "") + (shadow ? shadow[0] : "") + clip + (opacity2 !== 1 ? `<g opacity="${opacity2}">` : "") + (backgroundShapes || shape) + (opacity2 !== 1 ? `</g>` : "") + (shadow ? shadow[1] : "") + extra;
}

// src/builder/image.ts
init_esm_shims();
function image({
  id,
  left,
  top,
  width,
  height,
  src,
  debug: _debug,
  isInheritingTransform
}, style) {
  if (style.display === "none")
    return "";
  let contentMaskId = "";
  let contentMask2 = "";
  let clip = "";
  let opacity2 = 1;
  let matrix = "";
  let defs = "";
  let borderShape = "";
  if (style.transform) {
    matrix = transform(
      {
        left,
        top,
        width,
        height
      },
      style.transform,
      isInheritingTransform,
      style.transformOrigin
    );
  }
  const preserveAspectRatio = style.objectFit === "contain" ? "xMidYMid" : style.objectFit === "cover" ? "xMidYMid slice" : "none";
  const path = radius(
    { left, top, width, height },
    style
  );
  const clipPathId = style._inheritedClipPathId;
  const overflowMaskId = style._inheritedMaskId;
  if (path) {
    clip = buildXMLString(
      "clipPath",
      {
        id: `satori_c-${id}`,
        "clip-path": clipPathId ? `url(#${clipPathId})` : void 0
      },
      buildXMLString("path", {
        x: left,
        y: top,
        width,
        height,
        d: path
      })
    );
  }
  const borderClip = getBorderClipPath(
    {
      id,
      left,
      top,
      width,
      height,
      currentClipPathId: clipPathId,
      borderPath: path,
      borderType: path ? "path" : "rect"
    },
    style
  );
  if (borderClip) {
    defs += borderClip[0];
    const rectClipId = borderClip[1];
    borderShape += border(
      {
        left,
        top,
        width,
        height,
        props: {
          transform: matrix ? matrix : void 0,
          "clip-path": `url(#${rectClipId})`,
          mask: overflowMaskId ? `url(#${overflowMaskId})` : void 0
        }
      },
      style
    );
  }
  if (style.opacity) {
    opacity2 = +style.opacity;
  }
  const shadow = boxShadow(
    {
      width,
      height,
      id,
      opacity: opacity2,
      shape: buildXMLString(path ? "path" : "rect", {
        x: left,
        y: top,
        width,
        height,
        fill: "#fff",
        d: path ? path : void 0,
        transform: matrix ? matrix : void 0,
        "clip-path": clipPathId ? `url(#${clipPathId})` : void 0,
        mask: overflowMaskId ? `url(#${overflowMaskId})` : void 0
      })
    },
    style
  );
  if (path) {
    contentMaskId = `satori_cm-${id}`;
    contentMask2 = contentMask(
      {
        id: `satori_cm-${id}`,
        left,
        top,
        width,
        height,
        matrix
      },
      style
    );
  }
  const offsetLeft = (style.borderLeftWidth || 0) + (style.paddingLeft || 0);
  const offsetTop = (style.borderTopWidth || 0) + (style.paddingTop || 0);
  const offsetRight = (style.borderRightWidth || 0) + (style.paddingRight || 0);
  const offsetBottom = (style.borderBottomWidth || 0) + (style.paddingBottom || 0);
  return (defs ? buildXMLString("defs", {}, defs) : "") + contentMask2 + (shadow ? shadow[0] : "") + clip + buildXMLString("image", {
    x: left + offsetLeft,
    y: top + offsetTop,
    width: width - offsetLeft - offsetRight,
    height: height - offsetTop - offsetBottom,
    href: src,
    preserveAspectRatio,
    opacity: opacity2,
    transform: matrix ? matrix : void 0,
    "clip-path": clip ? `url(#satori_c-${id})` : clipPathId ? `url(#${clipPathId})` : void 0,
    mask: contentMaskId ? `url(#${contentMaskId})` : void 0
  }) + (shadow ? shadow[1] : "") + borderShape;
}

// src/layout.ts
async function* layout(element, context) {
  const Yoga2 = getYoga();
  const {
    id,
    inheritedStyle,
    parent,
    font,
    debug,
    embedFont = true,
    graphemeImages,
    canLoadAdditionalAssets,
    getTwStyles
  } = context;
  if (element === null || typeof element === "undefined") {
    yield;
    yield;
    return "";
  }
  if (!isReactElement(element) || typeof element.type === "function") {
    let iter;
    if (!isReactElement(element)) {
      iter = buildTextNodes(String(element), context);
      yield (await iter.next()).value;
    } else {
      if (isClass(element.type)) {
        throw new Error("Class component is not supported.");
      }
      iter = layout(element.type(element.props), context);
      yield (await iter.next()).value;
    }
    await iter.next();
    const offset = yield;
    return (await iter.next(offset)).value;
  }
  const { type, props } = element;
  let { style, children, tw: tw2 } = props || {};
  if (tw2) {
    const twStyles = getTwStyles(tw2, style);
    style = Object.assign(twStyles, style);
  }
  const node = Yoga2.Node.create();
  parent.insertChild(node, parent.getChildCount());
  const [computedStyle, newInheritableStyle] = await handler(
    node,
    type,
    inheritedStyle,
    style,
    props
  );
  const isInheritingTransform = computedStyle.transform === inheritedStyle.transform;
  if (!isInheritingTransform) {
    ;
    computedStyle.transform.__parent = inheritedStyle.transform;
  }
  if (computedStyle.overflow === "hidden") {
    newInheritableStyle._inheritedClipPathId = `satori_cp-${id}`;
    newInheritableStyle._inheritedMaskId = `satori_om-${id}`;
  }
  if (computedStyle.backgroundClip === "text") {
    const mutateRefValue = { value: "" };
    newInheritableStyle._inheritedBackgroundClipTextPath = mutateRefValue;
    computedStyle._inheritedBackgroundClipTextPath = mutateRefValue;
  }
  const normalizedChildren = normalizeChildren(children);
  const iterators = [];
  let i3 = 0;
  const segmentsMissingFont = [];
  for (const child of normalizedChildren) {
    const iter = layout(child, {
      id: id + "-" + i3++,
      parentStyle: computedStyle,
      inheritedStyle: newInheritableStyle,
      isInheritingTransform: true,
      parent: node,
      font,
      embedFont,
      debug,
      graphemeImages,
      canLoadAdditionalAssets,
      getTwStyles
    });
    if (canLoadAdditionalAssets) {
      segmentsMissingFont.push(...(await iter.next()).value || []);
    } else {
      await iter.next();
    }
    iterators.push(iter);
  }
  yield segmentsMissingFont;
  for (const iter of iterators)
    await iter.next();
  const [x2, y] = yield;
  let { left, top, width, height } = node.getComputedLayout();
  left += x2;
  top += y;
  let childrenRenderResult = "";
  let baseRenderResult = "";
  let depsRenderResult = "";
  if (type === "img") {
    const src = computedStyle.__src;
    baseRenderResult = image(
      {
        id,
        left,
        top,
        width,
        height,
        src,
        isInheritingTransform,
        debug
      },
      computedStyle
    );
  } else if (type === "svg") {
    const src = SVGNodeToImage(element);
    baseRenderResult = image(
      {
        id,
        left,
        top,
        width,
        height,
        src,
        isInheritingTransform,
        debug
      },
      computedStyle
    );
  } else {
    const display = style == null ? void 0 : style.display;
    if (type === "div" && children && typeof children !== "string" && display !== "flex" && display !== "none") {
      throw new Error(
        `Expected <div> to have explicit "display: flex" or "display: none" if it has more than one child node.`
      );
    }
    baseRenderResult = await rect(
      { id, left, top, width, height, isInheritingTransform, debug },
      computedStyle
    );
  }
  for (const iter of iterators) {
    childrenRenderResult += (await iter.next([left, top])).value;
  }
  if (computedStyle._inheritedBackgroundClipTextPath) {
    depsRenderResult += buildXMLString(
      "clipPath",
      {
        id: `satori_bct-${id}`,
        "clip-path": computedStyle._inheritedClipPathId ? `url(#${computedStyle._inheritedClipPathId})` : void 0
      },
      computedStyle._inheritedBackgroundClipTextPath.value
    );
  }
  return depsRenderResult + baseRenderResult + childrenRenderResult;
}

// src/font.ts
init_esm_shims();
import opentype from "@shuding/opentype.js";
function compareFont(weight, style, [weight1, style1], [weight2, style2]) {
  if (weight1 !== weight2) {
    if (!weight1)
      return 1;
    if (!weight2)
      return -1;
    if (weight1 === weight)
      return -1;
    if (weight2 === weight)
      return 1;
    if (weight === 400 && weight1 === 500)
      return -1;
    if (weight === 500 && weight1 === 400)
      return -1;
    if (weight === 400 && weight2 === 500)
      return 1;
    if (weight === 500 && weight2 === 400)
      return 1;
    if (weight < 400) {
      if (weight1 < weight && weight2 < weight)
        return weight2 - weight1;
      if (weight1 < weight)
        return -1;
      if (weight2 < weight)
        return 1;
      return weight1 - weight2;
    }
    if (weight < weight1 && weight < weight2)
      return weight1 - weight2;
    if (weight < weight1)
      return -1;
    if (weight < weight2)
      return 1;
    return weight2 - weight1;
  }
  if (style1 !== style2) {
    if (style1 === style)
      return -1;
    if (style2 === style)
      return 1;
  }
  return -1;
}
var FontLoader = class {
  constructor(fontOptions) {
    this.fonts = /* @__PURE__ */ new Map();
    this.addFonts(fontOptions);
  }
  get({
    name,
    weight,
    style
  }) {
    if (!this.fonts.has(name)) {
      return null;
    }
    if (weight === "normal")
      weight = 400;
    if (weight === "bold")
      weight = 700;
    const fonts = [...this.fonts.get(name)];
    let matchedFont = fonts[0];
    for (let i3 = 1; i3 < fonts.length; i3++) {
      const [, weight1, style1] = matchedFont;
      const [, weight2, style2] = fonts[i3];
      if (compareFont(weight, style, [weight1, style1], [weight2, style2]) > 0) {
        matchedFont = fonts[i3];
      }
    }
    return matchedFont[0];
  }
  addFonts(fontOptions) {
    for (const fontOption of fontOptions) {
      const data = fontOption.data;
      const font = opentype.parse(
        "buffer" in data ? data.buffer.slice(
          data.byteOffset,
          data.byteOffset + data.byteLength
        ) : data,
        { lowMemory: true }
      );
      const originalCharToGlyphIndex = font.charToGlyphIndex;
      font.charToGlyphIndex = (char) => {
        const index = originalCharToGlyphIndex.call(font, char);
        if (index === 0) {
          if (font._trackBrokenChars) {
            ;
            font._trackBrokenChars.push(char);
          }
        }
        return index;
      };
      if (!this.defaultFont)
        this.defaultFont = font;
      const name = fontOption.name.toLowerCase();
      if (!this.fonts.has(name)) {
        this.fonts.set(name, []);
      }
      this.fonts.get(name).push([font, fontOption.weight, fontOption.style]);
    }
  }
  getEngine(fontSize2 = 16, lineHeight2 = 1.2, {
    fontFamily: fontFamily2,
    fontWeight = 400,
    fontStyle = "normal"
  }) {
    if (!this.fonts.size) {
      throw new Error(
        "No fonts are loaded. At least one font is required to calculate the layout."
      );
    }
    fontFamily2 = (Array.isArray(fontFamily2) ? fontFamily2 : [fontFamily2]).map(
      (name) => name.toLowerCase()
    );
    const fonts = fontFamily2.map(
      (face) => this.get({
        name: face,
        weight: fontWeight,
        style: fontStyle
      })
    ).filter(Boolean);
    const keys = Array.from(this.fonts.keys());
    for (const name of keys) {
      if (fontFamily2.includes(name))
        continue;
      fonts.push(
        this.get({
          name,
          weight: fontWeight,
          style: fontStyle
        })
      );
    }
    const cachedFontResolver = /* @__PURE__ */ new Map();
    const resolveFont = (word, fallback = true) => {
      const code2 = word.charCodeAt(0);
      if (cachedFontResolver.has(code2))
        return cachedFontResolver.get(code2);
      const font = fonts.find((font2, index) => {
        return !!font2.charToGlyphIndex(word) || fallback && index === fonts.length - 1;
      });
      if (font) {
        cachedFontResolver.set(code2, font);
      }
      return font;
    };
    const ascender = (resolvedFont, useOS2Table = false) => {
      var _a2, _b;
      const ascender2 = (useOS2Table ? (_b = (_a2 = resolvedFont.tables) == null ? void 0 : _a2.os2) == null ? void 0 : _b.sTypoAscender : 0) || resolvedFont.ascender;
      return ascender2 / resolvedFont.unitsPerEm * fontSize2;
    };
    const descender = (resolvedFont, useOS2Table = false) => {
      var _a2, _b;
      const descender2 = (useOS2Table ? (_b = (_a2 = resolvedFont.tables) == null ? void 0 : _a2.os2) == null ? void 0 : _b.sTypoDescender : 0) || resolvedFont.descender;
      return descender2 / resolvedFont.unitsPerEm * fontSize2;
    };
    const resolve = (s2) => {
      return resolveFont(s2, false);
    };
    const engine = {
      has: (s2) => {
        if (s2 === "\n")
          return true;
        const font = resolve(s2);
        if (!font)
          return false;
        font._trackBrokenChars = [];
        font.stringToGlyphs(s2);
        if (!font._trackBrokenChars.length)
          return true;
        font._trackBrokenChars = void 0;
        return false;
      },
      baseline: (s2, resolvedFont = typeof s2 === "undefined" ? fonts[0] : resolveFont(s2)) => {
        const A = ascender(resolvedFont, true);
        const D2 = descender(resolvedFont, true);
        const glyphHeight = engine.height(s2, resolvedFont);
        const { yMax, yMin } = resolvedFont.tables.head;
        const sGlyphHeight = A - D2;
        const baselineOffset = (yMax / (yMax - yMin) - 1) * sGlyphHeight;
        return glyphHeight * ((1.2 / lineHeight2 + 1) / 2) + baselineOffset;
      },
      height: (s2, resolvedFont = typeof s2 === "undefined" ? fonts[0] : resolveFont(s2)) => {
        return (ascender(resolvedFont) - descender(resolvedFont)) * (lineHeight2 / 1.2);
      },
      measure: (s2, style) => {
        return this.measure(resolveFont, s2, style);
      },
      getSVG: (s2, style) => {
        return this.getSVG(resolveFont, s2, style);
      }
    };
    return engine;
  }
  patchFontFallbackResolver(font, resolveFont) {
    const brokenChars = [];
    font._trackBrokenChars = brokenChars;
    const originalStringToGlyphs = font.stringToGlyphs;
    font.stringToGlyphs = (s2, ...args) => {
      const glyphs = originalStringToGlyphs.call(font, s2, ...args);
      for (let i3 = 0; i3 < glyphs.length; i3++) {
        if (glyphs[i3].unicode === void 0) {
          const char = brokenChars.shift();
          const anotherFont = resolveFont(char);
          if (anotherFont !== font) {
            const glyph = anotherFont.charToGlyph(char);
            const scale = font.unitsPerEm / anotherFont.unitsPerEm;
            const p2 = new opentype.Path();
            p2.unitsPerEm = font.unitsPerEm;
            p2.commands = glyph.path.commands.map((command) => {
              const scaledCommand = { ...command };
              for (let k in scaledCommand) {
                if (typeof scaledCommand[k] === "number") {
                  scaledCommand[k] *= scale;
                }
              }
              return scaledCommand;
            });
            const g = new opentype.Glyph({
              ...glyph,
              advanceWidth: glyph.advanceWidth * scale,
              xMin: glyph.xMin * scale,
              xMax: glyph.xMax * scale,
              yMin: glyph.yMin * scale,
              yMax: glyph.yMax * scale,
              path: p2
            });
            glyphs[i3] = g;
          }
        }
      }
      return glyphs;
    };
    return () => {
      font.stringToGlyphs = originalStringToGlyphs;
      font._trackBrokenChars = void 0;
    };
  }
  measure(resolveFont, content, {
    fontSize: fontSize2,
    letterSpacing: letterSpacing2 = 0
  }) {
    const font = resolveFont(content);
    const unpatch = this.patchFontFallbackResolver(font, resolveFont);
    try {
      return font.getAdvanceWidth(content, fontSize2, {
        letterSpacing: letterSpacing2 / fontSize2
      });
    } finally {
      unpatch();
    }
  }
  getSVG(resolveFont, content, {
    fontSize: fontSize2,
    top,
    left,
    letterSpacing: letterSpacing2 = 0
  }) {
    const font = resolveFont(content);
    const unpatch = this.patchFontFallbackResolver(font, resolveFont);
    try {
      if (fontSize2 === 0) {
        return "";
      }
      return font.getPath(content.replace(/\n/g, ""), left, top, fontSize2, {
        letterSpacing: letterSpacing2 / fontSize2
      }).toPathData(1);
    } finally {
      unpatch();
    }
  }
};

// src/builder/svg.ts
init_esm_shims();
function svg({
  width,
  height,
  content
}) {
  return buildXMLString(
    "svg",
    {
      width,
      height,
      viewBox: `0 0 ${width} ${height}`,
      xmlns: "http://www.w3.org/2000/svg"
    },
    content
  );
}

// src/language.ts
init_esm_shims();
var code = {
  emoji: /\p{RI}\p{RI}|\p{Emoji}(\p{EMod}+|\u{FE0F}\u{20E3}?|[\u{E0020}-\u{E007E}]+\u{E007F})?(\u{200D}\p{Emoji}(\p{EMod}+|\u{FE0F}\u{20E3}?|[\u{E0020}-\u{E007E}]+\u{E007F})?)+|\p{EPres}(\p{EMod}+|\u{FE0F}\u{20E3}?|[\u{E0020}-\u{E007E}]+\u{E007F})?|\p{Emoji}(\p{EMod}+|\u{FE0F}\u{20E3}?|[\u{E0020}-\u{E007E}]+\u{E007F})|[\u{E000}-\u{F8FF}]|[\u{F0000}-\u{FFFFD}]|[\u{100000}-\u{10FFFD}]/u,
  ja: /\p{scx=Hira}|\p{scx=Kana}|[]/u,
  ko: /\p{scx=Hangul}/u,
  zh: /\p{scx=Han}/u,
  th: /\p{scx=Thai}/u,
  bn: /\p{scx=Bengali}/u,
  ar: /\p{scx=Arabic}/u,
  ta: /\p{scx=Tamil}/u,
  ml: /\p{scx=Malayalam}/u,
  he: /\p{scx=Hebrew}/u,
  te: /\p{scx=Telugu}/u,
  devanagari: /\p{scx=Devanagari}/u
};
function detectLanguageCode(segment2) {
  for (const c2 in code) {
    if (code[c2].test(segment2)) {
      return c2;
    }
  }
  return "unknown";
}

// src/handler/tailwind.ts
init_esm_shims();

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/create.js
init_esm_shims();
var import_resolveConfig = __toESM(require_resolveConfig2());

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/cache.js
init_esm_shims();

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/styles.js
init_esm_shims();

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/helpers.js
init_esm_shims();

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/types.js
init_esm_shims();
var PLATFORMS = [`ios`, `android`, `windows`, `macos`, `web`];
function isPlatform(x2) {
  return PLATFORMS.includes(x2);
}
var ORIENTATIONS = [`portrait`, `landscape`];
function isOrientation(x2) {
  return ORIENTATIONS.includes(x2);
}
var ConfigType;
(function(ConfigType2) {
  ConfigType2["fontSize"] = "fontSize";
  ConfigType2["lineHeight"] = "lineHeight";
})(ConfigType || (ConfigType = {}));
var Unit;
(function(Unit2) {
  Unit2["rem"] = "rem";
  Unit2["em"] = "em";
  Unit2["px"] = "px";
  Unit2["percent"] = "%";
  Unit2["vw"] = "vw";
  Unit2["vh"] = "vh";
  Unit2["none"] = "<no-css-unit>";
})(Unit || (Unit = {}));
function isString(value) {
  return typeof value === `string`;
}
function isObject(value) {
  return typeof value === `object`;
}

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/helpers.js
var _a;
function complete(style) {
  return { kind: `complete`, style };
}
function parseNumericValue(value, context = {}) {
  const { fractions } = context;
  if (fractions && value.includes(`/`)) {
    const [numerator = ``, denominator = ``] = value.split(`/`, 2);
    const parsedNumerator = parseNumericValue(numerator);
    const parsedDenominator = parseNumericValue(denominator);
    if (!parsedNumerator || !parsedDenominator) {
      return null;
    }
    return [parsedNumerator[0] / parsedDenominator[0], parsedDenominator[1]];
  }
  const number = parseFloat(value);
  if (Number.isNaN(number)) {
    return null;
  }
  const match = value.match(/(([a-z]{2,}|%))$/);
  if (!match) {
    return [number, Unit.none];
  }
  switch (match === null || match === void 0 ? void 0 : match[1]) {
    case `rem`:
      return [number, Unit.rem];
    case `px`:
      return [number, Unit.px];
    case `em`:
      return [number, Unit.em];
    case `%`:
      return [number, Unit.percent];
    case `vw`:
      return [number, Unit.vw];
    case `vh`:
      return [number, Unit.vh];
    default:
      return null;
  }
}
function getCompleteStyle(prop, value, context = {}) {
  const styleVal = parseStyleVal(value, context);
  return styleVal === null ? null : complete({ [prop]: styleVal });
}
function mergeStyle(prop, value, style) {
  const styleVal = parseStyleVal(value);
  if (styleVal !== null) {
    style[prop] = styleVal;
  }
  return style;
}
function getStyle(prop, value) {
  const styleVal = parseStyleVal(value);
  return styleVal === null ? null : { [prop]: styleVal };
}
function parseStyleVal(value, context = {}) {
  if (value === void 0) {
    return null;
  }
  const parsed = parseNumericValue(String(value), context);
  if (parsed) {
    return toStyleVal(...parsed, context);
  } else {
    return null;
  }
}
function toStyleVal(number, unit, context = {}) {
  const { isNegative, device } = context;
  switch (unit) {
    case Unit.rem:
      return number * 16 * (isNegative ? -1 : 1);
    case Unit.px:
      return number * (isNegative ? -1 : 1);
    case Unit.percent:
      return `${isNegative ? `-` : ``}${number}%`;
    case Unit.none:
      return number * (isNegative ? -1 : 1);
    case Unit.vw:
      if (!(device === null || device === void 0 ? void 0 : device.windowDimensions)) {
        warn(`\`vw\` CSS unit requires configuration with \`useDeviceContext()\``);
        return null;
      }
      return device.windowDimensions.width * (number / 100);
    case Unit.vh:
      if (!(device === null || device === void 0 ? void 0 : device.windowDimensions)) {
        warn(`\`vh\` CSS unit requires configuration with \`useDeviceContext()\``);
        return null;
      }
      return device.windowDimensions.height * (number / 100);
    default:
      return null;
  }
}
function toPx(value) {
  const parsed = parseNumericValue(value);
  if (!parsed) {
    return null;
  }
  const [number, unit] = parsed;
  switch (unit) {
    case Unit.rem:
      return number * 16;
    case Unit.px:
      return number;
    default:
      return null;
  }
}
var DIR_MAP = {
  t: `Top`,
  tr: `TopRight`,
  tl: `TopLeft`,
  b: `Bottom`,
  br: `BottomRight`,
  bl: `BottomLeft`,
  l: `Left`,
  r: `Right`,
  x: `Horizontal`,
  y: `Vertical`
};
function getDirection(string) {
  return DIR_MAP[string !== null && string !== void 0 ? string : ``] || `All`;
}
function parseAndConsumeDirection(utilityFragment) {
  let direction = `All`;
  const consumed = utilityFragment.replace(/^-(t|b|r|l|tr|tl|br|bl)(-|$)/, (_, dir) => {
    direction = getDirection(dir);
    return ``;
  });
  return [consumed, direction];
}
function parseUnconfigged(value, context = {}) {
  if (value.includes(`/`)) {
    const style = unconfiggedStyleVal(value, { ...context, fractions: true });
    if (style)
      return style;
  }
  if (value[0] === `[`) {
    value = value.slice(1, -1);
  }
  return unconfiggedStyleVal(value, context);
}
function unconfiggedStyle(prop, value, context = {}) {
  const styleVal = parseUnconfigged(value, context);
  if (styleVal === null) {
    return null;
  }
  return complete({ [prop]: styleVal });
}
function unconfiggedStyleVal(value, context = {}) {
  if (value === `px`) {
    return 1;
  }
  const parsed = parseNumericValue(value, context);
  if (!parsed) {
    return null;
  }
  let [number, unit] = parsed;
  if (context.fractions) {
    unit = Unit.percent;
    number *= 100;
  }
  if (unit === Unit.none) {
    number = number / 4;
    unit = Unit.rem;
  }
  return toStyleVal(number, unit, context);
}
function consoleWarn(...args) {
  console.warn(...args);
}
function noopWarn(..._) {
}
var warn = typeof process === `undefined` || ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.JEST_WORKER_ID) === void 0 ? consoleWarn : noopWarn;

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/styles.js
var defaultStyles = [
  [`aspect-square`, complete({ aspectRatio: 1 })],
  [`aspect-video`, complete({ aspectRatio: 16 / 9 })],
  [`items-center`, complete({ alignItems: `center` })],
  [`items-start`, complete({ alignItems: `flex-start` })],
  [`items-end`, complete({ alignItems: `flex-end` })],
  [`items-baseline`, complete({ alignItems: `baseline` })],
  [`items-stretch`, complete({ alignItems: `stretch` })],
  [`justify-start`, complete({ justifyContent: `flex-start` })],
  [`justify-end`, complete({ justifyContent: `flex-end` })],
  [`justify-center`, complete({ justifyContent: `center` })],
  [`justify-between`, complete({ justifyContent: `space-between` })],
  [`justify-around`, complete({ justifyContent: `space-around` })],
  [`justify-evenly`, complete({ justifyContent: `space-evenly` })],
  [`content-start`, complete({ alignContent: `flex-start` })],
  [`content-end`, complete({ alignContent: `flex-end` })],
  [`content-between`, complete({ alignContent: `space-between` })],
  [`content-around`, complete({ alignContent: `space-around` })],
  [`content-stretch`, complete({ alignContent: `stretch` })],
  [`content-center`, complete({ alignContent: `center` })],
  [`self-auto`, complete({ alignSelf: `auto` })],
  [`self-start`, complete({ alignSelf: `flex-start` })],
  [`self-end`, complete({ alignSelf: `flex-end` })],
  [`self-center`, complete({ alignSelf: `center` })],
  [`self-stretch`, complete({ alignSelf: `stretch` })],
  [`self-baseline`, complete({ alignSelf: `baseline` })],
  [`direction-inherit`, complete({ direction: `inherit` })],
  [`direction-ltr`, complete({ direction: `ltr` })],
  [`direction-rtl`, complete({ direction: `rtl` })],
  [`hidden`, complete({ display: `none` })],
  [`flex`, complete({ display: `flex` })],
  [`flex-row`, complete({ flexDirection: `row` })],
  [`flex-row-reverse`, complete({ flexDirection: `row-reverse` })],
  [`flex-col`, complete({ flexDirection: `column` })],
  [`flex-col-reverse`, complete({ flexDirection: `column-reverse` })],
  [`flex-wrap`, complete({ flexWrap: `wrap` })],
  [`flex-wrap-reverse`, complete({ flexWrap: `wrap-reverse` })],
  [`flex-nowrap`, complete({ flexWrap: `nowrap` })],
  [`flex-auto`, complete({ flexGrow: 1, flexShrink: 1, flexBasis: `auto` })],
  [`flex-initial`, complete({ flexGrow: 0, flexShrink: 1, flexBasis: `auto` })],
  [`flex-none`, complete({ flexGrow: 0, flexShrink: 0, flexBasis: `auto` })],
  [`overflow-hidden`, complete({ overflow: `hidden` })],
  [`overflow-visible`, complete({ overflow: `visible` })],
  [`overflow-scroll`, complete({ overflow: `scroll` })],
  [`absolute`, complete({ position: `absolute` })],
  [`relative`, complete({ position: `relative` })],
  [`italic`, complete({ fontStyle: `italic` })],
  [`not-italic`, complete({ fontStyle: `normal` })],
  [`oldstyle-nums`, fontVariant(`oldstyle-nums`)],
  [`small-caps`, fontVariant(`small-caps`)],
  [`lining-nums`, fontVariant(`lining-nums`)],
  [`tabular-nums`, fontVariant(`tabular-nums`)],
  [`proportional-nums`, fontVariant(`proportional-nums`)],
  [`font-thin`, complete({ fontWeight: `100` })],
  [`font-100`, complete({ fontWeight: `100` })],
  [`font-extralight`, complete({ fontWeight: `200` })],
  [`font-200`, complete({ fontWeight: `200` })],
  [`font-light`, complete({ fontWeight: `300` })],
  [`font-300`, complete({ fontWeight: `300` })],
  [`font-normal`, complete({ fontWeight: `normal` })],
  [`font-400`, complete({ fontWeight: `400` })],
  [`font-medium`, complete({ fontWeight: `500` })],
  [`font-500`, complete({ fontWeight: `500` })],
  [`font-semibold`, complete({ fontWeight: `600` })],
  [`font-600`, complete({ fontWeight: `600` })],
  [`font-bold`, complete({ fontWeight: `bold` })],
  [`font-700`, complete({ fontWeight: `700` })],
  [`font-extrabold`, complete({ fontWeight: `800` })],
  [`font-800`, complete({ fontWeight: `800` })],
  [`font-black`, complete({ fontWeight: `900` })],
  [`font-900`, complete({ fontWeight: `900` })],
  [`include-font-padding`, complete({ includeFontPadding: true })],
  [`remove-font-padding`, complete({ includeFontPadding: false })],
  [`max-w-none`, complete({ maxWidth: `99999%` })],
  [`text-left`, complete({ textAlign: `left` })],
  [`text-center`, complete({ textAlign: `center` })],
  [`text-right`, complete({ textAlign: `right` })],
  [`text-justify`, complete({ textAlign: `justify` })],
  [`text-auto`, complete({ textAlign: `auto` })],
  [`underline`, complete({ textDecorationLine: `underline` })],
  [`line-through`, complete({ textDecorationLine: `line-through` })],
  [`no-underline`, complete({ textDecorationLine: `none` })],
  [`uppercase`, complete({ textTransform: `uppercase` })],
  [`lowercase`, complete({ textTransform: `lowercase` })],
  [`capitalize`, complete({ textTransform: `capitalize` })],
  [`normal-case`, complete({ textTransform: `none` })],
  [`w-auto`, complete({ width: `auto` })],
  [`h-auto`, complete({ height: `auto` })],
  [
    `shadow-sm`,
    complete({
      shadowOffset: { width: 1, height: 1 },
      shadowColor: `#000`,
      shadowRadius: 1,
      shadowOpacity: 0.025,
      elevation: 1
    })
  ],
  [
    `shadow`,
    complete({
      shadowOffset: { width: 1, height: 1 },
      shadowColor: `#000`,
      shadowRadius: 1,
      shadowOpacity: 0.075,
      elevation: 2
    })
  ],
  [
    `shadow-md`,
    complete({
      shadowOffset: { width: 1, height: 1 },
      shadowColor: `#000`,
      shadowRadius: 3,
      shadowOpacity: 0.125,
      elevation: 3
    })
  ],
  [
    `shadow-lg`,
    complete({
      shadowOffset: { width: 1, height: 1 },
      shadowColor: `#000`,
      shadowOpacity: 0.15,
      shadowRadius: 8,
      elevation: 8
    })
  ],
  [
    `shadow-xl`,
    complete({
      shadowOffset: { width: 1, height: 1 },
      shadowColor: `#000`,
      shadowOpacity: 0.19,
      shadowRadius: 20,
      elevation: 12
    })
  ],
  [
    `shadow-2xl`,
    complete({
      shadowOffset: { width: 1, height: 1 },
      shadowColor: `#000`,
      shadowOpacity: 0.25,
      shadowRadius: 30,
      elevation: 16
    })
  ],
  [
    `shadow-none`,
    complete({
      shadowOffset: { width: 0, height: 0 },
      shadowColor: `#000`,
      shadowRadius: 0,
      shadowOpacity: 0,
      elevation: 0
    })
  ]
];
var styles_default = defaultStyles;
function fontVariant(type) {
  return {
    kind: `dependent`,
    complete(style) {
      if (!style.fontVariant || !Array.isArray(style.fontVariant)) {
        style.fontVariant = [];
      }
      style.fontVariant.push(type);
    }
  };
}

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/cache.js
var Cache = class {
  constructor(customStyles) {
    this.ir = new Map(styles_default);
    this.styles = /* @__PURE__ */ new Map();
    this.prefixes = /* @__PURE__ */ new Map();
    this.ir = new Map([...styles_default, ...customStyles !== null && customStyles !== void 0 ? customStyles : []]);
  }
  getStyle(key) {
    return this.styles.get(key);
  }
  setStyle(key, style) {
    this.styles.set(key, style);
  }
  getIr(key) {
    return this.ir.get(key);
  }
  setIr(key, ir) {
    this.ir.set(key, ir);
  }
  getPrefixMatch(key) {
    return this.prefixes.get(key);
  }
  setPrefixMatch(key, value) {
    this.prefixes.set(key, value);
  }
};

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/ClassParser.js
init_esm_shims();

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/resolve/font-size.js
init_esm_shims();
function fontSize(value, config2, context = {}) {
  const configValue = config2 === null || config2 === void 0 ? void 0 : config2[value];
  if (!configValue) {
    return unconfiggedStyle(`fontSize`, value, context);
  }
  if (typeof configValue === `string`) {
    return getCompleteStyle(`fontSize`, configValue);
  }
  let style = {};
  const [fontSize2, rest] = configValue;
  const fontSizeStyle = getStyle(`fontSize`, fontSize2);
  if (fontSizeStyle) {
    style = fontSizeStyle;
  }
  if (typeof rest === `string`) {
    return complete(mergeStyle(`lineHeight`, calculateLineHeight(rest, style), style));
  }
  const { lineHeight: lineHeight2, letterSpacing: letterSpacing2 } = rest;
  if (lineHeight2) {
    mergeStyle(`lineHeight`, calculateLineHeight(lineHeight2, style), style);
  }
  if (letterSpacing2) {
    mergeStyle(`letterSpacing`, letterSpacing2, style);
  }
  return complete(style);
}
function calculateLineHeight(lineHeight2, style) {
  const parsed = parseNumericValue(lineHeight2);
  if (parsed) {
    const [number, unit] = parsed;
    if ((unit === Unit.none || unit === Unit.em) && typeof style.fontSize === `number`) {
      return style.fontSize * number;
    }
  }
  return lineHeight2;
}

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/resolve/line-height.js
init_esm_shims();
function lineHeight(value, config2) {
  var _a2;
  const parseValue = (_a2 = config2 === null || config2 === void 0 ? void 0 : config2[value]) !== null && _a2 !== void 0 ? _a2 : value.startsWith(`[`) ? value.slice(1, -1) : value;
  const parsed = parseNumericValue(parseValue);
  if (!parsed) {
    return null;
  }
  const [number, unit] = parsed;
  if (unit === Unit.none) {
    return {
      kind: `dependent`,
      complete(style) {
        if (typeof style.fontSize !== `number`) {
          return `relative line-height utilities require that font-size be set`;
        }
        style.lineHeight = style.fontSize * number;
      }
    };
  }
  const styleVal = toStyleVal(number, unit);
  return styleVal !== null ? complete({ lineHeight: styleVal }) : null;
}

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/resolve/spacing.js
init_esm_shims();
function spacing(type, direction, isNegative, value, config2) {
  let numericValue = ``;
  if (value[0] === `[`) {
    numericValue = value.slice(1, -1);
  } else {
    const configValue = config2 === null || config2 === void 0 ? void 0 : config2[value];
    if (!configValue) {
      const unconfigged = parseUnconfigged(value);
      if (unconfigged && typeof unconfigged === `number`) {
        return spacingStyle(unconfigged, Unit.px, direction, type);
      }
      return null;
    } else {
      numericValue = configValue;
    }
  }
  if (numericValue === `auto`) {
    return expand2(direction, type, `auto`);
  }
  const parsed = parseNumericValue(numericValue);
  if (!parsed) {
    return null;
  }
  let [number, unit] = parsed;
  if (isNegative) {
    number = -number;
  }
  return spacingStyle(number, unit, direction, type);
}
function spacingStyle(number, unit, direction, type) {
  const pixels = toStyleVal(number, unit);
  if (pixels === null) {
    return null;
  }
  return expand2(direction, type, pixels);
}
function expand2(direction, type, value) {
  switch (direction) {
    case `All`:
      return {
        kind: `complete`,
        style: {
          [`${type}Top`]: value,
          [`${type}Right`]: value,
          [`${type}Bottom`]: value,
          [`${type}Left`]: value
        }
      };
    case `Bottom`:
    case `Top`:
    case `Left`:
    case `Right`:
      return {
        kind: `complete`,
        style: {
          [`${type}${direction}`]: value
        }
      };
    case `Vertical`:
      return {
        kind: `complete`,
        style: {
          [`${type}Top`]: value,
          [`${type}Bottom`]: value
        }
      };
    case `Horizontal`:
      return {
        kind: `complete`,
        style: {
          [`${type}Left`]: value,
          [`${type}Right`]: value
        }
      };
    default:
      return null;
  }
}

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/screens.js
init_esm_shims();
function screens(input) {
  if (!input) {
    return {};
  }
  const screenData = Object.entries(input).reduce((acc, [screen, value]) => {
    const data = [0, Infinity, 0];
    const values2 = typeof value === `string` ? { min: value } : value;
    const minPx = values2.min ? toPx(values2.min) : 0;
    if (minPx === null) {
      warn(`invalid screen config value: ${screen}->min: ${values2.min}`);
    } else {
      data[0] = minPx;
    }
    const maxPx = values2.max ? toPx(values2.max) : Infinity;
    if (maxPx === null) {
      warn(`invalid screen config value: ${screen}->max: ${values2.max}`);
    } else {
      data[1] = maxPx;
    }
    acc[screen] = data;
    return acc;
  }, {});
  const values = Object.values(screenData);
  values.sort((a2, b) => {
    const [minA, maxA] = a2;
    const [minB, maxB] = b;
    if (maxA === Infinity || maxB === Infinity) {
      return minA - minB;
    }
    return maxA - maxB;
  });
  let order = 0;
  values.forEach((value) => value[2] = order++);
  return screenData;
}

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/resolve/font-family.js
init_esm_shims();
function fontFamily(value, config2) {
  const configValue = config2 === null || config2 === void 0 ? void 0 : config2[value];
  if (!configValue) {
    return null;
  }
  if (typeof configValue === `string`) {
    return complete({ fontFamily: configValue });
  }
  const firstFamily = configValue[0];
  if (!firstFamily) {
    return null;
  }
  return complete({ fontFamily: firstFamily });
}

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/resolve/color.js
init_esm_shims();
function color(type, value, config2) {
  if (!config2) {
    return null;
  }
  let shorthandOpacity = void 0;
  if (value.includes(`/`)) {
    [value = ``, shorthandOpacity] = value.split(`/`, 2);
  }
  let color2 = ``;
  if (value.startsWith(`[#`) || value.startsWith(`[rgb`)) {
    color2 = value.slice(1, -1);
  } else {
    color2 = findColorInConfigRecursive(value, config2);
  }
  if (!color2) {
    return null;
  }
  if (shorthandOpacity) {
    const opacity2 = Number(shorthandOpacity);
    if (!Number.isNaN(opacity2)) {
      color2 = addOpacity(color2, opacity2 / 100);
      return complete({ [STYLE_PROPS[type].color]: color2 });
    }
  }
  return {
    kind: `dependent`,
    complete(style) {
      const opacityProp = STYLE_PROPS[type].opacity;
      const opacity2 = style[opacityProp];
      if (typeof opacity2 === `number`) {
        color2 = addOpacity(color2, opacity2);
      }
      style[STYLE_PROPS[type].color] = color2;
    }
  };
}
function colorOpacity(type, value) {
  const percentage = parseInt(value, 10);
  if (Number.isNaN(percentage)) {
    return null;
  }
  const opacity2 = percentage / 100;
  const style = { [STYLE_PROPS[type].opacity]: opacity2 };
  return { kind: `complete`, style };
}
function addOpacity(color2, opacity2) {
  if (color2.startsWith(`#`)) {
    color2 = hexToRgba(color2);
  } else if (color2.startsWith(`rgb(`)) {
    color2 = color2.replace(/^rgb\(/, `rgba(`).replace(/\)$/, `, 1)`);
  }
  return color2.replace(/, ?\d*\.?(\d+)\)$/, `, ${opacity2})`);
}
function removeOpacityHelpers(style) {
  for (const key in style) {
    if (key.startsWith(`__opacity_`)) {
      delete style[key];
    }
  }
}
var STYLE_PROPS = {
  bg: { opacity: `__opacity_bg`, color: `backgroundColor` },
  text: { opacity: `__opacity_text`, color: `color` },
  border: { opacity: `__opacity_border`, color: `borderColor` },
  borderTop: { opacity: `__opacity_border`, color: `borderTopColor` },
  borderBottom: { opacity: `__opacity_border`, color: `borderBottomColor` },
  borderLeft: { opacity: `__opacity_border`, color: `borderLeftColor` },
  borderRight: { opacity: `__opacity_border`, color: `borderRightColor` },
  shadow: { opacity: `__opacity_shadow`, color: `shadowColor` },
  tint: { opacity: `__opacity_tint`, color: `tintColor` }
};
function hexToRgba(hex) {
  const orig = hex;
  hex = hex.replace(MATCH_SHORT_HEX, (_, r2, g2, b2) => r2 + r2 + g2 + g2 + b2 + b2);
  const result = MATCH_FULL_HEX.exec(hex);
  if (!result) {
    warn(`invalid config hex color value: ${orig}`);
    return `rgba(0, 0, 0, 1)`;
  }
  const r = parseInt(result[1], 16);
  const g = parseInt(result[2], 16);
  const b = parseInt(result[3], 16);
  return `rgba(${r}, ${g}, ${b}, 1)`;
}
function findColorInConfigRecursive(colorName, config2) {
  const configColor = config2[colorName];
  if (isString(configColor)) {
    return configColor;
  } else if (isObject(configColor) && isString(configColor.DEFAULT)) {
    return configColor.DEFAULT;
  }
  let [colorNameStart = ``, ...colorNameRest] = colorName.split(`-`);
  while (colorNameStart !== colorName) {
    const subConfig = config2[colorNameStart];
    if (isObject(subConfig)) {
      return findColorInConfigRecursive(colorNameRest.join(`-`), subConfig);
    } else if (colorNameRest.length === 0) {
      return ``;
    }
    colorNameStart = `${colorNameStart}-${colorNameRest.shift()}`;
  }
  return ``;
}
var MATCH_SHORT_HEX = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
var MATCH_FULL_HEX = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/resolve/borders.js
init_esm_shims();
function border2(value, theme) {
  let [rest, direction] = parseAndConsumeDirection(value);
  const widthUtilityMatch = rest.match(/^(-?(\d)+)?$/);
  if (widthUtilityMatch) {
    return borderWidth(rest, direction, theme === null || theme === void 0 ? void 0 : theme.borderWidth);
  }
  rest = rest.replace(/^-/, ``);
  if ([`dashed`, `solid`, `dotted`].includes(rest)) {
    return complete({ borderStyle: rest });
  }
  let colorType = `border`;
  switch (direction) {
    case `Bottom`:
      colorType = `borderBottom`;
      break;
    case `Top`:
      colorType = `borderTop`;
      break;
    case `Left`:
      colorType = `borderLeft`;
      break;
    case `Right`:
      colorType = `borderRight`;
      break;
  }
  const colorStyle = color(colorType, rest, theme === null || theme === void 0 ? void 0 : theme.borderColor);
  if (colorStyle) {
    return colorStyle;
  }
  const prop = `border${direction === `All` ? `` : direction}Width`;
  rest = rest.replace(/^-/, ``);
  const numericValue = rest.slice(1, -1);
  const arbitraryWidth = unconfiggedStyle(prop, numericValue);
  if (typeof (arbitraryWidth === null || arbitraryWidth === void 0 ? void 0 : arbitraryWidth.style[prop]) !== `number`) {
    return null;
  }
  return arbitraryWidth;
}
function borderWidth(value, direction, config2) {
  if (!config2) {
    return null;
  }
  value = value.replace(/^-/, ``);
  const key = value === `` ? `DEFAULT` : value;
  const configValue = config2[key];
  if (configValue === void 0) {
    return null;
  }
  const prop = `border${direction === `All` ? `` : direction}Width`;
  return getCompleteStyle(prop, configValue);
}
function borderRadius(value, config2) {
  if (!config2) {
    return null;
  }
  let [rest, direction] = parseAndConsumeDirection(value);
  rest = rest.replace(/^-/, ``);
  if (rest === ``) {
    rest = `DEFAULT`;
  }
  const prop = `border${direction === `All` ? `` : direction}Radius`;
  const configValue = config2[rest];
  if (configValue) {
    return expand3(getCompleteStyle(prop, configValue));
  }
  const arbitrary = unconfiggedStyle(prop, rest);
  if (typeof (arbitrary === null || arbitrary === void 0 ? void 0 : arbitrary.style[prop]) !== `number`) {
    return null;
  }
  return expand3(arbitrary);
}
function expand3(ir) {
  if ((ir === null || ir === void 0 ? void 0 : ir.kind) !== `complete`)
    return ir;
  const top = ir.style.borderTopRadius;
  if (top !== void 0) {
    ir.style.borderTopLeftRadius = top;
    ir.style.borderTopRightRadius = top;
    delete ir.style.borderTopRadius;
  }
  const bottom = ir.style.borderBottomRadius;
  if (bottom !== void 0) {
    ir.style.borderBottomLeftRadius = bottom;
    ir.style.borderBottomRightRadius = bottom;
    delete ir.style.borderBottomRadius;
  }
  const left = ir.style.borderLeftRadius;
  if (left !== void 0) {
    ir.style.borderBottomLeftRadius = left;
    ir.style.borderTopLeftRadius = left;
    delete ir.style.borderLeftRadius;
  }
  const right = ir.style.borderRightRadius;
  if (right !== void 0) {
    ir.style.borderBottomRightRadius = right;
    ir.style.borderTopRightRadius = right;
    delete ir.style.borderRightRadius;
  }
  return ir;
}

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/resolve/inset.js
init_esm_shims();
function inset(type, value, isNegative, config2) {
  let insetDir = null;
  if (type === `inset`) {
    value = value.replace(/^(x|y)-/, (_, dir) => {
      insetDir = dir === `x` ? `x` : `y`;
      return ``;
    });
  }
  const configValue = config2 === null || config2 === void 0 ? void 0 : config2[value];
  if (configValue) {
    const styleVal = parseStyleVal(configValue, { isNegative });
    if (styleVal !== null) {
      return insetStyle(type, insetDir, styleVal);
    }
  }
  const unconfigged = parseUnconfigged(value, { isNegative });
  if (unconfigged !== null) {
    return insetStyle(type, insetDir, unconfigged);
  }
  return null;
}
function insetStyle(type, dir, styleVal) {
  if (type !== `inset`) {
    return complete({ [type]: styleVal });
  }
  switch (dir) {
    case null:
      return complete({
        top: styleVal,
        left: styleVal,
        right: styleVal,
        bottom: styleVal
      });
    case `y`:
      return complete({
        top: styleVal,
        bottom: styleVal
      });
    case `x`:
      return complete({
        left: styleVal,
        right: styleVal
      });
  }
}

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/resolve/flex.js
init_esm_shims();
function flexGrowShrink(type, value, config2) {
  var _a2;
  value = value.replace(/^-/, ``);
  const configKey = value === `` ? `DEFAULT` : value;
  const numericValue = Number((_a2 = config2 === null || config2 === void 0 ? void 0 : config2[configKey]) !== null && _a2 !== void 0 ? _a2 : value);
  if (!Number.isNaN(numericValue)) {
    return complete({ [`flex${type}`]: numericValue });
  }
  return null;
}
function flex(value, config2) {
  var _a2, _b;
  value = (config2 === null || config2 === void 0 ? void 0 : config2[value]) || value;
  if ([`min-content`, `revert`, `unset`].includes(value)) {
    return null;
  }
  if (value.match(/^\d+(\.\d+)?$/)) {
    return complete({
      flexGrow: Number(value),
      flexBasis: `0%`
    });
  }
  let match = value.match(/^(\d+)\s+(\d+)$/);
  if (match) {
    return complete({
      flexGrow: Number(match[1]),
      flexShrink: Number(match[2])
    });
  }
  match = value.match(/^(\d+)\s+([^ ]+)$/);
  if (match) {
    const flexBasis = parseStyleVal((_a2 = match[2]) !== null && _a2 !== void 0 ? _a2 : ``);
    if (!flexBasis) {
      return null;
    }
    return complete({
      flexGrow: Number(match[1]),
      flexBasis
    });
  }
  match = value.match(/^(\d+)\s+(\d+)\s+(.+)$/);
  if (match) {
    const flexBasis = parseStyleVal((_b = match[3]) !== null && _b !== void 0 ? _b : ``);
    if (!flexBasis) {
      return null;
    }
    return complete({
      flexGrow: Number(match[1]),
      flexShrink: Number(match[2]),
      flexBasis
    });
  }
  return null;
}

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/resolve/width-height.js
init_esm_shims();
function widthHeight(type, value, context = {}, config2) {
  const configValue = config2 === null || config2 === void 0 ? void 0 : config2[value];
  if (configValue !== void 0) {
    return getCompleteStyle(type, configValue, context);
  }
  return unconfiggedStyle(type, value, context);
}
function minMaxWidthHeight(type, value, context = {}, config2) {
  const styleVal = parseStyleVal(config2 === null || config2 === void 0 ? void 0 : config2[value], context);
  if (styleVal) {
    return complete({ [type]: styleVal });
  }
  if (value === `screen`) {
    value = type.includes(`Width`) ? `100vw` : `100vh`;
  }
  return unconfiggedStyle(type, value, context);
}

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/resolve/letter-spacing.js
init_esm_shims();
function letterSpacing(value, isNegative, config2) {
  const configValue = config2 === null || config2 === void 0 ? void 0 : config2[value];
  if (configValue) {
    const parsed = parseNumericValue(configValue, { isNegative });
    if (!parsed) {
      return null;
    }
    const [number, unit] = parsed;
    if (unit === Unit.em) {
      return relativeLetterSpacing(number);
    }
    if (unit === Unit.percent) {
      warn(`percentage-based letter-spacing configuration currently unsupported, switch to \`em\`s, or open an issue if you'd like to see support added.`);
      return null;
    }
    const styleVal = toStyleVal(number, unit, { isNegative });
    if (styleVal !== null) {
      return complete({ letterSpacing: styleVal });
    }
    return null;
  }
  return unconfiggedStyle(`letterSpacing`, value, { isNegative });
}
function relativeLetterSpacing(ems) {
  return {
    kind: `dependent`,
    complete(style) {
      const fontSize2 = style.fontSize;
      if (typeof fontSize2 !== `number` || Number.isNaN(fontSize2)) {
        return `tracking-X relative letter spacing classes require font-size to be set`;
      }
      style.letterSpacing = Math.round((ems * fontSize2 + Number.EPSILON) * 100) / 100;
    }
  };
}

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/resolve/opacity.js
init_esm_shims();
function opacity(value, config2) {
  const configValue = config2 === null || config2 === void 0 ? void 0 : config2[value];
  if (configValue) {
    const parsedConfig = parseNumericValue(String(configValue));
    if (parsedConfig) {
      return complete({ opacity: parsedConfig[0] });
    }
  }
  const parsedArbitrary = parseNumericValue(value);
  if (parsedArbitrary) {
    return complete({ opacity: parsedArbitrary[0] / 100 });
  }
  return null;
}

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/resolve/shadow.js
init_esm_shims();
function shadowOpacity(value) {
  const percentage = parseInt(value, 10);
  if (Number.isNaN(percentage)) {
    return null;
  }
  return {
    kind: `complete`,
    style: { shadowOpacity: percentage / 100 }
  };
}
function shadowOffset(value) {
  if (value.includes(`/`)) {
    const [widthStr = ``, heightStr = ``] = value.split(`/`, 2);
    const width = offsetValue(widthStr);
    const height = offsetValue(heightStr);
    if (width === null || height === null) {
      return null;
    }
    return {
      kind: `complete`,
      style: {
        shadowOffset: {
          width,
          height
        }
      }
    };
  }
  const number = offsetValue(value);
  if (number === null) {
    return null;
  }
  return {
    kind: `complete`,
    style: {
      shadowOffset: {
        width: number,
        height: number
      }
    }
  };
}
function offsetValue(value) {
  const parsed = parseUnconfigged(value);
  return typeof parsed === `number` ? parsed : null;
}

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/ClassParser.js
var ClassParser = class {
  constructor(input, config2 = {}, cache2, device, platform) {
    var _a2, _b, _c, _d, _e, _f;
    this.config = config2;
    this.cache = cache2;
    this.position = 0;
    this.isNull = false;
    this.isNegative = false;
    this.context = {};
    this.context.device = device;
    const parts = input.trim().split(`:`);
    let prefixes = [];
    if (parts.length === 1) {
      this.string = input;
    } else {
      this.string = (_a2 = parts.pop()) !== null && _a2 !== void 0 ? _a2 : ``;
      prefixes = parts;
    }
    this.char = this.string[0];
    const widthBreakpoints = screens((_b = this.config.theme) === null || _b === void 0 ? void 0 : _b.screens);
    for (const prefix of prefixes) {
      if (widthBreakpoints[prefix]) {
        const breakpointOrder = (_c = widthBreakpoints[prefix]) === null || _c === void 0 ? void 0 : _c[2];
        if (breakpointOrder !== void 0) {
          this.order = ((_d = this.order) !== null && _d !== void 0 ? _d : 0) + breakpointOrder;
        }
        const windowWidth = (_e = device.windowDimensions) === null || _e === void 0 ? void 0 : _e.width;
        if (windowWidth) {
          const [min, max] = (_f = widthBreakpoints[prefix]) !== null && _f !== void 0 ? _f : [0, 0];
          if (windowWidth <= min || windowWidth > max) {
            this.isNull = true;
          }
        } else {
          this.isNull = true;
        }
      } else if (isPlatform(prefix)) {
        this.isNull = prefix !== platform;
      } else if (isOrientation(prefix)) {
        if (!device.windowDimensions) {
          this.isNull = true;
        } else {
          const deviceOrientation = device.windowDimensions.width > device.windowDimensions.height ? `landscape` : `portrait`;
          if (deviceOrientation !== prefix) {
            this.isNull = true;
          } else {
            this.incrementOrder();
          }
        }
      } else if (prefix === `retina`) {
        if (device.pixelDensity === 2) {
          this.incrementOrder();
        } else {
          this.isNull = true;
        }
      } else if (prefix === `dark`) {
        if (device.colorScheme !== `dark`) {
          this.isNull = true;
        } else {
          this.incrementOrder();
        }
      } else if (!this.handlePossibleArbitraryBreakpointPrefix(prefix)) {
        this.isNull = true;
      }
    }
  }
  parse() {
    if (this.isNull) {
      return { kind: `null` };
    }
    const cached = this.cache.getIr(this.rest);
    if (cached) {
      return cached;
    }
    this.parseIsNegative();
    const ir = this.parseUtility();
    if (!ir) {
      return { kind: `null` };
    }
    if (this.order !== void 0) {
      return { kind: `ordered`, order: this.order, styleIr: ir };
    }
    return ir;
  }
  parseUtility() {
    var _a2, _b, _c, _d, _e;
    const theme = this.config.theme;
    let style = null;
    switch (this.char) {
      case `m`:
      case `p`: {
        const match = this.peekSlice(1, 3).match(/^(t|b|r|l|x|y)?-/);
        if (match) {
          const prop = this.char === `m` ? `margin` : `padding`;
          this.advance(((_b = (_a2 = match[0]) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b !== void 0 ? _b : 0) + 1);
          const spacingDirection = getDirection(match[1]);
          const style2 = spacing(prop, spacingDirection, this.isNegative, this.rest, (_c = this.config.theme) === null || _c === void 0 ? void 0 : _c[prop]);
          if (style2)
            return style2;
        }
      }
    }
    if (this.consumePeeked(`h-`)) {
      style = widthHeight(`height`, this.rest, this.context, theme === null || theme === void 0 ? void 0 : theme.height);
      if (style)
        return style;
    }
    if (this.consumePeeked(`w-`)) {
      style = widthHeight(`width`, this.rest, this.context, theme === null || theme === void 0 ? void 0 : theme.width);
      if (style)
        return style;
    }
    if (this.consumePeeked(`min-w-`)) {
      style = minMaxWidthHeight(`minWidth`, this.rest, this.context, theme === null || theme === void 0 ? void 0 : theme.minWidth);
      if (style)
        return style;
    }
    if (this.consumePeeked(`min-h-`)) {
      style = minMaxWidthHeight(`minHeight`, this.rest, this.context, theme === null || theme === void 0 ? void 0 : theme.minHeight);
      if (style)
        return style;
    }
    if (this.consumePeeked(`max-w-`)) {
      style = minMaxWidthHeight(`maxWidth`, this.rest, this.context, theme === null || theme === void 0 ? void 0 : theme.maxWidth);
      if (style)
        return style;
    }
    if (this.consumePeeked(`max-h-`)) {
      style = minMaxWidthHeight(`maxHeight`, this.rest, this.context, theme === null || theme === void 0 ? void 0 : theme.maxHeight);
      if (style)
        return style;
    }
    if (this.consumePeeked(`leading-`)) {
      style = lineHeight(this.rest, theme === null || theme === void 0 ? void 0 : theme.lineHeight);
      if (style)
        return style;
    }
    if (this.consumePeeked(`text-`)) {
      style = fontSize(this.rest, theme === null || theme === void 0 ? void 0 : theme.fontSize, this.context);
      if (style)
        return style;
      style = color(`text`, this.rest, theme === null || theme === void 0 ? void 0 : theme.textColor);
      if (style)
        return style;
      if (this.consumePeeked(`opacity-`)) {
        style = colorOpacity(`text`, this.rest);
        if (style)
          return style;
      }
    }
    if (this.consumePeeked(`font-`)) {
      style = fontFamily(this.rest, theme === null || theme === void 0 ? void 0 : theme.fontFamily);
      if (style)
        return style;
    }
    if (this.consumePeeked(`aspect-`)) {
      if (this.consumePeeked(`ratio-`)) {
        warn(`\`aspect-ratio-{ratio}\` is deprecated, use \`aspect-{ratio}\` instead`);
      }
      style = getCompleteStyle(`aspectRatio`, this.rest, { fractions: true });
      if (style)
        return style;
    }
    if (this.consumePeeked(`tint-`)) {
      style = color(`tint`, this.rest, theme === null || theme === void 0 ? void 0 : theme.colors);
      if (style)
        return style;
    }
    if (this.consumePeeked(`bg-`)) {
      style = color(`bg`, this.rest, theme === null || theme === void 0 ? void 0 : theme.backgroundColor);
      if (style)
        return style;
      if (this.consumePeeked(`opacity-`)) {
        style = colorOpacity(`bg`, this.rest);
        if (style)
          return style;
      }
    }
    if (this.consumePeeked(`border`)) {
      style = border2(this.rest, theme);
      if (style)
        return style;
      if (this.consumePeeked(`-opacity-`)) {
        style = colorOpacity(`border`, this.rest);
        if (style)
          return style;
      }
    }
    if (this.consumePeeked(`rounded`)) {
      style = borderRadius(this.rest, theme === null || theme === void 0 ? void 0 : theme.borderRadius);
      if (style)
        return style;
    }
    if (this.consumePeeked(`bottom-`)) {
      style = inset(`bottom`, this.rest, this.isNegative, theme === null || theme === void 0 ? void 0 : theme.inset);
      if (style)
        return style;
    }
    if (this.consumePeeked(`top-`)) {
      style = inset(`top`, this.rest, this.isNegative, theme === null || theme === void 0 ? void 0 : theme.inset);
      if (style)
        return style;
    }
    if (this.consumePeeked(`left-`)) {
      style = inset(`left`, this.rest, this.isNegative, theme === null || theme === void 0 ? void 0 : theme.inset);
      if (style)
        return style;
    }
    if (this.consumePeeked(`right-`)) {
      style = inset(`right`, this.rest, this.isNegative, theme === null || theme === void 0 ? void 0 : theme.inset);
      if (style)
        return style;
    }
    if (this.consumePeeked(`inset-`)) {
      style = inset(`inset`, this.rest, this.isNegative, theme === null || theme === void 0 ? void 0 : theme.inset);
      if (style)
        return style;
    }
    if (this.consumePeeked(`flex-`)) {
      if (this.consumePeeked(`grow`)) {
        style = flexGrowShrink(`Grow`, this.rest, theme === null || theme === void 0 ? void 0 : theme.flexGrow);
      } else if (this.consumePeeked(`shrink`)) {
        style = flexGrowShrink(`Shrink`, this.rest, theme === null || theme === void 0 ? void 0 : theme.flexShrink);
      } else {
        style = flex(this.rest, theme === null || theme === void 0 ? void 0 : theme.flex);
      }
      if (style)
        return style;
    }
    if (this.consumePeeked(`grow`)) {
      style = flexGrowShrink(`Grow`, this.rest, theme === null || theme === void 0 ? void 0 : theme.flexGrow);
      if (style)
        return style;
    }
    if (this.consumePeeked(`shrink`)) {
      style = flexGrowShrink(`Shrink`, this.rest, theme === null || theme === void 0 ? void 0 : theme.flexShrink);
      if (style)
        return style;
    }
    if (this.consumePeeked(`shadow-color-opacity-`)) {
      style = colorOpacity(`shadow`, this.rest);
      if (style)
        return style;
    }
    if (this.consumePeeked(`shadow-opacity-`)) {
      style = shadowOpacity(this.rest);
      if (style)
        return style;
    }
    if (this.consumePeeked(`shadow-offset-`)) {
      style = shadowOffset(this.rest);
      if (style)
        return style;
    }
    if (this.consumePeeked(`shadow-radius-`)) {
      style = unconfiggedStyle(`shadowRadius`, this.rest);
      if (style)
        return style;
    }
    if (this.consumePeeked(`shadow-`)) {
      style = color(`shadow`, this.rest, theme === null || theme === void 0 ? void 0 : theme.colors);
      if (style)
        return style;
    }
    if (this.consumePeeked(`elevation-`)) {
      const elevation = parseInt(this.rest, 10);
      if (!Number.isNaN(elevation)) {
        return complete({ elevation });
      }
    }
    if (this.consumePeeked(`opacity-`)) {
      style = opacity(this.rest, theme === null || theme === void 0 ? void 0 : theme.opacity);
      if (style)
        return style;
    }
    if (this.consumePeeked(`tracking-`)) {
      style = letterSpacing(this.rest, this.isNegative, theme === null || theme === void 0 ? void 0 : theme.letterSpacing);
      if (style)
        return style;
    }
    if (this.consumePeeked(`z-`)) {
      const zIndex = Number((_e = (_d = theme === null || theme === void 0 ? void 0 : theme.zIndex) === null || _d === void 0 ? void 0 : _d[this.rest]) !== null && _e !== void 0 ? _e : this.rest);
      if (!Number.isNaN(zIndex)) {
        return complete({ zIndex });
      }
    }
    warn(`\`${this.rest}\` unknown or invalid utility`);
    return null;
  }
  handlePossibleArbitraryBreakpointPrefix(prefix) {
    var _a2;
    if (prefix[0] !== `m`)
      return false;
    const match = prefix.match(/^(min|max)-(w|h)-\[([^\]]+)\]$/);
    if (!match)
      return false;
    if (!((_a2 = this.context.device) === null || _a2 === void 0 ? void 0 : _a2.windowDimensions)) {
      this.isNull = true;
      return true;
    }
    const windowDims = this.context.device.windowDimensions;
    const [, type = ``, dir = ``, amount = ``] = match;
    const checkDimension = dir === `w` ? windowDims.width : windowDims.height;
    const parsedAmount = parseNumericValue(amount, this.context);
    if (parsedAmount === null) {
      this.isNull = true;
      return true;
    }
    const [bound, unit] = parsedAmount;
    if (unit !== `px`) {
      this.isNull = true;
    }
    if (type === `min` ? checkDimension >= bound : checkDimension <= bound) {
      this.incrementOrder();
    } else {
      this.isNull = true;
    }
    return true;
  }
  advance(amount = 1) {
    this.position += amount;
    this.char = this.string[this.position];
  }
  get rest() {
    return this.peekSlice(0, this.string.length);
  }
  peekSlice(begin, end) {
    return this.string.slice(this.position + begin, this.position + end);
  }
  consumePeeked(string) {
    if (this.peekSlice(0, string.length) === string) {
      this.advance(string.length);
      return true;
    }
    return false;
  }
  parseIsNegative() {
    if (this.char === `-`) {
      this.advance();
      this.isNegative = true;
      this.context.isNegative = true;
    }
  }
  incrementOrder() {
    var _a2;
    this.order = ((_a2 = this.order) !== null && _a2 !== void 0 ? _a2 : 0) + 1;
  }
};

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/parse-inputs.js
init_esm_shims();
function parseInputs(inputs) {
  let classNames = [];
  let styles = null;
  inputs.forEach((input) => {
    if (typeof input === `string`) {
      classNames = [...classNames, ...split(input)];
    } else if (Array.isArray(input)) {
      classNames = [...classNames, ...input.flatMap(split)];
    } else if (typeof input === `object` && input !== null) {
      for (const [key, value] of Object.entries(input)) {
        if (typeof value === `boolean`) {
          classNames = [...classNames, ...value ? split(key) : []];
        } else if (styles) {
          styles[key] = value;
        } else {
          styles = { [key]: value };
        }
      }
    }
  });
  return [classNames.filter(Boolean).filter(unique), styles];
}
function split(str) {
  return str.trim().split(/\s+/);
}
function unique(className, index, classes) {
  return classes.indexOf(className) === index;
}

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/plugin.js
init_esm_shims();
function getAddedUtilities(plugins) {
  var _a2;
  return (_a2 = plugins === null || plugins === void 0 ? void 0 : plugins.reduce((utils, plugin) => ({ ...utils, ...callPluginFunction(plugin.handler) }), {})) !== null && _a2 !== void 0 ? _a2 : {};
}
function callPluginFunction(pluginFn) {
  let added = {};
  pluginFn({
    addUtilities: (utilities) => {
      added = utilities;
    },
    ...core
  });
  return added;
}
function notImplemented(fn) {
  throw new Error(`tailwindcss plugin function argument object prop "${fn}" not implemented`);
}
var core = {
  addComponents: notImplemented,
  addBase: notImplemented,
  addVariant: notImplemented,
  e: notImplemented,
  prefix: notImplemented,
  theme: notImplemented,
  variants: notImplemented,
  config: notImplemented,
  corePlugins: notImplemented,
  matchUtilities: notImplemented,
  postcss: null
};

// node_modules/.pnpm/twrnc@3.4.0/node_modules/twrnc/dist/esm/create.js
function create(customConfig, platform) {
  const config2 = (0, import_resolveConfig.default)(withContent(customConfig));
  const device = {};
  const pluginUtils = getAddedUtilities(config2.plugins);
  const customStringUtils = {};
  const customStyleUtils = Object.entries(pluginUtils).map(([util, style2]) => {
    if (typeof style2 === `string`) {
      customStringUtils[util] = style2;
      return [util, { kind: `null` }];
    }
    return [util, complete(style2)];
  }).filter(([, ir]) => ir.kind !== `null`);
  function deriveCacheGroup() {
    return [
      device.windowDimensions ? `w${device.windowDimensions.width}` : false,
      device.windowDimensions ? `h${device.windowDimensions.height}` : false,
      device.fontScale ? `fs${device.fontScale}` : false,
      device.colorScheme === `dark` ? `dark` : false,
      device.pixelDensity === 2 ? `retina` : false
    ].filter(Boolean).join(`--`) || `default`;
  }
  let cacheGroup = deriveCacheGroup();
  const contextCaches = {};
  function getCache() {
    const existing = contextCaches[cacheGroup];
    if (existing) {
      return existing;
    }
    const cache2 = new Cache(customStyleUtils);
    contextCaches[cacheGroup] = cache2;
    return cache2;
  }
  function style(...inputs) {
    const cache2 = getCache();
    let resolved = {};
    const dependents = [];
    const ordered = [];
    const [utilities, userStyle] = parseInputs(inputs);
    const joined = utilities.join(` `);
    const cached = cache2.getStyle(joined);
    if (cached) {
      return { ...cached, ...userStyle ? userStyle : {} };
    }
    for (const utility of utilities) {
      let styleIr = cache2.getIr(utility);
      if (!styleIr && utility in customStringUtils) {
        const customStyle = style(customStringUtils[utility]);
        cache2.setIr(utility, complete(customStyle));
        resolved = { ...resolved, ...customStyle };
        continue;
      }
      const parser = new ClassParser(utility, config2, cache2, device, platform);
      styleIr = parser.parse();
      switch (styleIr.kind) {
        case `complete`:
          resolved = { ...resolved, ...styleIr.style };
          cache2.setIr(utility, styleIr);
          break;
        case `dependent`:
          dependents.push(styleIr);
          break;
        case `ordered`:
          ordered.push(styleIr);
          break;
        case `null`:
          cache2.setIr(utility, styleIr);
          break;
      }
    }
    if (ordered.length > 0) {
      ordered.sort((a2, b) => a2.order - b.order);
      for (const orderedStyle of ordered) {
        switch (orderedStyle.styleIr.kind) {
          case `complete`:
            resolved = { ...resolved, ...orderedStyle.styleIr.style };
            break;
          case `dependent`:
            dependents.push(orderedStyle.styleIr);
            break;
        }
      }
    }
    if (dependents.length > 0) {
      for (const dependent of dependents) {
        const error = dependent.complete(resolved);
        if (error) {
          warn(error);
        }
      }
      removeOpacityHelpers(resolved);
    }
    if (joined !== ``) {
      cache2.setStyle(joined, resolved);
    }
    if (userStyle) {
      resolved = { ...resolved, ...userStyle };
    }
    return resolved;
  }
  function color2(utils) {
    const styleObj = style(utils.split(/\s+/g).map((util) => util.replace(/^(bg|text|border)-/, ``)).map((util) => `bg-${util}`).join(` `));
    return typeof styleObj.backgroundColor === `string` ? styleObj.backgroundColor : void 0;
  }
  const tailwindFn = (strings, ...values) => {
    let str = ``;
    strings.forEach((string, i3) => {
      var _a2;
      str += string + ((_a2 = values[i3]) !== null && _a2 !== void 0 ? _a2 : ``);
    });
    return style(str);
  };
  tailwindFn.style = style;
  tailwindFn.color = color2;
  tailwindFn.prefixMatch = (...prefixes) => {
    const joined = prefixes.sort().join(`:`);
    const cache2 = getCache();
    const cached = cache2.getPrefixMatch(joined);
    if (cached !== void 0) {
      return cached;
    }
    const parser = new ClassParser(`${joined}:flex`, config2, cache2, device, platform);
    const ir = parser.parse();
    const prefixMatches = ir.kind !== `null`;
    cache2.setPrefixMatch(joined, prefixMatches);
    return prefixMatches;
  };
  tailwindFn.setWindowDimensions = (newDimensions) => {
    device.windowDimensions = newDimensions;
    cacheGroup = deriveCacheGroup();
  };
  tailwindFn.setFontScale = (newFontScale) => {
    device.fontScale = newFontScale;
    cacheGroup = deriveCacheGroup();
  };
  tailwindFn.setPixelDensity = (newPixelDensity) => {
    device.pixelDensity = newPixelDensity;
    cacheGroup = deriveCacheGroup();
  };
  tailwindFn.setColorScheme = (newColorScheme) => {
    device.colorScheme = newColorScheme;
    cacheGroup = deriveCacheGroup();
  };
  return tailwindFn;
}
function withContent(config2) {
  return {
    ...config2,
    content: [`_no_warnings_please`]
  };
}

// src/handler/tailwind.ts
var config = {
  plugins: [
    {
      handler: ({ addUtilities }) => {
        const presets = {
          "shadow-sm": { boxShadow: "0 1px 2px 0 rgb(0 0 0 / 0.05)" },
          shadow: {
            boxShadow: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)"
          },
          "shadow-md": {
            boxShadow: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)"
          },
          "shadow-lg": {
            boxShadow: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)"
          },
          "shadow-xl": {
            boxShadow: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)"
          },
          "shadow-2xl": {
            boxShadow: "0 25px 50px -12px rgb(0 0 0 / 0.25)"
          },
          "shadow-inner": {
            boxShadow: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)"
          },
          "shadow-none": { boxShadow: "0 0 #0000" }
        };
        addUtilities(presets);
      }
    }
  ]
};
function createTw() {
  return create(config, "web");
}
var tw;
function getTw({
  width,
  height
}) {
  if (!tw) {
    tw = createTw();
  }
  tw.setWindowDimensions({ width: +width, height: +height });
  return tw;
}

// src/satori.ts
import { virtualSheet } from "twind/sheets";
import * as twind from "twind";
var sheet = virtualSheet();
var i2 = twind.create({
  sheet,
  mode: "strict",
  preflight: false,
  prefix: false
});
var fontCache = /* @__PURE__ */ new WeakMap();
async function satori(element, options) {
  const Yoga2 = getYoga();
  if (!Yoga2)
    throw new Error("Satori is not initialized.");
  let font;
  if (fontCache.has(options.fonts)) {
    font = fontCache.get(options.fonts);
  } else {
    fontCache.set(options.fonts, font = new FontLoader(options.fonts));
  }
  const root = Yoga2.Node.create();
  root.setWidth(options.width);
  root.setHeight(options.height);
  root.setFlexDirection(Yoga2.FLEX_DIRECTION_ROW);
  root.setFlexWrap(Yoga2.WRAP_WRAP);
  root.setAlignContent(Yoga2.ALIGN_AUTO);
  root.setAlignItems(Yoga2.ALIGN_FLEX_START);
  root.setJustifyContent(Yoga2.JUSTIFY_FLEX_START);
  root.setOverflow(Yoga2.OVERFLOW_HIDDEN);
  const graphemeImages = { ...options.graphemeImages };
  const handler2 = layout(element, {
    id: "id",
    parentStyle: {},
    inheritedStyle: {
      fontSize: 16,
      fontWeight: "normal",
      fontFamily: "serif",
      fontStyle: "normal",
      lineHeight: 1.2,
      color: "black",
      opacity: 1,
      whiteSpace: "normal",
      _viewportWidth: options.width,
      _viewportHeight: options.height
    },
    parent: root,
    font,
    embedFont: options.embedFont,
    debug: options.debug,
    graphemeImages,
    canLoadAdditionalAssets: !!options.loadAdditionalAsset,
    getTwStyles: (tw2, style) => {
      sheet.reset();
      i2.tw(tw2);
      console.log(tw2, sheet.target);
      const twToStyles = getTw({
        width: options.width,
        height: options.height
      });
      const twStyles = { ...twToStyles([tw2]) };
      if (typeof twStyles.lineHeight === "number") {
        twStyles.lineHeight = twStyles.lineHeight / (+twStyles.fontSize || style.fontSize || 16);
      }
      if (twStyles.shadowColor && twStyles.boxShadow) {
        twStyles.boxShadow = twStyles.boxShadow.replace(
          /rgba?\([^)]+\)/,
          twStyles.shadowColor
        );
      }
      return twStyles;
    }
  });
  let segmentsMissingFont = (await handler2.next()).value;
  if (options.loadAdditionalAsset) {
    if (segmentsMissingFont.length) {
      segmentsMissingFont = Array.from(
        new Set(segment(segmentsMissingFont.join(""), "grapheme"))
      );
      const languageCodes = {};
      segmentsMissingFont.forEach((seg) => {
        const code2 = detectLanguageCode(seg);
        languageCodes[code2] = languageCodes[code2] || [];
        if (code2 === "emoji") {
          languageCodes[code2].push(seg);
        } else {
          languageCodes[code2][0] = (languageCodes[code2][0] || "") + seg;
        }
      });
      const fonts = [];
      const images = {};
      await Promise.all(
        Object.entries(languageCodes).flatMap(
          ([code2, segments]) => segments.map(
            (segment2) => options.loadAdditionalAsset(code2, segment2).then((asset) => {
              if (typeof asset === "string") {
                images[segment2] = asset;
              } else if (asset) {
                fonts.push(asset);
              }
            })
          )
        )
      );
      font.addFonts(fonts);
      Object.assign(graphemeImages, images);
    }
  }
  await handler2.next();
  root.calculateLayout(options.width, options.height, Yoga2.DIRECTION_LTR);
  const content = (await handler2.next([0, 0])).value;
  root.freeRecursive();
  return svg({ width: options.width, height: options.height, content });
}
export {
  satori as default,
  init
};
//# sourceMappingURL=index.wasm.js.map